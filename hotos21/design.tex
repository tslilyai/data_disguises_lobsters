%-------------------------------------------------------------------------------
\section{Data Disguising}
%-------------------------------------------------------------------------------
\begin{figure}[t!]
    \centering
    \includegraphics[width=0.5\textwidth]{img/disguises}

    \caption{Disguises move the target object (in this example, a user Bob) from an identity-revealing
    guise to privacy-preserving guises.}
    \label{fig:example}
\end{figure}

%\lyt{TODO (Frans): drive w/explicit example of table rows and foreign key relationships, too
%abstract. Start with Figure~\ref{fig:arch}?}

\begin{figure*}[t!]
    \centering
    \footnotesize
\begin{tabular}{@{}c|c|c|c@{}}
\textbf{User Transformation Spec} & \textbf{Template User} & \textbf{Guise 1} &
    \textbf{Guise 2} \\
\begin{lstlisting}[language=Rust]
"id":       IDAttribute,
"name":     Gen(Random),
"active":   Gen(Default(false)),
"darkmode": CopyAll,
"notifs":   CopyOnce+Gen(Default(false)),
"tag_id":   GenForeignKey,
\end{lstlisting}
    &
\begin{lstlisting}[language=Rust]
"id":       19,
"name":     BobParr,
"active":   true,
"darkmode": false,
"notifs":   true,
"tag_id":   11
\end{lstlisting}
&
\begin{lstlisting}[language=Rust]
"id":       295,
"name":     MrIncredible,
"active":   false,
"darkmode": false,
"notifs":   true,
"tag_id":   81483
\end{lstlisting}
&
\begin{lstlisting}[language=Rust]
"id":       918,
"name":     SuperDad,
"active":   false,
"darkmode": false,
"notifs":   false,
"tag_id":   15592
\end{lstlisting}
\end{tabular}
    \caption{Creating two guises of an example user (of a synthetic application schema).}
    \label{fig:guises}
\end{figure*}


%
The key idea behind \emph{data disguising} is to associate multiple \emph{guises} with a target
data object: some guises are identity-revealing, while others are privacy-preserving.
%
Objects move between different guises by means of privacy transformations.
%
Figure~\ref{fig:example} illustrates this with the example of user account deletion.
%
When his account is active, user Bob's profile is associated with his true identity and all his
contributions to the site (an identity-revealing guise).
%
When Bob deletes his account, his profile and contributions move to different,
privacy-preserving guises: his profile is now associated with an anonymizing name, his email
address redacted, and his contributions are decorrelated and attributed to individual,
unidentified user guises.
%

%
Data disguising builds on the existing structure of web applications.
%
Web applications are often structured as object graphs, either explicitly~\cite{tao, delf},
through an object-relational model (ORM)~\cite{orm}, or implicitly via foreign keys (edges)
between tables (vertices) in relational databases.
%
Data disguises transform the content and structure of this object graph.
%

%
The application developer writes a disguise specification for each privacy transformation needed
in the application.
%
This specification is a declarative statement similar to a relational schema, with entries for
graph vertices (objects) and directed edges (relationships between pairs of objects)
to be transformed (see \S\ref{sec:policies}).
%
We assume that:
\begin{enumerate}[nosep]
  \item developers use their domain knowledge to write correct and complete disguises;
    %\lyt{a bit worried about ``complete'' here}
  \item that application code handles the different guises appropriately (\eg in
    displaying them); and
  \item that different guises of the same object have the same structure (\eg they can be
    rows in the same table).
\end{enumerate}
%
A data disguising tool takes the disguise specification and turns it into storage operations that
apply the transformation (disguise) or its reverse (reveal).
%
% Malte: I don't think the following is fundamental
%The tool proxies application queries to its data storage, and exposes ``DISGUISE'' and
%``REVERSE DISGUISE" operations that invoke the disguise on transformation-triggering events
%(\eg user account deletion, data timeout, etc.).
%\lyt{This repeats the intro currently; perhaps we want to put it only there?}
%

%\begin{enumerate}[nosep]
  %\item application developers use their domain knowledge to write correct and complete
    %disguise specifications;
%\item \lyt{Not sure we need this?} application code invokes disguises via the disguising tool's API on
 %   transformation-triggering events (\eg user account deletion, data timeout, etc.); and
%  \item application code is prepared to handle the different guises appropriately (\eg in displaying
%      them); guises have the same structure as application objects (\eg exist as rows in existing
%        application tables).
%\end{enumerate}
%
An application's data object graph thus, at any point in time, consists of a mix of
identity-revealing guises and privacy-preserving ones, with privacy transformations splitting
and combining individual guises when triggered.
%
%Using their application expertise, the developer selects from a menu of possible transformations
%(Section~\ref{sec:policies}) that can be performed on objects and object graph edges.
%The data disguise consists of the chosen set of transformations, and determines the
%structure of the object graph after a target (\eg the unsubscribing user) is disguised.
%
%Disguising a target object creates \emph{guises}---transformed versions and/or copies of the target.
%Disguising requires object deletion and anonymization: guises help maintain referential integrity
%when data is deleted, and transform objects into anonymized forms.  Guises additionally decorrelate
%other objects from the target: for example, a new guise for the user can be created in the users
%table, and the foreign key relationship from a row in the posts table rewritten to point this guise,
%to decorrelate the post from the user.

%-------------------------------------------------------------------------------
\section{Specifying Data Disguises}
%-------------------------------------------------------------------------------
\label{sec:policies}

%
Each data disguise consists of a set of transformations on object types and edge types in the
application object graph.
%
The disguising tool applies these transformations by traversing the graph, starting from a
developer-specified target object, such as a deleted user.
%
%The developer chooses one transformation for each object type, and
%one for each edge type.
%Object type transformations specify how to transform a template object of that type into guises; edge type
%transformations specify whether to delete, retain, or decorrelate edges of that type.
%where decorrelation replaces the edge with edges to guises.

%We next describe a menu of object and edge transformations sufficient to write disguises for the
%privacy transformations in Section~\ref{sec:survey}.

\subsection{Creating Guises for Objects}
\label{sec:guises}

\ms{``template object'' is a new term. Previously, we referred to all versions of an object
as ``guises''. Is there a special guise that corresponds to the template object?}
%
To create a guise from a \emph{template object}, developers specify how to transform
attributes of the template object into guise attributes.
%
An object has three kinds of attributes: a unique identifier attribute; value
(non-referential) attributes such as timestamps or usernames; and edge (\eg foreign key)
attributes that refer to other objects.
%
Figure~\ref{fig:guises} shows an example, producing guises for user objects.
%
User objects have \texttt{id} as the identifier attribute,
\texttt{tag\_id} as an edge attribute (a foreign key constraint to tag objects),
and all other attributes as value attributes.
%

Guises always have unique, random identifier attributes.
Developers choose how to create guise edge and value attributes, selecting from the following:

\paragraph{(1) Copy object content.} Guises of the same template object all share the template's
    attribute value. If the attribute is an edge attribute (\eg is a foreign key column),
    all guises will share an edge to the same object.

    Copying allows developers to retain the template's content, without worrying about how to
    synthesize attribute values for guises.
    %However, this should only be chosen if guise attribute
    %values cannot be generated, or if this attribute says little about the true identity of the
    %entity.
    For example, Figure~\ref{fig:guises} shows how the \texttt{darkmode} attribute is copied in
    all guises.
    %; the \texttt{darkmode} attribute reveals very little about the underlying user's
    %identity.

\paragraph{(2) Generate new content.}
        To create new value attributes, developers specify whether the guise's value should be random,
        a default value, or generated from the template value via a custom function (\eg a hash of
        the template value). Figure~\ref{fig:guises} illustrates
        an example of random (\texttt{name}) and default (\texttt{active}) generated value attributes.

        To create new guise edge attributes (\eg new foreign key relationships), the data disguise
        recursively generates a guise for the connected object, and rewrites the edge to point to
        the new guise.  In Figure~\ref{fig:guises}, creating two user guises recursively creates two
        tag guises; the tag guises' identifiers become the user guises' foreign keys.

\paragraph{(3) Copy object content, but only once.}
%
One guise copies the attribute value from the template object, but all other guises generate new
values (as described above).
%
\texttt{notifs} in Figure~\ref{fig:guises} illustrates how the attribute is copied once.
%
This enables the application to retain the original object content (\eg a count of how many
users want notifications), without creating duplicates.
%

\subsection{Transforming Edges Between Objects}
\label{design:edgepol}

\ms{to discuss: recursive guise creation (described above) also restructures the object graph,
namely by introducing new objects and connecting them with others. Do we need to differentiate?}
%
Edge transformations specify how guises \emph{restructure} the object graph.
%
Disguises apply edge transformations while recursively traversing edges from the target.
%
For clarity, we refer to edges as between a \emph{parent} object and a \emph{child} object,
where the child references the parent (\eg via a foreign key column in a relational database).
%
The developer specifies transformations for each edge type, choosing from the following:
%
\begin{enumerate}[nosep]
    %
    \item \textbf{Retain} edges of this type. Transform both parent and child objects into a
      single guise each.
    %
    \item \textbf{Decorrelate} edges of this type. Create one guise of the parent (using the
      parent as template) for each of the children; replace each child's edge to the parent
      with an edge to that unique guise.
    %
    \item \textbf{Delete} edges of this type. Transform the parent object into a single
      guise; remove the child \ms{what if child has other incoming edges?} and its descendants.
    %
\end{enumerate}
%
Optional arguments enables conditionally-applied edge transformations, \eg removing only
user-created tags; or removing tags only until the user's papers comprise less than
$10$\% of tagged papers; or transforming only in the child-parent direction.
%
\ms{above specifies only parent-child direction; is there a reverse too? Let's discuss.}

\subsection{An Example Disguise}
\label{design:eg}
%
Consider disguising Bob when he deletes his HotCRP account.
%
Bob would prefer his papers and reviews to be unliked from his identity.
%
HotCRP, on the other hand, would like to retain paper and review information that other users
find useful.
%
A careful selection of edge and object transformations achieves both.
%

%
To decorrelate reviews from Bob, the disguise \texttt{Decorrelate}s user-to-review edges.
%
This requires transforming Bob into one unique user guise per review.
%
To do so, the disguise generates guise attribute values using suitable defaults.
%
In particular, it specifies to set HotCRP users's \texttt{disabled} attribute for the guises,
ensuring that guises have no permissions and never review papers.
%

%
Bob is further linked to papers through conflicts, which can indicate coauthorship or a
reviewer conflict.
%
Bob's conflict with a specific paper should not be reassigned to a user guise: the remaining set
of conflicts can reidentify the guise through the implied affiliation and collaborations.
%
Instead, the conflict-to-paper edges need a \texttt{Delete} annotation.
%
Edge directionality matters here: paper-to-conflict edges should not be removed, as doing so
could incorrectly allow conflicted users to see the paper!

The disguise \texttt{Retain}s all other edge types, ensuring that review and paper
artifacts remain correctly linked: active reviewers still see the correct paper for their
reviews, and active authors see the correct reviews for their papers, albeit authored by
anonymous, unlinkable guises of the original author.
%
Review and paper guises copy the original object, retaining paper and review information.
%
\ms{Does this mean duplicate papers/reviews can show up?}

%
Unlike the current real-world HotCRP account deletion policy~\cite{hotcrp:privacy}, which
deletes all objects belonging to Bob, this disguise strikes a balance between decorrelating
Bob's identity from his reviews and papers, and maintaining useful information for other
HotCRP users.
%
Furthermore, it is easy to imagine extending this disguise to automatically disguise Bob
after some time (\eg 2 years after the conference), protecting his future research career
by hiding youthful reviewing sins.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
%By default, all \emph{sensitive} entities---entities transitively connected via
%parent-child edges to the mask's target entity---transform into with ghost entities.
%For example, in Figure~\ref{fig:edgepol}a, all reviews and papers of the unsubscribing user are by
%default replaced by ghosts.

%Any parent of a sensitive child is ghosted as well. This is not actually true; we retain the
%original parent entity, but allow it to be decorrelated
%\lyt{Child-to-Parent edges can have different ghost
%generation policies + edge policies than Parent-to-Child edges. I'm not sure if we should mention
%that here (seems too detailed?)}

\paragraph{Child-Parent Edge Transformations.}
Data masks also allow the developer to specify edge transformations in the child-parent direction,
namely from sensitive children to parents that are not descendants of the user.
%
For example, papers have both tags and users as parents. If an unsubscribed user authors all papers
with a particular tag, the developer may realize that the tag can reidentify the user, and want to
decorrelate the paper from the tag.

Because parents of sensitive children may have non-sensitive children (\eg many papers may share
tags with the user's papers), decorrelation and delete transformations in the child-parent direction
take a \textbf{sensitivity threshold} as an argument, which tells the mask how many edges need to be
decorrelated or deleted.

In the paper-tag example, a reasonable sensitivity threshold
might be $0.1$: fewer than 10\% of all papers with a specific tag key should be correlated with an
(unsubscribed) user.  Figure~\ref{fig:sensitivity} shows an example in which paper-tag edges are
decorrelated to meet a threshold of 0.5.

\paragraph{Edge Transformation Filters}
For decorrelation or delete transformations (in either parent-child or child-parent directions), the
developer can additionally specify an \textbf{edge filter}. The filter takes the parent and child
entities of the edge as inputs, and returns whether the entities satisfy the filter. If yes, the
edge is decorrelated or deleted; otherwise, the edge is retained.
%
For example, perhaps we want to remove tags from a user's papers (decorrelate paper-tag edges)
\emph{only if} the tags were created by the unsubscribing user.
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
\sys also handles user data management and storage.
While unsubscribing a user, \sys tracks all deletions and modifications to the database.
\sys encrypts this log with a per-user key, and stores this encrypted
blob in a dedicated application datastore (Figure~\ref{fig:arch}, step 5). The user key is secret-shared using a (2, 3)
threshold scheme~\cite{secretsharing} between the user, \sys, and a trusted third party (\eg
Amazon S3), so that the user can authorize \sys and the third party to restore the key if
the user forgets their share.
%Alternatively, the key can also be password-encrypted, which relies
%on the user not forgetting their password.
The user can optionally choose to store this encrypted data themselves
%(or in a third party cloud provider),
and be in charge of providing their data and key to \sys to decrypt the data upon
resubscription.

To resubscribe, a user authorizes the decryption of their data and associated metadata by
providing their share of the key (or authorizing a trusted third party to reconstruct the secret
with the application). \sys decrypts the data with the key, and systematically reverses
the modifications made during unsubscription, restoring removed entities and correlations between
entities.
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
\subsection{\sys's Execution Algorithm}
\begin{figure*}[ht!]
    \centering
    \includegraphics[width=\textwidth]{img/algo}

    \caption{Stages of \sys's execution when unsubscribing user U1. Entities and edges detected as
    sensitive are outlined in red. Only the part of the entity graph relevant to unsubscription is shown.
    For simplicity, the specified guises policies apply for all attributes
    of the entity: a black ghost entity indicates that it is a full clone of the original.
    New edges indicates that the edge (foreign-key) value of the child has been changed to
    point to the specified parent.\\
    In this example, \sys decorrelates paper-tag edges only enough that the proportion of sensitive papers
    is at most the sensitivity threshold of 0.5, retaining one correlation between a sensitive
    paper P2 and the parent tag T1, and decorrelating the other sensitive paper P1 from the tag.}
    \label{fig:algo}
\end{figure*}


Given an application's schema and unsubscription policy, and an entity to be decorrelated as input,
\sys executes unsubscription as follows. Figure~\ref{fig:algo} illustrates each step.
\begin{enumerate}
    \item \textbf{Parent-Child Traversal:} \sys traverses the entity graph starting from the input entity,
        going down parent to child edges (and halting if it detects a cycle).
        \sys collects traversed edges as it traverses the graph.

    \item \textbf{Parent-Child Edge Policy Application:}
        Post-traversal, \sys acts on each collected edge instance according to the specified
        decorrelation relationship policy for that edge's type.

        \sys takes all edges of every unique parent entity, and applies policies as appropriate.
        Note that any sensitivity threshold less than $1$ requires that \emph{all} edges be decorrelated or
        deleted, depending on the developer's specified choice: all the children of this parent are
        sensitive due to the nature of \sys's parent-child traversal.

        Any edges that should be deleted removes the child entity and any descendants.
        \sys generates new ghost parents using the real parent as template for any edges that should
        be decorrelated, and rewrites the child's edge attribute to be the ghost parent's
        identifier. If any edges are retained, \sys generates a ghost parent entity to replace the
        parent.

    \item \textbf{Child-Parent Edge Policy Application:}
        Next, \sys takes the children of all traversed edge instances, and considers the set of
        edges from these children to other parents \emph{not} traversed by \sys during the first
        traversal phase. In other words, these children have multiple parents, at least one of which
        is transitively connected to the input entity.

        Intuitively, children of edges traversed by \sys share a connection with the initial
        entity being decorrelated. Edges \emph{from} these children to other parent entities may
        thus leak sensitive identifying information.

        \sys acts on these child-parent edges according to the specified edge policy for each edge's
        type. For each unique parent, \sys limits the proportion of edges of each type that connect
        to sensitive entities (the children of traversed edge instances) to below the policy's
        sensitivity threshold by either decorrelating or deleting the children.
        If \sys retains any edges from sensitive children to the real parent, then \sys generates a
        ghost parent entity to replace the parent.

        Note that unlike the previous steps, this step considers edges from parents that may have
        many non-sensitive children (\eg a particular tag may correlate with many stories by various
        authors).  \sys therefore may retain edges to sensitive children when given a sensitivity
        threshold less than 1 and greater than 0, unlike in the previous step.

        \sys optionally allows developers to specify that edges have weaker or stronger edge
        policies in the child-to-parent direction than in the  parent-to-child direction. Weaker
        policies---higher sensitivity thresholds---allow \sys to retain links if \emph{only the
        child} is sensitive, but decorrelate or remove the link if \emph{both} the child and parent
        are sensitive. For example, perhaps a user wants to ensure that they are decorrelated from
        their reviews, but correlations between the review and the the paper authors can still be
        retained.

        Stronger policies may specify that the parent connected to sensitive children should
        decorrelate \emph{all} correlations to the paper even from non-sensitive correlations.
        Developers specify such a policy with a sensitive threshold of -1. For
        example, perhaps the set of users with review conflicts to the paper can identify the
        author, even if the author is decorrelated from the paper. We see an example of this in
        Section~\ref{sec:hotcrp_example} (Figure~\ref{fig:pcs}).

    \item \textbf{Anonymizing Leaf Children:}
        If any sensitive children that are leaves (have no children) remain, \sys generates a ghost child entity to replace this leaf.

        In Figure~\ref{fig:algo}, step 4, P1 and P2 are both leaves. \sys generates ghosts for both
        these papers: since these papers have \texttt{CloneOne} guises policies, ghost papers gP1
        and gP2 are identical to P1 and P2, and retain the edge attributes linking them to their
        respective parent tags and users.

    \item \textbf{Returning User Data:} \sys collects all removed entities that have either been
        replaced by ghost entities, or deleted entirely from the graph. \sys also records all
        generated ghost entity identifiers, and which ghost entities replaced which real entity.
        \sys returns both the removed entity data and this ghost entity metadata to the user.
\end{enumerate}

Note that \sys must decide \emph{which} ghost clones the template entity's attributes when the
developer selects a \texttt{CloneOne} guises policy for one or more attributes. \sys always
associates the cloned ghost with as many non-sensitive entities as possible. For example, as shown
in Figure~\ref{fig:algo} step 3b, if \sys decorrelates sensitive papers from a parent tag with a
\texttt{CloneOne} policy, \sys chooses the ghost tag that remains associated with non-sensitive
papers to be the clone. This decision ensures that any unsensitive application
data remain as unaffected as possible when disguising another entity.
To optimize
\texttt{CloneOne} policies, \sys can simply retain the original template entity instead of producing
a cloned ghost.
%\sys provides a menu of unsubscription policy choices that allow developers to choose how to
%\emph{ghost} individual data record content, and how to \emph{decorrelate} sensitive correlations.
%Specifying the policy requires nothing more than the application schema: guises policies act on
%application datatables and on foreign key relationships between tables.
%Table column values can be ghosted---removed, anonymized, or modified---in application-specific
%ways; and correlations can be broken, removed, or desensitized by adding noise. This gives
%developers the flexibility to specify fine-grained policies that properly de-identify a user, while
%retaining data as necessary for the application.

%\sys must pinpoint exactly which data and correlations may be
%identity-sensitive, and allow developers to specify exactly what the post-unsubscription state of
%this data should be.

\fi

