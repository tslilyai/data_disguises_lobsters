%-------------------------------------------------------------------------------
\section{Implementation}
%-------------------------------------------------------------------------------

\sys{} introduces in-memory shim layer on top of a MySQL database, 
allowing \sys{} to intercept and process queries sent by the application frontend. 
To amortize the cost of unsubscription and resubscription, \sys{} preemptively creates, stores, and
links ghost parent entities to child entities if an update creates an edge that may be decorrelated.
\sys{} builds in-memory materialized views on top of the underlying database, exposing ghost
entities only if the true entity has been decorrelated, and real entities otherwise. Updates
propagate to the materialized views when the underlying database is updated. \sys{} answers
application queries using these materialized views, hiding the complexity of ghost entity and
decorrelation management.

\sys{} is build in 5K LoC of Rust, and supports a subset of MySQL. \sys{} adds \texttt{UNSUBSCRIBE
[user]} and \texttt{RESUBSCRIBE [user] WITH [user\_data]} calls to the query language.
\lyt{Should I mention details like query parsing, single-threaded?}
Application developers specify and provide an \texttt{ApplicationPolicy} using the objects shown in
Figure~\ref{fig:policytype} \lyt{Why is this showing the wrong figure number??}.

\begin{figure}
\begin{lstlisting}[language=Rust]
 pub enum GeneratePolicy {
     Random,
     Default,
     Custom(FnMut(ColumnValue) -> ColumnValue),
     ForeignKey, 
 }
 pub enum GhostColumnPolicy {
     CloneAll,
     CloneOne(gp: GeneratePolicy),
     Generate(gp: GeneratePolicy),
 }
 pub type GhostPolicy;
    HashMap<Column, GhostColumnPolicy>;
 pub type EntityGhostPolicies = 
    HashMap<EntityName, GhostPolicy>;

pub enum DecorrelationPolicy {
     NoDecorRemove,
     NoDecorRetain,
     NoDecorSensitivity(f64),
     Decor,
 }
 pub struct KeyRelationship {
     child: EntityName,
     parent: EntityName,
     column_name: String,
     parent_child_decor_policy: DecorrelationPolicy,
     child_parent_decor_policy: DecorrelationPolicy,
 }
 pub struct ApplicationPolicy {
     entity_type_to_decorrelate: EntityName,
     ghost_policies: EntityGhostPolicies,
     edge_policies: Vec<KeyRelationship>,
 }
\end{lstlisting}
    \label{fig:policytype}
    \caption{\sys{}-provided types to specify key relationships and ghost generation policies.}
\end{figure}

\subsection{Data Objects}
In addition to the original application data tables, \sys{} stores a persistent mapping from entity
ID (EID) to a set of ghost IDs (GID). This mapping is cached in the shim layer for performance. Only
ghost entities that correspond to a true parent entity are stored in the mapping: auxiliary ghosts that are
created to introduce noise (reduce sensitivity), or to satisfy referential integrity---all their
children are also ghosts---are not linked to the real parent EID.

\sys{} stores the in-memory materialized views for each datatable, using hashtables and btrees for
table indexes. An in-memory cache of the graph of parent-child entity key relationships built on
top of the views is also stored for unsubscription and resubscription performance.

\subsection{Handling Normal Execution Queries}
\paragraph{Reads.}
Reads are answered by the materialized views. Because the materialized views are kept up-to-date with any application
writes, no queries to the underlying datatables are performed.
\lyt{I'm not sure if it's appropriate or interesting to put some of the MV query handling stuff
here? (Like processing joins, etc.)}

\paragraph{Inserts.}
When the application inserts an entity, \sys{} first checks (using the developer-provided policy) whether
the entity is a child entity (i.e., it has a foreign key to another data table). 
and whether the policy specifies that this child-parent key
relationship should be decorrelated during unsubscription. 

If so, \sys{} preemptively creates a \emph{ghost parent} entity using the appropriate entity
generation policy, and adds this ghost to the parent data table. \sys{} then saves the child
entity's real parent EID (the child entity's foreign key column value), and adds a mapping from this
EID to the new ghost parent GID.\footnote{\sys{} assumes that the application does not violate
referential integrity, namely that any child entity inserted into the system will refer to a
corresponding parent in the database.} Finally, \sys{} rewrites the child entity's foreign key
reference to correspond to this new ghost parent's GID, and stores the child into the datatable.

Note that generating the ghost parent may recursively generate a set of ghost ancestors for that
parent as well (to satisfy referential integrity). These ancestors are also added to the parent data
table.

The insert then propagates to the materialized view, inserting the entity with its real parent EID; queries that
select for this entity will not see any ghost entities. 

If the child-parent key relationship should not be decorrelated, or the inserted entity is not a
child, \sys{} simply inserts the entity as-is into the datatable, and the materialized view is
updated with the entity.

\sys{} also updates the parent-child entity graph with the new entity if the entity adds any edges
specified by the developer-provided policy. This graph is built on top of the materialized view, and
thus contains only those entities exposed by the materialized view to the application.

\paragraph{Updates.}
When the application updates an entity, \sys{} again checks (using the developer-provided policy) whether
the entity is a child entity (i.e., it has a foreign key to another data table). 
If the entity is a child, and the policy specifies that this child-parent key
relationship should be decorrelated during unsubscription, then \sys{} performs one final check of
whether the entity's parent key is one of the columns being updated.

If yes, then \sys{} gets the current value of the entity parent key in the datatable: because \sys{}
inserts only GIDs into the datatable for these decorrelatable child-parent links, this value 
corresponds to some ghost parent GID.
\sys{} checks its ghosts mapping table for which real parent EID currently maps to this GID, removes
this current mapping, and updates the mapping so that the updated parent key value now points to
this GID.
\sys{} updates all non-foreign key columns as normal, with values specified by the application.

If the updated entity is not a child of a decorrelatable edge, the update is performed without any
alterations.

Updates are propagated to the materialized view without modifying the values, so that application
reads only observe real parent entities.
\sys{} also updates the parent-child entity graph if any edges between materialized view entities change.

\paragraph{Deletes.}
When the application deletes an entity, \sys{} checks whether
the entity is a child entity (i.e., it has a foreign key to another data table). 
If the entity is a child, and the policy specifies that this child-parent key
relationship should be decorrelated during unsubscription, then \sys{} gets the current value of the
entity parent key in the datatable, which must correspond to some ghost parent GID.
\sys{} checks its ghosts mapping table for which real parent EID currently maps to this GID and removes
this mapping. \sys{} also removes the ghost parent with this GID.

In all cases, \sys{} removes the entity being deleted.
The deletion is propagated to the materialized view and removes the entity being deleted; the
parent-child entity graph is modified appropriately.

\subsection{Handling Unsubscription}
\paragraph{Traversal.}
\sys{} is given the top-level entity type and EID to be decorrelated (typically a user and a user ID).
\sys{} then performs a (depth-first) traversal of the parent-child entity graph built on top of the materialized
views. 

\sys{} stores all the children entities traversed during decorrelation for post-processing, and
handles parent-child edges as follows:

If a parent-child edge has a no-decorrelation-retain policy, \sys{} does nothing; if a parent child-edge has a
no-decorrelation-remove policy, \sys{} removes the child entity and recursively removes all of its
descendants. 

For every parent-child edge with a decorrelate policy, \sys{} looks up the parent EID in the
EID to GIDs mapping, saves the corresponding GIDs, and removes the mapping (both persistent and
cached).
\sys{} then updates the child entity in the materialized view to point to a ghost entity instead
than the real parent (who is being decorrelated) by choosing one of the corresponding GIDs for this
parent and updating the child's parent key with this GID.  The parent-child entity graph is updated
accordingly to include the ghost parent (note that this does not affect the traversal, which only
traverses parent-child edges).

If a parent-child edge has a no-decorrelation-sensitivity policy, \sys{} stores the edge for
post-processing.

\paragraph{Sensitive Parent-Child Edges.}
Post-traversal, \sys{} considers its collected set of sensitive edges. For every unique parent,
\sys{} counts how many children attach to the parent for each distinct edge type (e.g,\ for a
particular tag, how many stories are linked to this tag, how many comments are linked to this tag,
etc.). For each child count $n$, and with an edge type sensitivity threshold of $\sigma$, 
\sys{} generates $n / \sigma$ ghost entities of that child type, all of which have an edge to the parent.
These ghost entities are inserted both into the materialized views, and into the underlying
datatables; however, because they do not correspond to real entities, EID to GID mappings are not
stored. 
If \sys{} finds no ghost generation policy for the child entity type, \sys{} instead recursively
removes the child and its descendants.

\paragraph{Handling Child-Parent Edges.}
Next, \sys{} considers child-parent edges from the collected set of traversed children to parents
not seen during \sys{}'s traversal. If an 
edge can be decorrelated, \sys{} rewrites the materialized child parent key to one of the parent
ghost GIDs. The ghost GID is retrieved by querying the parent's EID to GIDs mapping, the
corresponding ghost parent is added to the materialized view,
and the mapping from parent EID to GID is subsequently removed. These steps ensure that the
materialized view reflects that the link between the child and the original parent has been
decorrelated.

If an edge has a remove policy, the child and its descendants are removed; if an edge has a retain
policy, nothing is done. 
If an edge $e$ has a senstivity threshold,
\sys{} counts $N_{all}$, the total number of edges of the same edge type as $e$ that connect to $e$'s parent.
\sys{} then counts $N_{sensitive}$, the number of these edges that connect to children that were traversed by \sys{} during the
first decorrelation step (this number includes $e$).
If $e$'s edge type has sensitivity threshold of $\sigma$ and $N_{sensitive} / N_{all} > \sigma$,
\sys{} generates $\lceil N_{sensitive}*\sigma\rceil - N_{all}$ ghost entities of $e$'s child type, all
of which have an edge to $e$'s parent.
As before, these ghost entities are inserted both into the materialized views, and into the underlying
datatables; however, because they do not correspond to real entities, EID to GID mappings are not
stored. 
If \sys{} finds no ghost generation policy for the child entity type, \sys{} instead recursively
removes the child and its descendants.

\paragraph{Decorrelated Entity Removal and Return Values.}
Finally, \sys{} removes any completely decorrelated entities, namely those children that have no
descendants and are linked to only ghost (or no) parents.
\sys{} returns to the unsubscribing user (1) the removed parent EID to GIDs mappings, (2) any completely decorrelated (and removed) entities,
and (3) the GIDs of any additional generated ghosts during sensitivity checks.
To ensure that the end user cannot tamper with their application data while unsubscribed, \sys{}
saves the hash of the top-level entity EID and the returned data to check upon resubscription.
\lyt{This is currently in-memory; should I persist it? (Will add another db query, but unsubscribe
is already pretty expensive)}

\subsection{Handling Resubscription}
\sys{} is given the top-level entity type and EID to be resubscribed, along with the data returned
from a prior unsubscription.
\sys{} verifies that the hash of the EID and data matches that from the latest unsubscription of
this entity.

\sys{} first re-inserts any completely
decorrelated entities into both the datatables and materialized views. 

Next, for all removed parent EID to GIDs mappings, \sys{} reinserts these mappings into the
persistent and cached EID to GIDs mapping.
\sys{} then removes the corresponding ghost entities for all GIDs and any ghost ancestors of these
GIDS from the materialized views; note that these ghosts still remain present in the
persistent data tables for future unsubscription.
\sys{} then updates all materialized children of these removed ghosts with the original parent EID. Looking up the relevant
children is facilitated by the in-memory entity graph. 

Finally, \sys{} removes any
ghost entities from the datatables and materialized views that were created during unsubscription to
lower sensitivity.

\paragraph{Consistency and Recovering the Materialized Views}
\lyt{This isn't actually implemented yet...}
Upon a crash, the in-memory materialized views are rebuilt from the underlying datatables and ghost
mapping. Non-children datatable entities are simply reinserted into the appropriate
materialized view. 

If a datatable contains child entities, and these children have ghost parent GIDs as foreign
keys (because their child-parent edges can be decorrelated), then \sys{} checks, for each child, whether a mapping
from a real parent EID to this entity's foreign key GID exists in the persistent EID to GIDs
mapping. If such a mapping exists, then this edge has not yet been decorrelated, and the real parent
entity should be exposed to the application: \sys{} inserts the child entity with the real parent
EID into the materialized view.

If the mapping does not exist, then the link to the real parent entity must have been decorrelated at some point:
\sys{} inserts the unmodified child entity with the GID as foreign key into the materialized view.
Note that this may link a child entity with a \emph{different} ghost user than initially decided
during unsubscription (where any one of the ghosts corresponding to the real parent could be used as
a ghost parent for any child). 
\lyt{I think this can also be avoided by updating the MV entities with GIDs in monotonically
increasing order, since this is how they would have been inserted into the underlying database. It
also doesn't seem that important.}

The parent-child graph is constructed appropriately on top of the materialized view, and the EID to
GIDs mapping cache repopulated.

\sys{} does not currently support atomic unsubscription, resubscription, or recovery behavior.
\lyt{TODO}
