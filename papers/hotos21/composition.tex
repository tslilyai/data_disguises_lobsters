\section{Reasoning about Multiple Disguises}

Applications benefit from the ability to apply multiple disguises. For example,
\S\ref{sec:motivation} highlights two desirable disguises in HotCRP, namely \gdpr and \ca. \gdpr
provides user privacy by removing the user's data; \ca provides user privacy by anonymization.
As we observed, however, applying \ca destroys information allowing \gdpr to properly remove the
user's data.

Applications define an acceptable outcome after composing multiple disguises when they define their
privacy policy.
For example, HotCRP may require that \gdpr removes the invoking user's reviews completely, even when
applied after other disguises such as \ca.  Alternatively, HotCRP may accept a post-\gdpr outcome that either
anonymizes or removes reviews. 
The choice of policy affects how the disguising tool integrates with the application.

For example, assume HotCRP requires that a user's \gdpr disguise must \emph{remove} the invoking
user's reviews. If the disguising tool stores per-user reveal functions in user vaults when
executing \ca, then the disguising tool can query the user's vault to temporarily recorrelate the
user's reviews with their identity before applying \gdpr for the user.  This allows the tool to
remove the user's reviews.
%This requires the user to grant access to their vault.
%If one disguise removes an object that the other disguise
%modified, then the removal takes precedence.
%
%However, if they both modify the same object attribute, a disguising tool establishes no precedence
%between the modifications and applies them in chronological order.  Alternatively, we can imagine
%that the developer could specify a partial ordering between modifications, or our framework could
%restrict the set of possible modifications and establish a precedence order within this set.

However, if the disguising tool \emph{discards} the reveal functions produced when executing \ca
because \ca is irreversible, then the tool cannot perform \gdpr while guaranteeing that \gdpr
removes all the user's originally owned reviews.  The right solution here is unclear: one
possibility is for the tool to a-priori determine (via, \eg static dependency analysis) the set of
irreversible disguises such as \ca that could prevent \gdpr from removing the user's reviews. This
analysis could be presented to the developer, providing a warning that the privacy policy may be
violated if \gdpr is applied after \ca.

If HotCRP's policy instead accepts that a user's \gdpr disguise can either remove \emph{or} anonymize the
invoking user's reviews, then the disguising tool can simply execute \gdpr on top of \ca and achieve
an acceptable state: any reviews missed by \gdpr would necessarily have been anonymized by \ca.
Thus, the tool can achieve HotCRP's privacy policy regardless of whether \ca discards or stores
reveal functions in user vaults.

\subsection{Reasoning about Complete Disguise Reversals}
Reasoning about multiple disguises is further complicated when disguises are intermixed with
disguise reversals.
%
For example, imagine that \ca and \gdpr both store reveal functions in user vaults. 
%
\ca followed by a user's \gdpr followed by the reversal of \ca should ensure that the deleted user's
reviews are still anonymized or removed (depending on HotCRP's specific policy for \gdpr).
Similarly, the user's \gdpr followed by \ca followed by the reversal of the user's \gdpr should also
ensure that the deleted user's reviews are anonymized.
To handle these scenarios, the disguising tool could keep a persistent log of all disguises performed by the
application; any disguises performed between a disguise's application and its reversal are 
applied to any reintroduced data. In the former scenario, \gdpr's removal would apply to any
recorrelated reviews; in the latter scenario, \ca's decorrelation would apply to any of the user's reintroduced reviews.

\lyt{This doesn't fit in well, but we should discuss it.}
Furthermore, vault deployment models greatly affect the practicality of complete disguise reversal. \gdpr
necessarily must store user vaults external to the application in order to be GDPR-compliant;
however, complete reversal of \ca requires retrieving reveal functions from every user's vault,
which is infeasible in a setting in which vaults live in external storage, encrypted with per-user keys.
