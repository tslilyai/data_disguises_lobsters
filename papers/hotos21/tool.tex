\section{Our Current Data Disguising Framework}

We propose \emph{data disguising}, a systematic approach to privacy
transformations that separates them from application code.
%
Data disguising reasons about \emph{disguises}, privacy transformations that
follow an organized structure.
%
Disguises are based on the observation that application data can take
different forms, which we call \emph{guises}; some guises are identity-revealing while others are
privacy-preserving (to varying degrees).
%
%For example, a web application's database contents may assocate posts with
%an actual user as their author (an identity-revealing guise), or with
%one or more anonymous placeholder users (privacy-preserving guises).
%
A disguise transforms the database contents between these different forms.
%
%The structured nature of disguises allows a data disguising tool to
%automatically determine how to correctly compose multiple disguises, and to
%check that the end-state achieves the desired privacy properties.
%
%The tool uses the abstraction of \emph{per-user vaults}, which allow the tool to
%reintroduce destroyed data from prior disguises as necessary, while still ensuring that user data
%remains protected (\S\ref{sec:composition}).

%
An external data disguising tool interprets and applies these disguises
based on the application's policy (a \emph{disguise specification}).
%
Application developers only need to invoke the tool's API with a disguise specification to trigger
the disguise; the tool then performs the necessary physical changes to the application's
database.
%
These changes may include data removal, modification of contents, or decorrelation by modifying
references between objects.
%

%
In the following, we sketch one design for a data disguising framework.
%
Some of the specific design decisions in this framework have alternatives that are worth
investigating, and open research questions remain; we discuss these in \S\ref{s:disc}.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.47\textwidth]{img/disguises_new}

    \caption{Disguises move data (in this example, user Bob) 
             between different \emph{guises}. Guises represent the
             same data, but with different privacy properties (\eg
             anonymization).}
    \label{fig:example}
\end{figure}

%
%The key idea behind data disguising is to associate multiple \emph{guises} with a target data
%object (\ie a row in a relational database).
%
%Guises vary in how they reveal identities or preserve privacy.
%
%Objects move between different guises by means of disguises, namely organized privacy transformations.
%
Figure~\ref{fig:example} illustrates the key ideas behind data disguising with the example of a user
account deletion disguise.
%
When his account is active, user Bob's profile is associated with his true identity and all his
contributions to the site (an identity-revealing guise).
%
When Bob deletes his account, his profile and contributions move to different, privacy-preserving
guises: his name has been anonymized, his email address has been redacted, and his contributions
have been decorrelated and attributed to individual, unidentified user guises.
%
Decorrelation makes it seem as if a different user provided each of Bob's contributions.
%
This allows these contributions to be retained, but prevents an observer from correlating these
contributions back to Bob's identity.
%
Importantly, this also preserves refential integrity in the database, an importnat precondition
to application correctness.
%

%
Disguises transform a guise by modifying it at per-attribute (\ie per-column) granularity, or
splitting it into multiple guises in order to decorrelating from objects that reference it (via \eg foreign-key relationships).
%
Guises can also be removed entirely.
%
At any given moment, an application's data comprises a mix of identity-revealing guises
and privacy-preserving ones. Disguises modify, split, and/or combine individual guises when triggered.

\ms{OLD TEXT FOLLOWS}

\subsection{Writing Disguises}
\label{sec:disguises}

\begin{figure}[t!]
    \centering
    \footnotesize
\begin{lstlisting}[language=Rust]
disguise_name: "UserScrub",
user_to_disguise: UID,
tables {
  "ContactInfo": {
    generate_guise_info: [
      ("name", Random),
      ("email", Default(None)),
      ..
    ],
    transformations: [Remove(pred: "id" = UID)],
  },
  "Review" : {
    guise_info: [], 
    transformations: [
      Decorrelate(
        pred: "contactId" = UID,
        fk_column: "id",
        fk_table: "User"
      )
    ],
  }
  "ReviewPreference" : {
    guise_info: [], 
    transformations: [Remove(pred: "contactId" = UID)],
  }
}
\end{lstlisting}
    \caption{Partial of the specification for a user scrubbing disguise in HotCRP}
    \label{fig:spec}
\end{figure}


The application developer writes a disguise specification for each privacy transformation needed
in the application.
%
When writing a disguise, developers can reason about its
specification in isolation; interactions between different disguises are handled by a disguising
tool (\S\ref{sec:composition}).
%
%We assume that:
%\begin{enumerate}[nosep]
%  \item developers use their domain knowledge to write correct and complete disguises;
%      \lyt{should make clear that correct/complete is just operational? \eg doesn't mess up the DB}
%  \item application code handles the different guises appropriately (\eg in
%    displaying them); and
%  \item different guises of the same object have the same structure (\eg they can be
%    rows in the same table).
%\end{enumerate}
%
Our data disguising tool takes a disguise specification and turns it into storage operations that
achieve the desired application data state.

Developers specify predicated transformations, which describes how to update all objects satisfying
the predicate. For example, Figure~\ref{fig:example} would include a specification that all email
addresses be obfuscated in an anonymous manner for the user with name ``Bob Parr''.
%
Transformations can either remove objects, or change objects into one or more guises.
To create a guise from an object, developers specify how to transform attributes of the
object (\eg table column values) into guise attributes (\eg changing email addresses).

\iffalse
Developers choose how to create other guise attributes, selecting from among the following:
%
\paragraph{(1) Copy object content.}
%
Guises of the same object all share the object's attribute values.
%
If the attribute is a reference attribute (\eg a foreign key column), all guises will refer to the same object.
%
%
Copying allows developers to retain the object's content, without worrying about how to
synthesize attribute values for guises.
%
%However, this should only be chosen if guise attribute
%values cannot be generated, or if this attribute says little about the true identity of the
%entity.
For example, in Figure~\ref{fig:guises} the \texttt{darkmode} attribute is copied in
all guises.
%; the \texttt{darkmode} attribute reveals very little about the underlying user's
%identity.

\paragraph{(2) Generate new content.}
%
To create new attributes, developers specify whether the guise's value should be random,
a default value, or generated from the object's attribute value via a custom function (\eg hashing
the value).
%
Figure~\ref{fig:guises} illustrates an example of random (\texttt{name}) and default
(\texttt{active}) generated value attributes.
%
%
Creating new guise reference attributes (\eg new foreign key relationships) requires
creating a new guise for the referenced object in order to maintain referential
integrity;
the data disguise rewrites the reference to point to the new guise.
%
In Figure~\ref{fig:guises}, creating two user guises requires creating two
tag guises, and the tag guises' identifiers become the user guises' foreign keys.
%

\paragraph{(3) Copy object content, but only once.}
%
One guise copies the attribute value from the object, but all other guises generate new
values (as described above).
%
\texttt{notifs} in Figure~\ref{fig:guises} illustrates how the attribute is copied once.
%
This enables the application to retain the original object semantics (\eg a count of how many
users want notifications) without creating duplicates.
%



\begin{figure*}[t!]
    \centering
    \footnotesize
\begin{tabular}{@{}c|c|c|c@{}}
\textbf{User Transformation Spec} & \textbf{User Object} & \textbf{Guise 1} &
    \textbf{Guise 2} \\
\begin{lstlisting}[language=Rust]
"id":       IDAttribute,
"name":     Gen(Random),
"active":   Gen(Default(false)),
"darkmode": CopyAll,
"notifs":   CopyOnce+Gen(Default(false)),
"tag_id":   GenForeignKey,
\end{lstlisting}
    &
\begin{lstlisting}[language=Rust]
"id":       19,
"name":     BobParr,
"active":   true,
"darkmode": false,
"notifs":   true,
"tag_id":   11
\end{lstlisting}
&
\begin{lstlisting}[language=Rust]
"id":       295,
"name":     MrIncredible,
"active":   false,
"darkmode": false,
"notifs":   true,
"tag_id":   81483
\end{lstlisting}
&
\begin{lstlisting}[language=Rust]
"id":       918,
"name":     SuperDad,
"active":   false,
"darkmode": false,
"notifs":   false,
"tag_id":   15592
\end{lstlisting}
\end{tabular}
    \caption{Creating two guises of an example user (of a synthetic application schema).}
    \label{fig:guises}
\end{figure*}

\fi
%-------------------------------------------------------------------------------
\subsection{Disguise Composition}
%\label{sec:composition}
%-------------------------------------------------------------------------------

The data disguising tool handles the complexity behind disguise composition, applying disguises in
sequence and generating the necessary storage operations.
%
%When applying a disguise, the disguising tool must both not only apply the specified ptivacy
%transformations, but also manage codependencies between the new disguise and any prior disguises.
%
Because disguises inherently destroy data, applying one disguise may change the outcome of future
disguises applied on top of it.
%
%However, applications would benefit from the ability to apply multiple disguises.
%
For example, consider two desirable disguises in HotCRP: \gdpr and \ca.
%
\gdpr removing the user's data to comply with the GDPR's ``right to be forgotten''; \ca provides
user privacy by anonymizing all conference data.
%
These disguises touch the same data: applying \ca destroys information that \gdpr would remove
or transform if applied to an unmodified database.
%

%
In some cases, the disguises compose naturally---\eg information that an earlier disguise removed
needs no decorrelation---but in others, the tool may need to restore the original data to meet the
application's privacy goals.
%

%To handle inter-disguise dependencies, a disguising tool relies on (1) the structured nature of disguises to
%statically determine whether disguises share dependencies, and (2) the key abstraction of \emph{user
%vaults}, namely per-user logs of disguise updates to that user's data.  User vaults solve the issue
%that disguises inherently destroy data necessary to correctly achieve the end-state of future
%disguises by providing a secure way to store the data. A disguising tool queries the user vault to
%temporarily restore destroyed data (\eg decorrelated foreign key relationships) in order to apply
%the disguise correctly.

%As shown in Figure~\ref{fig:tool}, a disguising tool sits next to the application, and queries the
%user vaults and the application database. The application performs disguises by invoking a
%disguising tool.

%-------------------------------------------------------------------------------
\paragraph{Per-User Vaults}
%-------------------------------------------------------------------------------

Per-user vaults provide the necessary infrastructure to reveal previously-disguised data when
necessary.
%
These vaults store revealing functions for disguises, which when applied, reveal the underlying
data transformed by an already-applied disguise (possibly temporarily).
%

%
User vaults can be flexibly configured and deployed. It remains important, however, that any
configuration of user vaults should not violate the guarantee that disguises indeed destroy data,
from the viewpoint of the application and any users.
We imagine several exciting directions to explore for designing vaults that are both
performant and secure.
%

%
Some possible configurations include a disguising tool storing vaults encrypted with a per-user key; this key
may be secret-shared using a (2, 3) threshold scheme~\cite{secretsharing} between the user, the
tool, and a trusted third party (\eg Amazon S3), so that the user can authorize a disguising tool and the
third party to restore the key if the user forgets their share.
%
The vault entries could be configured to expire after a certain time; the corresponding disguises
then become irreversible.
%
Or perhaps the vault entries are stored entirely by some third party or locally by the user, whose
server runs a corresponding interface to allow disguise tools to read and write the vault.

\lyt{Added text:}
The choice of vault deployment has serious consequences for the practicality of disguise reversal.
For example, if \gdpr is to be reversable, reveal functions must necessarily be stored in user vaults external
to the application in order to be GDPR-compliant.
While it is reasonable to imagine accessing a single user's vault to reverse \gdpr in this
deployment, complete reversal of \ca would need to retrieve reveal functions from every user's vault, an infeasible task.
%A disguising tool should, with user permission, be able to read and write the vaults: a user invoking GDPR
%\texttt{GDPR} could provide the key to their vault, and the application invoking the
%\texttt{ConfAnon} might notify each user for approval (and temporary vault access) prior to disguise
%application.
An alternative might be a multi-tier security design: the first tier stores reveal functions of
non-GDPR disguises locally and acccessible to the disguising tool and application, while the second
tier stores reveal functions from user-invoked disguises in external, per-user encrypted storage.
%\lyt{Might want to say more about how often user vaults are
%queried---what if one disguise needs access to many user vaults, but is being done on behalf of a
%single user?}

%-------------------------------------------------------------------------------
\paragraph{Applying Disguises.}
%-------------------------------------------------------------------------------
A disguising tool applies disguises in a five-phase procedure:
\begin{enumerate}[nosep]
    \item \emph{Prepare}: execute the appropriate reveal functions of co-dependent,
        reversible disguises from the user vaults, if applicable (\S\ref{sec:composition})
        %reconcile any data dependencies between this disguise and prior disguises.
        %A disguising tool detects read-after-write dependencies between the new disguise's
        %predicates and prior disguises' updates, and, using entries in the vault, undoes any writes
        %that may affect the new disguise's predicates. As an optimization, vault entries recording
        %object removals need not be reversed.
        \item \emph{Read}: get all objects that satisfy (per-type) developer-specified predicates.
        \item \emph{Update}: modify, decorrelate, or remove objects read in step (2) according to the
        developer's specification.
    \item \emph{Record}: if the disguise is reversible, store per-user reveal functions for the
        disguise in the appropriate per-user vaults.
        A disguising tool must be able to determine which user vault should record each modification. This can be
        developer-specified, or rely on a set of heuristics (\eg assigning ownership by traversing,
        starting from each user, the application's object graph expressed in an object-relational
        model (ORM)~\cite{orm}, or implicitly via foreign keys).
        \item \emph{Finalize}: After applying the new disguise updates, the disguising tool
            redisguises any temporarily revealed data from earlier disguises.
\end{enumerate}

%Composed disguises should achieve an end-state that combines, in some way, the end-states achieved by each disguise when applied to the original application database in isolation.
%Correct composition of multiple disguises achieves an end-state equivalent to combining the
%end-states achieved by each disguise when applied to the original application database in isolation.
%
%If a prior disguise is reversible, then a disguising tool can use user vaults to ensure that this
%prior disguise does not affect \emph{which} objects are updated
%a future disguises.
%%In this case, a disguising tool allows developers to reason about multiple conflicting updates to
%the same object:
%regardless of when the disguises occurred, if one disguise removes an object that the other disguise
%modified, then the removal takes precedence.
%%
%
%However, if they both modify the same object attribute, a disguising tool establishes no precedence
%between the modifications and applies them in chronological order.  Alternatively, we can imagine
%that the developer could specify a partial ordering between modifications, or our framework could
%restrict the set of possible modifications and establish a precedence order within this set.
%
%If the prior disguise is not reversible, however, then the disguising tool could prevent future
%conflicting disguise application, or perhaps a-priori prevent the application of such non-reversible
%disguises that conflict with legally required disguises such as GDPR deletion \lyt{not sure what to
%put here? May also want to include something about developer assertions}
%%: a disguise will update all objects that it would have updated if performed on
%the original, undisguised state of application data.
