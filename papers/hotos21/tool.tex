%-------------------------------------------------------------------------------
\subsection{A Data Disguising Tool}
\label{sec:tool}
%-------------------------------------------------------------------------------

A data disguising tool handles the complexity behind disguise composition, applying disguises in
sequence and generating the necessary storage operations to achieve an acceptable end state.  When
applying a disguise, a disguising tool must both not only apply the specified disguise
transformations, but also manage codependencies between the new disguise and any prior disguises. 

\lyt{New text added!}
Because disguises inherently destroy data, applying one disguise limits the transfomational
capabilities of future disguises. However, applications would benefit from the ability to apply
multiple disguises. For example, \S\ref{sec:motivation} highlights two desirable disguises in
HotCRP, namely \gdpr and \ca. \gdpr provides user privacy by removing the user's data; \ca provides
user privacy by anonymization.  As we observed, these disguises share dependencies: applying \ca
destroys information needed to remove the user's data when applying \gdpr.

The tool can overcome some of these limitations if applications optionally allow disguise reversibility,
which the tool supports using per-user vaults. These vaults store per-user revealing functions for
reversible disguises, and enable the tool to support a larger set of privacy policies
(\S\ref{sec:composition}).

%To handle inter-disguise dependencies, a disguising tool relies on (1) the structured nature of disguises to
%statically determine whether disguises share dependencies, and (2) the key abstraction of \emph{user
%vaults}, namely per-user logs of disguise updates to that user's data.  User vaults solve the issue
%that disguises inherently destroy data necessary to correctly achieve the end-state of future
%disguises by providing a secure way to store the data. A disguising tool queries the user vault to
%temporarily restore destroyed data (\eg decorrelated foreign key relationships) in order to apply
%the disguise correctly.

%As shown in Figure~\ref{fig:tool}, a disguising tool sits next to the application, and queries the
%user vaults and the application database. The application performs disguises by invoking a
%disguising tool.

%-------------------------------------------------------------------------------
\paragraph{Deploying User Vaults.}
%-------------------------------------------------------------------------------
User vaults can be flexibly configured and deployed. It remains important, however, that any
configuration of user vaults should not violate the guarantee that disguises indeed destroy data,
from the viewpoint of the application and any users.
We imagine several exciting directions to explore for designing vaults that are both
performant and secure.
%

%
Some possible configurations include a disguising tool storing vaults encrypted with a per-user key; this key
may be secret-shared using a (2, 3) threshold scheme~\cite{secretsharing} between the user, the
tool, and a trusted third party (\eg Amazon S3), so that the user can authorize a disguising tool and the
third party to restore the key if the user forgets their share.
%
The vault entries could be configured to expire after a certain time; the corresponding disguises
then become irreversible.
%
Or perhaps the vault entries are stored entirely by some third party or locally by the user, whose
server runs a corresponding interface to allow disguise tools to read and write the vault.

\lyt{Added text:}
The choice of vault deployment has serious consequences for the practicality of disguise reversal.
For example, if \gdpr is to be reversable, reveal functions must necessarily be stored in user vaults external
to the application in order to be GDPR-compliant.
While it is reasonable to imagine accessing a single user's vault to reverse \gdpr in this
deployment, complete reversal of \ca would need to retrieve reveal functions from every user's vault, an infeasible task.
%A disguising tool should, with user permission, be able to read and write the vaults: a user invoking GDPR
%\texttt{GDPR} could provide the key to their vault, and the application invoking the
%\texttt{ConfAnon} might notify each user for approval (and temporary vault access) prior to disguise
%application. 
An alternative might be a multi-tier security design: the first tier stores reveal functions of
non-GDPR disguises locally and acccessible to the disguising tool and application, while the second
tier stores reveal functions from user-invoked disguises in external, per-user encrypted storage.
%\lyt{Might want to say more about how often user vaults are
%queried---what if one disguise needs access to many user vaults, but is being done on behalf of a
%single user?}

%-------------------------------------------------------------------------------
\paragraph{Applying Disguises.}
%-------------------------------------------------------------------------------
A disguising tool applies disguises in a five-phase procedure:
\begin{enumerate}[nosep]
    \item \emph{Prepare}: execute the appropriate reveal functions of co-dependent,
        reversible disguises from the user vaults, if applicable (\S\ref{sec:composition})
        %reconcile any data dependencies between this disguise and prior disguises.
        %A disguising tool detects read-after-write dependencies between the new disguise's
        %predicates and prior disguises' updates, and, using entries in the vault, undoes any writes
        %that may affect the new disguise's predicates. As an optimization, vault entries recording
        %object removals need not be reversed.
        \item \emph{Read}: get all objects that satisfy (per-type) developer-specified predicates.
        \item \emph{Update}: modify, decorrelate, or remove objects read in step (2) according to the
        developer's specification.
    \item \emph{Record}: if the disguise is reversible, store per-user reveal functions for the
        disguise in the appropriate per-user vaults. 
        A disguising tool must be able to determine which user vault should record each modification. This can be
        developer-specified, or rely on a set of heuristics (\eg assigning ownership by traversing,
        starting from each user, the application's object graph expressed in an object-relational
        model (ORM)~\cite{orm}, or implicitly via foreign keys).
        \item \emph{Finalize}: After applying the new disguise updates, the disguising tool
            redisguises any temporarily revealed data from earlier disguises.
\end{enumerate}

%Composed disguises should achieve an end-state that combines, in some way, the end-states achieved by each disguise when applied to the original application database in isolation.
%Correct composition of multiple disguises achieves an end-state equivalent to combining the
%end-states achieved by each disguise when applied to the original application database in isolation.
%
%If a prior disguise is reversible, then a disguising tool can use user vaults to ensure that this
%prior disguise does not affect \emph{which} objects are updated
%a future disguises. 
%%In this case, a disguising tool allows developers to reason about multiple conflicting updates to
%the same object: 
%regardless of when the disguises occurred, if one disguise removes an object that the other disguise
%modified, then the removal takes precedence.
%%
%
%However, if they both modify the same object attribute, a disguising tool establishes no precedence
%between the modifications and applies them in chronological order.  Alternatively, we can imagine
%that the developer could specify a partial ordering between modifications, or our framework could
%restrict the set of possible modifications and establish a precedence order within this set.
%
%If the prior disguise is not reversible, however, then the disguising tool could prevent future
%conflicting disguise application, or perhaps a-priori prevent the application of such non-reversible
%disguises that conflict with legally required disguises such as GDPR deletion \lyt{not sure what to
%put here? May also want to include something about developer assertions}
%%: a disguise will update all objects that it would have updated if performed on
%the original, undisguised state of application data.
