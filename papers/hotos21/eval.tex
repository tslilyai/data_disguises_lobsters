%-------------------------------------------------------------------------------
\section{Case Studies}
%-------------------------------------------------------------------------------
\label{sec:hotcrp_example}

\begin{figure}[t]
    \centering
    %\footnotesize
    \begin{tabular}{@{}cccc@{}}
        \textbf{Application} & \textbf{\#Object} & \textbf{Schema} &
        \textbf{Disguise} \\
        \textbf{Disguise} & \textbf{Types} & \textbf{LoC} & \textbf{LoC} \\
    \midrule
    \lrtbf & 19 & 318 & 100 \\
    \hrtbf & 25 & 352 & 142 \\
    \hrtbfplus & 25 & 352 & 255 \\
    \hconfanon & 25 & 352 & 232 \\
\end{tabular}
    \caption{Data disguise specifications for Lobsters and HotCRP have similar complexity to
    a relational schema.
}
\label{tab:loc}
\end{figure}

%
To evaluate the ease of writing disguises, we implement disguises for GDPR deletion
in Lobsters~\cite{lobsters}, an open-source news feed application, and HotCRP~\cite{hotcrp}.
%
We consider four disguises: \lrtbf and \hrtbf implement the current account
deletion policies in the two applications~\cite{lobsters:privacy, hotcrp:privacy}.
%
\hrtbfplus specifies a HotCRP account deletion policy that balances useful data retention with
data deletion for privacy (\S\ref{design:eg}), and
\hconfanon specifies the conference anonymization disguise for HotCRP.

\paragraph{Complexity.}
%
We would hope that writing disguises involves similar labor and difficulty as writing
relational schemas.
%
In particular, a developer should write a disguise only once, and
%
specify some reasonable number of predicated transformations for each object type.
%disguise complexity is limited by the number of object types in the
%application schema.
%
Figure~\ref{tab:loc} shows that the disguise specification for our applications is indeed
comparable in size to the applications' schemas.
%

\paragraph{Performance.}
\label{sec:perf}

Data disguising faces several performance challenges.
%
%First, disguise application should not unduly impact the performance of application queries
%when run on a live application database.
%
As expected, we observe that the number of queries performed by \sys to fetch and update
the relevant to-be-disguised objects grows linearly with the number of objects.
%
This disguise overhead is unavoidable: these modifications are crucial to applying the
disguise.
%
\sys currently applies these changes in one large SQL transaction; batching, parallelization,
and asynchronous application could improve performance.
%
The importance of reducing the cost of disguise application depends on the rate of
disguising, which may range from rare (as in today's applications) to quite frequent (in a
privacy-supporting world where users freely disguise and reveal themselves, or data expires).
%

%
Disguise interdependencies can further increase the cost of disguising: when applying a
disguise, \sys not only modifies objects, but may also read and apply reveal functions from
vaults.
%
In the worst case, \sys might need to read, reverse, and reapply all previous reversible
disguises in their entirety.
%

We evaluate the estimated cost of vault operations and disguise composition in an experiment
with a HotCRP database with 430 users (30 PC members), 450 papers, and 1400 reviews.
%
We first invoke \sys with two independent disguises: \hrtbf of different users.
%
We then compare the cost of invoking \hrtbf after \hconfanon---a conflicting, but reversible
disguise---has been applied.
%
Applying \hrtbf for a PC member user after an independent \hrtbf application takes 135ms on
average.
%
The same \hrtbf disguise applied after \hconfanon takes
\ms{new results w/o manual optimization},
%118ms
while \hconfanon itself takes about 7,000ms.
%
With the composed disguises, \sys incurs overhead because it temporarily re-correlates objects
using reveal functions, so that these objects are correctly removed.
%
While this selective reintroduction of data from user vaults is not free, it is cheaper than
completely undoing the prior \hconfanon disguise.
%

%
When we apply a (manual) optimization that avoids unnecessarily redoing decorrelation
actions that have already been taken by \hconfanon, the latency for \hrtbf after \hconfanon
drops to 118ms.
%
We imagine that we will be able to use static analysis of the disguise and schema to automate
this optimization in the future.
%
