%-------------------------------------------------------------------------------
\section{Case Studies}
%-------------------------------------------------------------------------------
\label{sec:hotcrp_example}

\begin{figure}[t]
    \centering
    %\footnotesize
    \begin{tabular}{@{}cccc@{}}
        \textbf{Application} & \textbf{\#Object} & \textbf{Schema} &
        \textbf{Disguise} \\
        \textbf{Disguise} & \textbf{Types} & \textbf{LoC} & \textbf{LoC} \\
    \midrule
    \lrtbf & 19 & 318 & 100 \\
    \hrtbf & 25 & 352 & 142 \\
    \hrtbfplus & 25 & 352 & 255 \\
    \hconfanon & 25 & 352 & 232 \\
\end{tabular}
    \caption{Data disguise specifications for Lobsters and HotCRP have similar complexity to
    a relational schema.
}
\label{tab:loc}
\end{figure}

%
To evaluate the ease of writing disguises, we implement disguises for GDPR deletion
in Lobsters~\cite{lobsters}, an open-source news feed application, and HotCRP~\cite{hotcrp}.
%
We consider four disguises: \lrtbf and \hrtbf implement the current account
deletion policies in the two applications~\cite{lobsters:privacy, hotcrp:privacy}.
%
\hrtbfplus specifies a HotCRP account deletion policy that balances useful data retention with
data deletion for privacy (user scrubbing, \S\ref{design:eg}), and
\hconfanon specifies the conference anonymization disguise for HotCRP.

\paragraph{Developer Effort.}
%
We would hope that writing disguises involves similar labor and difficulty as writing
relational schemas.
%
In particular, a developer should write a disguise only once, and
%
specify some reasonable number of predicated transformations for each object type.
%disguise complexity is limited by the number of object types in the
%application schema.
%
Figure~\ref{tab:loc} shows that the disguise specification for our applications is indeed
comparable in size to the applications' schemas.
%

\paragraph{Performance.}
\label{sec:perf}

Data disguising faces several performance challenges.
%
%First, disguise application should not unduly impact the performance of application queries
%when run on a live application database.
%
As expected, we observe that the number of queries performed by \sys to fetch and update
the relevant to-be-disguised objects grows linearly with the number of objects.
%
This disguise overhead is unavoidable: these modifications are crucial to applying the
disguise.
%
\sys currently applies these changes in one large SQL transaction; batching, parallelization,
and asynchronous application could improve performance.
%
The importance of reducing the cost of disguise application depends on the rate of
disguising, which may range from rare (as in today's applications) to quite frequent (in a
privacy-supporting world where users freely disguise and reveal themselves, or data expires).
%

%
Disguise interdependencies can further increase the cost of disguising: when applying a
disguise, \sys not only modifies objects, but may also read and apply reveal functions from
vaults.
%
In the worst case, \sys might need to read, reverse, and reapply all previous reversible
disguises in their entirety.
%

We evaluate the estimated cost of vault operations and disguise composition in an experiment
with a HotCRP database with 430 users (30 PC members), 450 papers, and 1400 reviews.
%
We first invoke \sys with two independent disguises: two \hrtbfplus disguises for different users.
%
We then compare the cost of invoking \hrtbfplus after having applied \hconfanon, a conflicting but reversible
disguise.
%
Applying a PC member's \hrtbfplus after having applied an independent \hrtbfplus takes 135ms on
average.
%
The same \hrtbfplus disguise applied after \hconfanon takes 452ms on average;
\hconfanon itself takes about 7,000ms.
%
The added overhead stems from \sys's temporarily recorrelation of objects
using reveal functions so it can correctly remove them.
%
While this selective reintroduction of data from user vaults is not free, it is cheaper than
completely undoing the prior \hconfanon disguise.
%

%
When we apply a (manual) optimization that avoids unnecessarily redoing decorrelation
actions that have already been taken by \hconfanon, the latency for \hrtbfplus after \hconfanon
drops to 118ms.
%
We imagine that we will be able to use static analysis of the disguise and schema to automate
this optimization in the future.
%
