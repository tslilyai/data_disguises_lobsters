\subsubsection{Modeling perfect decorrelation}
Application data is structured as tables, each representing a different \emph{data entity}, e.g.,\ a
story, user, or vote. Each entity type has a set of attributes, some of which are foreign keys to
other entities, and some of which are primitive column values.
Queries write, read from, and compute over entities.  All entities (e.g.,\
posts) that are correlated with the same attribute form a \emph{cluster}.
In database terms, entities in the same cluster belong to the same table, and the cluster is
identified by a shared foreign key or non-referencing column value.

Decorrelation of a user breaks any clusters identified by the user into singleton clusters, each
identified by a unique ghost user. In essence, the user is exploded into many ghost users, each
correlated with only one of the user's data entities and differing in its column
value attributes.

However, breaking up clusters around the user may not sufficiently decorrelate these entities from
the user. For example, stories belonging to the user may also cluster around a particular tag. Or
perhaps one of the user's stories is upvoted only by all of the users' friends (these upvotes
cluster around the story). These pieces of information allow an adversary to correlate a story back
to a single user, even when clusters around the user no longer exist.

The key observation here is that two types of clusters can still leak identifying information about
the user: (1) clusters identified by data entities owned by the users, and (2) clusters consisting
of the user's data entities, identified by other attributes (identity "proxies"). Decorrelation
recursively breaks up any such clusters into singletons by introducing ghost entities or attributes
(as was done with introducing ghost users), thus removing any identifying information leaked from
correlations between user's data entities and other entities in the application.

More generally, decorrelation continues to recursively break up any clusters that may recorrelate a
data entity back to the identifier of a broken-up cluster. Let $A$ be an attribute type (an entity
or a column value), and $B$ be an entity type. Let $a
\in A$ be the attribute being decorrelated. Given that $a$ identifies at least one cluster $B_a
\subseteq B$, decorrelation on $a$ does the following:
\begin{enumerate}
    \item \textbf{Break direct clusters and
            recurse.} $a$ splits into ghost entities $A_g \subseteq A$, one for each entity $b\in B_a$.
            Decorrelation then runs recursively on each cluster entity $b$.

            Furthermore, if the $A_g$ are in a cluster identified by some attribute $c$, $c$ is
            recursively decorrelated.
    \item \textbf{Break clusters around identity proxies and recurse.} If more than one of the
        $b \in B_a$ is also in a cluster that is identified by an attribute $c \in C$ (an identity
        ``proxy''), then we decorrelate $c$ from its data.

\end{enumerate}
For example, each story (the $b$) posted by a user $a$ belongs in a cluster $B_a$ identified by $a$.
Decorrelation step (1) reassigns each story to a ghost user. Then each story is itself decorrelated.
If stories are decorrelated into a ghost story per vote, for example, then the votes would be
decorrelated. The ghost stories would cluster by the ghost user, so this ghost user would have to
further decorrelate.

Decorrelation step (2) may find that a particular tag $c$ identifies at least two of the users'
stories (these stories belong in a cluster $B_c$ identified by $c$). This tag is a column value
attribute, and not an entity specified by a foreign key. The tag is split into ghost tags, one per
user story, and because the tag itself has no attributes, decorrelation does not continue beyond the
tag.

****************************************************************************************

A common strawman decorrelation technique replaces all unsubscribed users' \uidkey{}s with
one \emph{global placeholder} user, essentially collapsing all unsubscribed users' data into one pool.
This means that all remnants can be identified by one distinct \gidkey{}.
Other UIDs in data records (such as emails, phone numbers) are also replaced by global placeholders
(such as a default email address) that are assigned to this global user.
Using a global placeholder, however, makes resubscription challenging: users can no identify which unsubscribed data records belong to them if all user-specific data has been erased from the
system.

An alternative technique taken by \sys{} generates a unique \emph{ghost user} for each data remnant,
essentially splitting unsubscribed users' data into individual pieces, and replacing one \uidkey{}
with many \gidkey{}s, one per data record owned by the user. Ghost users each have distinct GIDs in
place of UIDs (e.g., a randomly generated email address per ghost).  Unlike a global placeholder,
\sys{} allows users to reactivate their account and undo the decorrelation: \uidkey{}s can be linked
back to a set of unique \gidkey{}s.  This gives users the ability to freely unsubscribe to protect
their privacy without worrying about losing their accounts.  \lyt{Ghosts also make schema changes /
changing the location of data records easier to support.}

We next describe how these two techniques can lead to different decorrelation guarantees.
\paragraph{Measuring Decorrelation.}
We say that the system achieves \textbf{$(Q, \epsilon)$-decorrelation} when the probability that an
attacker can correctly determine that any two distinct remnants belong to any one user is less than
$\epsilon$, given information derivable from performing any $Q$ queries.  \lyt{Note that the
\emph{correctly} is probably essential here: An attacker who will mistakenly correlate two remnants
with some user actually faces more challenges}

Defining this probability requires calculating two others: \begin{enumerate}
    \item[\premnant{}]:
        The probability that the attacker can determine that any data record is a remnant
    \item[\plinked{}]:
        The probability that the attacker can determine that any two remnants belong to the same individual
\end{enumerate}

\paragraph{Calculating \premnant{}.}
The probability that an attacker can determine that a data record is a remnant depends on the
database decorrelation technique and specific application semantics.

At one extreme, an application may expose only aggregate information over data records via its
queries, which prevents an attacker to locate individual data remnants or data records at all.

More realistically, however, the application may allow some queries to access the UIDs either
directly or indirectly. Then if decorrelation utilizes a global placeholder, an attacker can
determine with 100\% certainty which records are remnants: any record with a UID equal to the global
placeholder is clearly a remnant. However, if decorrelation instead relies on ghost users, an
attacker cannot guarantee that any revealed identifier is a ghost instead of a real (subscribed)
user. Instead, the attacker must calculate the probability that an identifier belongs to a ghost
using external knowledge about identifiers (e.g., GIDs may be randomly generated in a identifiable
pattern).

An attacker can also use IIDs and knowledge of the distribution of real user profiles to calculate the
probability that a record is a remnant, which would be necessary in the case in which queries cannot
access UIDs directly or indirectly. Similar to how an attacker could use external knowledge about
identifiers, an attacker could use knowledge about ghost profiles or ghosted records to distinguish
them from real users.  For example, decorrelation may generate ghost profile usernames that are
random numbers or arbitrary animals, while real users may have more human-friendly usernames.

\paragraph{Decreasing \premnant{}.}
Because an attacker may use the distribution of data records in the system to pinpoint outliers and
anomalies that may be remnants, remnants may be less easily spotted if more users unsubscribe and
the system contains more remnants.

Given the possibility for application-specific data to leak information even when identifiers are
hidden and when ghost users are used in place of a global placeholder, the decorrelation should
ensure that information exposed by remnants cannot distinguish remnants from real data records.
Creating remnants from data records should not follow a clear pattern (such as assigning global
values for usernames).  This is highly specific to the application: it may be difficult to
convincingly create user profiles for applications like Facebook and eCommerce sites, but easy in
applications such as Reddit where many users use pseudonyms and have simple usage patterns.

\paragraph{Calculating \plinked{}.}
The probability that two remnants belong to the same individual can be determined by how much
identifying information (from UIDs and IIDs) that attacker queries can reveal.
For example, if an attacker query reveals that multiple
(likely) remnants are comments on classical music, these remnants are more likely to be
correlated with the same individual than two remnants commenting on unrelated topics. If the
attacker additionally queries for the time of post of these comments, and sees that both these posts
were posted during daytime in California, the probability that they belong to the same individual
increases (since the number of people who live in California and like classical music is less than
the number of people who simply like classical music).

\paragraph{Decreasing \plinked{}.}
As with \premnant{}, increasing the number of unsubscribed users and resulting
number of remnants decreases the probability that any two remnants can be linked to any one
user. For example, if there are two records that are likely to be remnants and both are upvotes on topics related to
classical music, the probability that these remnants belong to the same unsubscribed user is high; but if
there are thousands of likely remnants and all are upvotes on topics related to classical music, it
is less likely that an attacker can tell that any two of these remnants belong to any one
unsubscribed user.~\lyt{I'm a bit unconvinced of this argument, but I feel like there is some
intuition here}.

Decreasing \plinked{} requires minimizing the amount of identifying information leaked
through queries. However, there is a fundamental tradeoff between preserving useful information for
the application and obfuscating remnant data.

At one extreme, if decorrelation does not modify UIDs at all (or does so in a predictable manner)
and queries may return UIDs, then an attacker can learn usernames or email addresses that will
identify the user. Similarly, if IIDs are not properly modified, attackers may learn
information such as the location of posts or time of posts, leading to a high probability
that the user can be identified.  Note that this leads to a low \premnant{} (since the
remnant would look unmodified from any other subscribed user record), but also a high \plinked{}.

At the other extreme, if decorrelation modifies the remnant completely by generating random and
potentially meaningless values for all remnant UIDs and IIDs, then an attacker gains little identifying
information from the remnant. However, this may increase \premnant{} significantly.
Alternatively, decorrelation could simply to remove remnants completely. In either case, decorrelation limits the usefulness of remnant data to the application.

Practically, in order to both preserve the usefulness of remnants to the application and provide
decorrelation, \sys{} will need to balance destroying remnant information with revealing identifying
information to the attacker when creating ghosts during unsubscription.
