%-------------------------------------------------------------------------------
\section{\sys API.}
\label{s:api}
%-------------------------------------------------------------------------------
\begin{table*}[t!]
\centering
    \begin{tabular}{ p{.5\linewidth} p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($p$, Email email, PubKey $\pubk{p}$)} $\rightarrow$ () & Registers $p$ as
        a principal with public key \pubk{p}.\\
    \vspace{6pt}\\
        \fn{ApplyDisguise($p$, Disguise $d$, DataCap \dcapa{p}, Vec<LocCap> lcaps)}
        $\rightarrow$\fn{Vec<LocCap>} & 
        Applies disguise $d$ and returns the corresponding disguise $d$ and locating capabilities
        \lcapa{p}{d}. The argument capabilities allow \sys to locate and access disguise diffs,
        which \sys uses to compose disguise $d$ on top of prior disguises.
        \vspace{6pt}\\
    \fn{RevealDisguise($p$, Disguise $d$,
        DataCap \dcapa{p}, LocCap \lcapa{pd})} $\rightarrow$ ()& 
    Reveals disguise $d$. The argument capabilities grant \sys access to database
    diffs from applying $d$, which allows \sys to reveal undisguised data.
        \vspace{6pt}\\
        \fn{CapEstablishesOwnership($p$, DatabaseObj $x$, DataCap \dcapa{p}, LocCap \lcapa{pd})}
    $\rightarrow$ \fn{bool} & Returns
    whether principal $p$ has ownership rights to the provided database object. The capabilities 
    allow \sys to access diffs that can prove that $p$ had been correlated with the object. 
    \end{tabular}
\caption{The \sys Library API}
\label{tab:api}
\end{table*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sys's API in Table~\ref{tab:api} enables the application to support disguise application and
revealing.
%
The application also uses \sys to access and interpret diffs authorized by the provided
capabilities.  Applications integrating with \sys may modify the client API
so that the client can pass capabilities to the application along with the action to perform.
For example, the application can send users URLs to click that invoke application actions with
capability arguments.

We next describe example usages of the API.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Principal Registration.}
Every client who creates an application account for principal $p$ registers an email and public key with \sys.
\sys remembers each public key \pubk{p} along with $p$'s ID.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Disguising and Revealing.}
When a client speaking for principal $p$ wants to apply a disguise $d$,
the application invokes \fn{ApplyDisguise} with the client-provided data
capability and a set of locating capabilities. Each locating capability \lcapa{pd'} allows \sys to
access $p$'s disguise diffs from disguise $d'$, and to compose the new disguise on top of these
disguises during application. Applying a disguise returns the locating capability \lcapa{pd} that
the application sends to the client (via e.g., emailing the client a link).

In order to reveal data disguised by $d$ for principal $p$, the application invokes
\fn{RevealDisguise} on behalf of a client speaking for $p$. The client provides its data capability
\dcapa{p} and locating capability \lcapa{pd}. The application passes these to \sys to restore the
original, undisguised data with access to $p$'s diffs corresponding to $d$.

%\lyt{(ignore this) Why might we need multiple locating capabilities for reveal? This is because diffs may change
%other diffs. But in this case, why don't we have the diff storing the diff change also store the
%location of the diff? Also this might only affect "global" diffs.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Performing Permitted Application Actions.}
Imagine that HotCRP disguise $d$ anonymizes all reviewers and authors of a conference by
decorrelating them from their papers and reviews respectively. As described above, HotCRP emails the
client a link when that their data has been decorrelated, which contains the locating
capability in the URL. Assume that HotCRP sends a unique link for every piece of data (\eg every review
or paper); HotCRP could also send a single link for all decorrelated data.

The application normally ensures that only a client speaking for $p$ should have read-only access to
reviews for $p$'s authored papers, and read-write access to reviews $p$ wrote.

If the client speaking for $p$ wants to edit a review as it would normally, the application
(post-$d)$ will not grant the client any read/write permissions to perform actions on any reviews of
the conference: any previously correlated paper or review is now associated with pseudoprincipal
$q$.  

Instead, for the client speaking for $p$ to regain authorship or reviewership permissions of a
particular review or paper:
\begin{itemize}
    \item The client clicks on the URL emailed to the client for that piece of data when it was decorrelated, which
        opens a HotCRP page.
    \item Javascript on the webpage retrieves the client's data capability
        stored by the client's browser, and extracts the locating capability and the data object the client
        wants to access from the URL.
    \item The client then must log into HotCRP as principal $p$.
    \item HotCRP invokes \sys's \fn{CapEstablishesOwnership} for the data object in question,
        using the capabilities passed in by the client.
    \item If \sys returns \fn{true}, the application permits the client to view the object with ownership
        rights (\eg ability to see reviews on authored papers, or edit their review); otherwise, the
        application does not allow the client to perform privileged actions.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \vspace{6pt}
    %\fn{RegisterPrincipal($p$, email, $\pubk{p}$) $\rightarrow ()$} & Registers $p$ as a principal whose data can be privately disguised.\\
    %\vspace{6pt}
    \fn{GetGlobalAddresses($p$)} $\rightarrow$ \{\addr{p\d}\} & Retrieves the (globally 
    available) addresses associated with principal $p$; nonempty only if $p$ is a pseudoprincipal.\\
    \vspace{6pt}
    \fn{AddressesToEncTokenKeys(\{\addr{}\}) $\rightarrow$ \{Enc(\symk{})\}} & Uses the provided
    addresses to retrieve the corresponding encrypted symmetric keys that were used to encrypt tokens.\\
    \vspace{6pt}
    \fn{GetPseudoPrincipalEncPrivKeys($p$)} $\rightarrow$ \{\tpriv{pq}\} & Retrieves the
    encrypted private key tokens of pseudoprincipal created by decorrelating data from $p$.\\
    \vspace{6pt}
    \fn{Disguise($d$, \{\symk{pd'}\}) $\rightarrow$ \{\addr{}\}} & Applies disguise $d$.  The
    provided set of symmetric keys (potentially corresponding to several disguises and several
    principals) grant \sys access to tokens tokens from these disguises for these principals, which
    allow \sys to compose disguise $d$ on top of these previous disguises.  This function returns a
    set of addresses corresponding to the addresses of \tdata{} and \symk{} ciphertexts produced by this disguise.\\
    \vspace{6pt}
    \fn{Reveal($d$, \{\symk{p\d}\}) $\rightarrow ()$} & 
    Reveals disguise $d$.  The provided set of symmetric keys corresponding to disguise $d$ and
    potentially several principals grant \sys access to tokens from disguise $d$ for these
    principals. \sys reveals the data stored in the tokens if possible.
\end{tabular}
\vspace{6px}

\caption{\sys API}
\label{tab:api}
\end{table*}

\sys takes these developer-provided specifications and exposes the API in Table~\ref{tab:api} to the
application. 

\head{Principal Public Key Registration.}
Figure~\ref{fig:acctreg} illustrates the principal registration protocol: every principal in the
system must register a public key with \sys in order to later reveal (for disguise reversal or
composition) any of privately disguised data. \sys remembers each public key \pubk{p} along with
$p$'s ID.

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\fn{RegisterPrincipal(p,$\pubk{p}$)}} \< \\
\<\< \fn{StorePubKey($\pubk{p}$)}
}
\caption{\textbf{Principal public key registration.}}
\label{fig:acctreg}
\end{figure*} 

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \fn{addrs} \gets \fn{LoadClientAddresses($p$)}\\
\fn{privKs} \gets \{p \mapsto \privk{p}\}\pclb
\pcintertext[dotted]{Recursively get addresses of all linked pseudoprincipals}
\fn{idsToProcess} \gets \{p\}\\
\pcwhile \fn{idsToProcess} \neq \{\}:\\
\quad q \gets \fn{idsToProcess.pop()}\\
\< \sendmessageright*{\fn{GetPseudoPrincipalEncPrivKeys($q$)}} \< \\
\<\< \fn{encPrivKs} \gets \fn{\sys.Principals[q].EncPKTokens}\\
\< \sendmessageleft*{\fn{encPrivKs}} \< \\
\quad \pcforeach \fn{encPrivK} \in \fn{encPrivKs}:\\
\quad \quad \privk{q} \gets \fn{privKeys}[q]\\
\quad \quad \tpriv{qr} \gets \dec(\privk{q}, \fn{encPrivK})\\
\quad\quad\fn{privKs.insert}(r\mapsto \tpriv{qr}.\fn{privKey}) \<\< \\
\quad\quad\fn{idsToProcess.insert($r$)} \<\< \\
\< \sendmessageright*{\fn{GetGlobalAddresses($q$)}} \< \\
\<\< \fn{globalAddrs} \gets \fn{\sys.Principals[q].GlobalAddrs}\\
\< \sendmessageleft*{\fn{globalAddrs}} \< \\
\quad\quad\fn{addrs.append(globalAddrs)}\\
\quad \pcendforeach\\
\pcendwhile\pclb
    \pcintertext[dotted]{Use addresses to get corresponding encrypted token keys}
\< \sendmessageright*{\fn{AddressesToEncTokenKeys(addrs)}} \< \\
    \<\< \fn{encsymkeys} \gets \fn{LoadEncTokenKeys(addrs)}\\
\< \sendmessageleft*{\fn{encsymkeys}}\\
\fn{symkeys} \gets \{\}\\
\pcforeach \fn{Enc(\symk{qd'})} \in \fn{encsymkeys}\\
\quad \pcif \text{authorizes access to $q$'s private tokens for $d'$}: \\
\quad\quad \privk{q} \gets \fn{privKs[q]}\\
\quad\quad \fn{symkeys.insert(\dec(\privk{q}, \symk{qd'}))}\\
\pcendforeach\pclb
\pcintertext[dotted]{Apply disguise with token keys}
\< \sendmessageright*{\fn{Disguise($d$,symkeys)}} \< \\
\<\< \{\addr{}\}\gets\fn{ApplyDisguise($d$,symkeys)} \pclb
\pcintertext[dotted]{Addresses can be emailed by \sys or returned to application}
}
\caption{\textbf{Disguise Application.}}
\label{fig:disgapp}
\end{figure*} 

\head{Disguise Application and Reversal with Addresses.}
As shown in Figure~\ref{fig:disgapp}, an \sys client can retrieve addresses both provided for an
original principal $p$ (for which the client is authenticated and has \privk{p}). 

The client can also retrieve addresses and private keys for all pseudoprincipals associated with $p$.

Using these addresses, the client can query for encrypted symmetric \symk{} keys corresponding to
the set of provided addresses; and decrypt and provide these \symk{}s to \sys to disguise (or reveal) using token data that can be decrypted using the provided \symk{}.

\iffalse
\vspace{6pt}\noindent\textbf{(2) \tdata{} Token Ciphertext Storage.}
\sys must hide which token ciphertexts correspond to which principals.  Naively, \sys can store
all ciphertexts in one bag; in order to determine which ciphertexts a client may access, the client
provides the decrypted \symk{p\d} and \sys tries to decrypt every ciphertext in the bag. This clearly
has poor performance and is unscalable.
However, \sys cannot group the ciphertexts into bags indexed by principal ID: this leaks information
about the number of private tokens associated with a principal.

To provide metadata privacy while achieving better performance, \sys stores encrypted \tdata{p\d} and
\tpriv{pq} tokens in a linked list of encrypted tokens produced by $d$ associated with $p$, notated
as \tokls{p\d}. 
Tokens store links to the next token in the list with in an additional \fn{nextEncToken} field: this
field stores a pointer to the location of current tail of \tokls{p\d} for $p$ and $d$.
Thus, only by decrypting tokens in the list one by one can the entire \tokls{p\d} be discovered and
the ciphertexts in the list decrypted.

\sys stores current pointers to the tails of \tokls{p\d} indexed by $p$ and $d$. This allows \sys to
know where to start decrypting the list of tokens given $p$ and $d$, and how to set
\fn{nextEncToken} for a new token in \tokls{p\d} produced when applying $d$. \sys generates dummy
tail pointers for all principals not associated with disguise $d$ to hide metadata about which lists
exist.
Because \tokls{p\d} tails point to (real or dummy) token ciphertexts, an adversary learns nothing
about the token contents or how many tokens are associated with a principal.

\vspace{6pt}\noindent\textbf{(3) \tpriv{} Token Ciphertext Storage.}
\lyt{For this, we would need to store in a linked list, each node would have to be sent one at a
time to the client because each token is encrypted with \pubk{p}}.

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.6\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \vspace{6pt}
    \fn{RegisterPrincipal($\pubk{p}$)} & Registers $p$ as a principal whose data can be privately disguised. \\
    \vspace{6pt}
    \fn{PseudoPrincipalKeysRequest($p$)} & Requests the encrypted private keys of pseudoprincipals
    created by decorrelating data from $p$.\\
    \vspace{6pt}
    \fn{PseudoPrincipalKeysResponse(encPrivKs)} & Sent from \sys to the client authenticated as $p$ with the set of encrypted
    private keys of pseudoprincipals linked to $p$.\\
    \vspace{6pt}
    \fn{StartDisguise($d$, addrs, ppIds)} & Begins the process of applying disguise
    $d$, granting \sys access to prior disguised data of $p$'s with the provided addresses in
    \texttt{addrs}, and access to prior disguised data of any pseudoprincipals in \texttt{ppIds}.\\
    \vspace{6pt}
    \fn{StartDisguiseReversal($d$, addrs, ppIds)} & Begins the process of reversing disguise $d$,
    granting \sys access to prior disguised data of $p$'s with the provided addresses in \texttt{addrs}, and access to prior disguised data of any pseudoprincipals in \texttt{ppIds}.\\
    \vspace{6pt}
    \fn{RequestTokenAccess(encSymKeys)} & Sent from \sys to a client authenticated as
    $p$, requesting the client decrypt all the encrypted symmetric keys in \fn{encSymKeys} with
    \privk{p} and uncover the corresponding \symk{p\d}s. \\
    \vspace{6pt}
    \fn{GrantTokenAccess(\{\symk{p\d}\})} & Grants \sys permission, for all \symk{p\delta} in the
    argument, to decrypt any privately-stored \tdata{p\d} and \tpriv{pdq} with \symk{p\delta}.
\end{tabular}
    \vspace{6px}
\caption{API Calls for Client Authenticated as Principal $p$}
\label{tab:api_impl}
\end{table*}

Table~\ref{tab:api} describes all the API calls used in protocols between \sys and a client.
\lyt{Not sure if the admin- vs. user-authenticated client distinction is clear here..}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{PseudoPrincipal Private Key Retrieval.}
Figure~\ref{fig:userprivkeyretrieval} illustrates the protocol by which a client, authenticated as
principal $p$, can gain access to the private keys (and thus the tokens) of pseudoprincipals created
from decorrelating $p$'s data.

The client sends a request to \sys for the private keys of pseudoprincipals linked to $p$. \sys
loads the encrypted private key tokens for $p$, and sends these back in a response to the client.
%
The client then decrypts these tokens with \privk{p}, and saves the mapping from pseudoprincipal ID
$q$ to private key \privk{q} encoded in the token.

The client recursively retrieves the private keys of all pseudoprincipals linked to $q$ until
no more nested pseudoprincipals exist.

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\fn{privKs} \gets \{p \mapsto \privk{p}\}\\
\fn{idsToProcess} \gets \{p\}\\
\fn{ppIds} \gets \{\}\\
\pcwhile \fn{idsToProcess} \neq \{\}:\\
\quad q \gets \fn{idsToProcess.pop()}\\
\< \sendmessageright*{\fn{PseudoPrincipalKeysRequest($q$)}} \< \\
\<\< \fn{encPrivKs} \gets \fn{LoadEncPrivKTokens}(q)\\
\< \sendmessageleft*{\fn{PseudoPrincipalKeysResponse(encPrivKs)}} \< \\
\quad \pcforeach \fn{encPrivK} \in \fn{encPrivKs}:\\
\quad \quad \privk{q} \gets \fn{privKs}[q]\\
\quad \quad \tpriv{qd'r} \gets \dec(\privk{q}, \fn{encPrivK})\\
\quad \quad \pcif \text{authorizes access to $r$'s private tokens}: \\
\quad \quad\quad\fn{privKs.insert}(r\mapsto \tpriv{qd'r}.\fn{privKey}) \<\< \\
\quad \quad\quad\fn{idsToProcess.insert($r$)} \<\< \\
\quad \quad\pcfi\\
\quad \pcif q \neq p:\\
\quad\quad \fn{ppIds.append($q$)}\\
\quad \pcfi\\
\quad \pcendforeach\\
\pcendwhile
}
\caption{\textbf{PseudoPrincipal Key Retrieval.}}
\label{fig:userprivkeyretrieval}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{User-Authenticated Disguise Application.}
Figure~\ref{fig:userauthdisapp} illustrates the protocol for user-authenticated (as principal $p$) disguise application.

The client first performs pseudoprincipal private key retrieval for $p$, and retrieves all addresses from
prior disguises for which the client grants token access.
%
The client then invokes \fn{StartDisguise} with these addresses and the set of pseudoprincipals.

\sys takes the addresses of $p$ and the public addresses of all pseudoprincipals in the
provided set, and retrieves the corresponding encrypted \symk{}s.
\sys then requests to access all private tokens protected by these symmetric keys by sending a
\fn{RequestTokenAccess} to the client with the \symk{} ciphertexts.

The client decrypts the ciphertexts using the appropriate \privk{q} (proving
that the client has access to $q$'s private tokens). 
%
The client only includes the decrypted \symk{qd'} in the set of keys sent back to \sys via a
\fn{GrantTokenAccess} API call if the client wants to authorizes access to $q$'s private tokens
from disguise $d'$. 

\sys then uses each \symk{qd'} to decrypt $q$'s private tokens produced by disguise $d'$. Note that
if the client returns a false \symk{qd'}, the decryption will fail, and \sys will not reveal any
$q$'s private tokens from $d'$.

\sys combines all decrypted private tokens with the set of globally accessible tokens to produce
all tokens available to apply disguise $d$. 

\lyt{Note: this requires that a client be user-authenticated as $p$ to access $p$'s tokens, which
isn't necessarily fundamental.}

\begin{figure*}[t!]
\pcb{
\<\< \\[-1\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]\\
\texttt{//perform pseudoprincipal key retrieval}\\
\fn{addrs} \gets \{\}\\
\pcforeach \addr{pd'} \in \fn{client.Addresses}:\\
\quad \pcif \text{authorizes access to $d'$ tokens for $p$}: \\
\quad\quad\fn{addrs.insert(\addr{pd'})} \<\< \\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{StartDisguise($d$,addrs,ppIds)}} \< \\
\<\< \fn{symKeyEncs} \gets \{\}\\
    \<\< \fn{symKeyEncs.insert(LoadEncSymKeys(addrs))}\\
\<\< \pcforeach q \in \fn{ppIds}:\\
\<\< \quad\quad\fn{ppAddrs} \gets \fn{\sys.PseudoPAddrs[q]}\\
\<\< \quad\quad\fn{symKeyEncs.insert(}\\
\<\< \quad\quad\quad\quad \fn{LoadEncSymKeys(ppAddrs))}\\
\<\< \quad\pcendif\\
\<\< \pcendforeach\\
\< \sendmessageleft*{\fn{RequestTokenAccess(symKeyEncs)}} \< \\
\fn{symKeys} \gets \{\}\\
\pcforeach \fn{encSymKey} \in \fn{symKeyEncs}:\\
\quad q \gets \fn{encSymKey.principalId}\\
\quad d' \gets \fn{encSymKey.disguiseId}\\
\quad \privk{q} \gets \fn{privKeys}[q]\\
\quad \pcif \text{authorizes access to $d'$ tokens for $q$}: \\
\quad\quad \fn{symKeys.insert(\dec(\privk{q}, \fn{encSymKey})}\\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{GrantTokenAccess(\fn{symKeys})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
    \<\< \quad\fn{tokens.insert(}\\
    \<\<\quad\quad\fn{ReadGlobalTokens}(d'))\\ 
\<\< \pcendforeach\\
\<\< \pcforeach \symk{qd'} \in \fn{symKeys}: \\
\<\< \quad\fn{tokens.insert(}\\
\<\< \quad \quad \fn{ReadPrivateTokens(\symk{qd'}))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{User-Authenticated disguise application.}}
    \label{fig:userauthdisapp}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Admin-Authenticated Disguise Application.}
In contrast to user-authenticated disguise application, \sys does not request access to any private
tokens, and instead simply applies the disguise with only globally-accessible tokens (shown in Figure~\ref{fig:adminauthdisapp}).

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Admin-authenticated Client} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \< \sendmessageright*{\fn{StartDisguise($d$,\{\},\{\})}} \< \\
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\fn{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Admin-authenticated disguise application}. }
    \label{fig:adminauthdisapp}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Disguise Reversal.}
User- and admin-authenticated disguise
reversal protocols follow the same logic as disguise application protocols, with the only
differences being the API call invoked by the client 
(\fn{StartDisguiseReversal}\fn{($d$,addrs,ppIds)}) and the
function that \sys calls at the end (\fn{ReverseDisguise} \fn{($d$,tokens)}).
\fi
\fi
