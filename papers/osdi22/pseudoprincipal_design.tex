%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pseudoprincipal Tokens Design}

To apply one disguise on top of another in a way that supports, \eg comment removal after universal
decorrelation, \sys should support disguises that modify data belonging to pseudoprincipals, and which
produce tokens for pseudoprincipals.
%
For example, after universal decorrelation, every paper or review correlates with a pseudoprincipal
user. If the application then performs a disguise to remove papers, the corresponding diff token 
would be associated with pseudoprincipals.

However, pseudoprincipals $q$ have no corresponding real user known to the application or \sys (for
unlinkability, the application server and \sys cannot store pseudoprincipal-user correspondences). 
This means that there is no ability to store the corresponding decryption capability \privk{q}
external to the application or \sys.
To support pseudoprincipal tokens, \sys needs to securely store pseudoprincipal decryption
capabilities (private keys) such that only authorized users can access them.

The simplest designs either fail to achieve this security property, or reduce functionality:
\begin{enumerate}
    \item \emph{Weak Security:} \sys can store \privk{q} in plaintext for pseudoprincipal $q$. 
        This is equivalent to $q$'s data being undisguised after compromise.  
    \item \emph{Permanent Disguises:} \sys throws away \privk{q} for pseudoprincipal $q$. This means that the
            disguise modifications to pseudoprincipal data are permanent, and prevents temporary
            recorrelation and disguise revealing.
\end{enumerate}

\head{Pseudoprincipal Private Keys.}
When a pseudoprincipal $q$ is generated to decorrelate data from $p$: 
\begin{enumerate}
    \item \sys generates keypair (\pubk{q}, \privk{q}) for $q$
    \item encrypts the private key of $q$ with \pubk{p} to produce $\enc(\pubk{p}, \privk{q})$
    \item stores $\enc(\pubk{p}, \privk{q})$ at location \lcapa{pd} along with $p$'s encrypted diffs from disguise $d$
\end{enumerate}
This ensures that a client with \lcapa{pd} and \privk{p} (\privk{p}) can access \privk{q}, the data
capability of pseudoprincipal $q$.  Furthermore, only a client who holds \lcapa{pd} can learn
that $p$ has decorrelated data because associated pseudoprincipal private keys are not stored
publically with $p$'s ID.

When \sys applies disguise $d'$ to further disguise pseudoprincipal $q$'s data, \sys:
\begin{enumerate}
    \item stores disguise diffs \tdiff{qd'} at location \lcapa{qd}
    \item encrypts \lcapa{qd} with \pubk{p} to produce $\enc(\pubk{p}, \lcapa{qd})$
    \item stores $\enc(\pubk{p}, \lcapa{qd})$ mapped to by principal $q$'s ID
\end{enumerate}
Note that \sys stores \lcapa{qd} ciphertexts associated with $q$'s ID, whereas for a real principal
$p$, \sys does not store any similar metadata indicating how many disguises have applied to $p$. 
This means that an adversary can learn that \emph{some} disguise has applied to and
decorrelated data from $q$. However, this falls out of scope in our threat model: $q$ is a
pseudoprincipal created from a decorrelation operation, and therefore any disguise metadata regarding $q$ has already been dissociated from
the original principal $p$'s identity.

\lyt{TODO}

Thus, locators \lcapa{qd} produced by disguising pseudoprincipal $q$ to a user who speaks for pseudoprincipal $p$!
We now have a problem. Diffs are encrypted with \privk{p} and stored at
\lcapa{pd}, and \sys emails \lcapa{pd} to (potentially offline) clients and does not retain
\lcapa{pd}.  
%, so pseudoprincipals' capabilities can either be insecurely stored by \sys, or lost forever!


  

\head{Extending capabilities to authorize pseudoprincipal diffs access.}
With this extended design, a client speaking for $p$ that provides data and locating capabilities%\pcapa{p}{d}
authorizes access to \emph{both} $p$'s diffs for disguise $d$, \emph{and}
diffs of a pseudoprincipal $q$ created by
decorrelating $p$'s data. \lyt{I don't think we're necessarily allowing clients to speak for $q$,
but rather to perform actions using $q$'s diffs.}

Given a data capability \privk{p}, \sys can can access \privk{q} by decrypting \enc(\pubk{p},
\privk{q}).
%
With \privk{q}, \sys can decrypt all \enc(\pubk{q}, \lcapa{qd}) so that \sys has both the data and
location capabilities for all of $q$'s disguise diffs. This allows the application to reveal,
disguise, or perform application actions with access to diffs from all disguises applying to $q$.

While clearly more expensive for \sys to execute, this protocol allows \sys to recursively disguise
pseudoprincipals, yet still require only the top-level original principal capabilities to support the
desired use cases. Furthermore, this design still meets our security goals: data capabilities secure
all disguise diffs, and an adversary learns no disguise metadata for real users.

%This introduces another round-trip for any client using the API: a client speaking for $p$ that
%wants to reveal or compose on top of pseudoprincipal diffs must (1) query for all pseudoprincipal
%\privk{q} ciphertexts associated with $p$ for all \lcapa{qd} (for all $d$); (2) recursively
%query for all nested pseudoprincipal \privk{q} ciphertexts associated with $q$ for all \lcapa{qd};
%and (3) actually invoke the action with the decrypted capability pairs.
%
%This makes it difficult to implement a userflow where the user can click on a single URL to grant
%\sys diff access: in this design, the user has to first retrieve all possible URLs, and make several
%more round-trips to the application/\sys.
