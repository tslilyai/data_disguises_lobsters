%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pseudoprincipal Tokens Design}

To apply one disguise on top of another in a way that supports, \eg comment removal after universal
decorrelation, \sys should support disguises that modify data belonging to pseudoprincipals, and which
produce tokens for pseudoprincipals.
%
For example, after universal decorrelation, pseudoprincipals own every paper or review. If the
application then performs a disguise to remove papers, the corresponding diff token would be
associated with pseudoprincipals.

To secure these tokens, \sys needs to encrypt them in some way. The simplest way would be to use
\pubk{p}, where $p$ is the real principal linked to the pseudoprincipal being disguised.
However, \sys does not know which real user corresponds to which pseudoprincipals (for
unlinkability, the application server/\sys cannot store pseudoprincipal-user correspondences). 

Instead, \sys associates each pseudoprincipal $q$ with a keypair \pubk{q} and \privk{q}, and treats
pseudoprincipals the same as any other principal in the system. \sys encrypts pseudoprincipal tokens
with \pubk{q}, and requires decryption capability \privk{q} to access these tokens. \sys must
securely store pseudoprincipal decryption capabilities \privk{q} such that only authorized
users---those who can speak for the original principal linked to pseudoprincipals---can
access them.

\head{Protecting Pseudoprincipal Decryption Capabilities.}
To secure access to pseudoprincipal private keys, \sys leverages the fact that 
when a disguise generates pseudoprincipals, the link between pseudoprincipal and original principal
is known. 

When disguise $d$ decorrelates data from $p$ and asks \sys to generate a pseudoprincipal $q$, \sys does the following: 
\begin{enumerate}
    \item \sys generates keypair (\pubk{q}, \privk{q}) for $q$
    \item encrypts the private key of $q$ with \pubk{p} to produce $\enc(\pubk{p}, \privk{q})$
    \item stores $\enc(\pubk{p}, \privk{q})$ at location \lcapa{pd} along with $p$'s encrypted diffs from disguise $d$
\end{enumerate}

Note that the application cannot simply send \privk{q} via \eg email to the corresponding
real user: the original principal whose data is being decorrelated may in fact be a pseudoprincipal
itself, and therefore unassociated with any real email!

This method ensures that only a client with \lcapa{pd} and \privk{p} can access \privk{q}, the data
capability of pseudoprincipal $q$. 
%Furthermore, only a client who holds \lcapa{pd} can learn
%that $p$ has decorrelated data because associated pseudoprincipal private keys are not stored
%publically with $p$'s ID.

\head{Securing Pseudoprincipal Tokens.}
When \sys applies disguise $d$ to further disguise pseudoprincipal $q$'s data, \sys:
\begin{enumerate}
    \item stores disguise tokens \tdiff{qd} and \town{qd} at location \lcapa{qd}
    \item encrypts \lcapa{qd} with \pubk{q} to produce $\enc(\pubk{q}, \lcapa{qd})$
    \item stores \lcapa{qd} associated with principal $q$'s ID
\end{enumerate}
Note that the process for pseudoprincipal tokens is the same as that for real principal tokens up to
step (3): \sys stores \lcapa{qd} associated with $q$'s ID, whereas \sys returns all locators to
the application when producing real principal tokens (and then forgets these locators).
This is because the application and \sys may not know which original principal can speak for $q$,
and therefore cannot \eg email \lcapa{qd} to the appropriate user.

Storing \lcapa{qd} on the server allows an adversary can learn that \emph{some} disguise has
applied to $q$. However, this falls out of scope in our threat model: $q$ is a pseudoprincipal
created by a disguise, and therefore any disguise metadata regarding $q$ has already been
dissociated from the original principal $p$'s identity.

\head{Extending capabilities to authorize pseudoprincipal diffs access.}
With this extended design, a client speaking for $p$ that provides data and locating capabilities%\pcapa{p}{d}
authorizes access to \emph{both} $p$'s diffs for disguise $d$, \emph{and}
diffs of a pseudoprincipal $q$ created by
decorrelating $p$'s data. \lyt{I don't think we're necessarily allowing clients to speak for $q$,
but rather to perform actions using $q$'s diffs.}

Given a data capability \privk{p}, \sys can can access \privk{q} by decrypting \enc(\pubk{p},
\privk{q}).
%
With \privk{q}, \sys can decrypt all \enc(\pubk{q}, \lcapa{qd}) so that \sys has both the data and
location capabilities for all of $q$'s disguise diffs. This allows the application to reveal,
disguise, or perform application actions with access to diffs from all disguises applying to $q$.

While clearly more expensive for \sys to execute, this protocol allows \sys to recursively disguise
pseudoprincipals, yet still require only the top-level original principal capabilities to support the
desired use cases. Furthermore, this design still meets our security goals: data capabilities secure
all disguise diffs, and an adversary learns no disguise metadata for real users.

%This introduces another round-trip for any client using the API: a client speaking for $p$ that
%wants to reveal or compose on top of pseudoprincipal diffs must (1) query for all pseudoprincipal
%\privk{q} ciphertexts associated with $p$ for all \lcapa{qd} (for all $d$); (2) recursively
%query for all nested pseudoprincipal \privk{q} ciphertexts associated with $q$ for all \lcapa{qd};
%and (3) actually invoke the action with the decrypted capability pairs.
%
%This makes it difficult to implement a userflow where the user can click on a single URL to grant
%\sys diff access: in this design, the user has to first retrieve all possible URLs, and make several
%more round-trips to the application/\sys.

\lyt{Note somewhere that pseudoprincipals and recursive disguising are why we need asymmetric crypto; otherwise, we
could just send the symmetric key to the original user being disguised?}

\iffalse
Two strawmen, simple designs either fail to achieve this security property, or reduce functionality:
\begin{enumerate}
    \item \emph{Weak Security:} \sys can store \privk{q} in plaintext for pseudoprincipal $q$. 
        This is equivalent to $q$'s data being undisguised after compromise.  
    \item \emph{Permanent Disguises:} \sys throws away \privk{q} for pseudoprincipal $q$. This means that the
            disguise modifications to pseudoprincipal data are permanent, and prevents temporary
            recorrelation and disguise revealing.
\end{enumerate}

\fi
