%-------------------------------------------------------------------------------
\section{Design} 
%-------------------------------------------------------------------------------
\subsection{Disguise Operations.} 
Because disguises are inherently application-specific, the application developer 
specifies a disguise as a 
%provides disguise
%specifications that consist of a 
set of predicated disguise operations \op{d} to perform.

Operations \op{d} of disguise $d$ take data objects as input and execute updates to application
data.  \sys automatically generates database change records when applying \op{d}. 

Developers describe which principal(s) an operation's generated database change record corresponds
to. For example, a database change record generated by removing comment may correspond to the
principal whose ID is referenced by the author column.  

Developers also specify an application-aware pseudoprincipal generation policy, namely how to
generate new user accounts in a manner that the application can handle (e.g., pseudoprincipals may
not have email addresses).

Finally, developers specify which principals are authorized to apply the disguise: enforcing access
control for disguising is left to the application.  
%\lyt{It seems most reasonable for the
%pplication to enforce AC for the disguising API the application exposes to the client?}

\vspace{6pt}\noindent
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.  
\end{enumerate}

\noindent For each \op{d}, the application developer specifies:
\begin{itemize}
    \item An associated predicate over the application database that selects \op{d}'s input
        objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The corresponding principal(s) that should have the capability to access \op{d}'s
        generated disguise change or correlation record.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Database Diffs.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Every \op{d} produces a \emph{database diff} \tdiff{pd} associated with the disguise $\delta$ and a principal $p$. 
%
Each \tdiff{pd} contains the ID of the disguise, the associated principal $p$'s ID,
and a random nonce.
%
In addition to this data, a decorrelation \tdiff{pd} contains the created pseudoprincipal's
ID; a removal \tdiff{pd} contains the removed object's value; and a modification
\tdiff{pd} contains the old and new value of the modified object.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Diff Access Control.} 

\head{Securing Access to Database Diffs.} 
\sys's design uses principal $p$'s private key \privk{p} as the decryption capability \privk{p}. \sys
secures $p$'s diffs \tdiff{pd} by encrypting them with \pubk{p}. The diff's nonce ensures safety
against known-plaintext attacks. 
Only a client who knows \privk{p} can access diffs.

%\sys represents a decryption capability \privk{p} as a symmetric key specific to
%the disguise and principal.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Disguise History.}
\sys's design may leak information that $d$ disguised principal $p$ because an adversary may learn
that ciphertexts for \tdiff{pd} exist for a particular $p$ and $d$.  This is a problem: for example,
\sys should not store information that a principal $p$ has invoked GDPR deletion.

To avoid this problem, \sys stores an array of \tdiff{pd} ciphertexts at random location pointed to
by locating capability \lcapa{pd}.  This dissociates one disguise applied to a principal $p$ from
all other disguises, so an adversary only ever learns about a single disguise if \sys gains
permission to reveal or compose upon that disguise.

Note that an adversary without access to any \lcapa{pd} can learn that $n$ diffs exist for
\emph{some} $p$ and $d$, but cannot directly identify which $p$ or $d$.  If an adversary has access
to \lcapa{pd}, the adversary can learn that $d$ applied to $p$, and the number of \tdiff{pd} diffs
for that $p$ and $d$. This metadata is out of scope of our threat model.
\lyt{An alternative design might remove the encrypted data completely (and email it to the client),
so that an adversary doesn't even know of its existence. However, since we're allowing disguised
data to be distinguished from undisguised data, this seems potentially unnecessary.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storage of Capabilities.}
\sys should not store \privk{p} or \lcapa{pd}: an adversary could then learn that $d$ has applied to
principal $p$. Thus, these capabilities must be stored externally, even when no client speaking for
$p$ is currently online.
%
%The only exception to this occurs when $p$ is a pseudoprincipal: in this case, \sys saves a
%(globally accessible) mapping from $p$ to \lcapa{pd}. This leaks the disguise history of
%pseudoprincipals, but is allowable because pseudoprincipals' data has already been decorrelated from their
%original principal owner.
%

Clients already hold \privk{p}: a client generates a keypair for a new principal $p$ and stores
\privk{p}, while registering \pubk{p} with \sys. \sys only stores \pubk{p}.

Because \sys generates \lcapa{pd} during disguising, \sys must communicate \lcapa{pd} to clients.
\sys emails \lcapa{pd} to the corresponding email address associated with $p$.  This allows \sys to
disguise data of principals even when no client authenticated as $p$ has an active session open.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Current Design: Discussion}
As the current design stands, \sys supports 1st-person and 3rd-person disguising, as well as
1st-person revealing.
%
Application developers can write GDPR-compliant and/or universal disguises with the primitives
exposed by \sys to write disguise specifications.
%
\sys uses diffs produced from disguising to reveal data when authorized to do so, and when
revealing does not revert updates made to the data since the time of disguise application.

%
\sys also supports ``Temporary Recorrelation without Database Changes'' because \sys can determine
the original owner of data as long as \sys has access to decorrelation diffs (which the client or
the application provides via the appropriate capabilities).
%
\sys can use information from decorrelation diffs to disguise decorrelated data as if it were owned
by the original user; and 
%
\sys can support the API discussed in \S\ref{s:api}, which allows applications to query \sys to
check ownership properties and grant authorized users personalized views and permissions to access
data objects.

Furthermore, \sys does this while meeting all security goals: \sys supports authorized disguises and
ensures the security of ownership claims, disguise diffs, and disguise history.

Our current design falls short, however, by failing to support ``Disguising Anonymized
Users'' which we explain next.
