%-------------------------------------------------------------------------------
\section{Design} 
%-------------------------------------------------------------------------------

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.8\linewidth} }
\textbf{Symbol} & \textbf{Description} \\
\hline
    \vspace{6pt}
$p$ & application principals, corresponding to a user ID in the application\\
    \vspace{6pt}
$d$ & disguise invoked by authorized principals that transforms the application database in
    privacy-preserving ways\\
    \vspace{6pt}
\op{d} & a disguise operation (either a removal, modification, or decorrelation)\\
    \vspace{6pt}
\tdata{pd} & database diff associated with $p$ produced by disguise $d$.\\
    \vspace{6pt}
\dcapa{p} & data capability that grants access to all disguises' diffs associated with principal
    $p$. \\
    \vspace{6pt}
\lcapa{pd} & locating capability that allows the holder to find the database diffs from
    $d$ associated with a principal $p$.\\
    \vspace{6pt}
\pubk{p} & public key of $p$ \\
    \vspace{6pt}
\privk{p} & private key of $p$ \\
    \end{tabular}
\caption{Notation used to describe \sys's design.}
\label{tab:notation}
\end{table*}

%-------------------------------------------------------------------------------
\section{\sys API.}
\label{s:api}
%-------------------------------------------------------------------------------
\begin{table*}[t!]
\centering
    \begin{tabular}{ p{.5\linewidth} p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($p$, Email email, PubKey $\pubk{p}$)} $\rightarrow$ () & Registers $p$ as
        a principal with public key \pubk{p}.\\
    \vspace{6pt}\\
        \fn{ApplyDisguise($p$, Disguise $d$, DataCap \dcapa{p}, Vec<LocCap> lcaps)}
        $\rightarrow$\fn{Vec<LocCap>} & 
        Applies disguise $d$ and returns the corresponding disguise $d$ and locating capabilities
        \lcapa{p}{d}. The argument capabilities allow \sys to locate and access disguise diffs,
        which \sys uses to compose disguise $d$ on top of prior disguises.
        \vspace{6pt}\\
    \fn{RevealDisguise($p$, Disguise $d$,
        DataCap \dcapa{p}, LocCap \lcapa{pd})} $\rightarrow$ ()& 
    Reveals disguise $d$. The argument capabilities grant \sys access to database
    diffs from applying $d$, which allows \sys to reveal undisguised data.
        \vspace{6pt}\\
        \fn{CapEstablishesOwnership($p$, DatabaseObj $x$, DataCap \dcapa{p}, LocCap \lcapa{pd})}
    $\rightarrow$ \fn{bool} & Returns
    whether principal $p$ has ownership rights to the provided database object. The capabilities 
    allow \sys to access diffs that can prove that $p$ had been correlated with the object. 
    \end{tabular}
\caption{The \sys Library API}
\label{tab:api}
\end{table*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sys's API in Table~\ref{tab:api} enables the application to support disguise application and
revealing.
%
The application also uses \sys to access and interpret diffs authorized by the provided
capabilities.  Applications integrating with \sys may modify the client API
so that the client can pass capabilities to the application along with the action to perform.
For example, the application can send users URLs to click that invoke application actions with
capability arguments.

We next describe example usages of the API.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Principal Registration.}
Every client who creates an application account for principal $p$ registers an email and public key with \sys.
\sys remembers each public key \pubk{p} along with $p$'s ID.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Disguising and Revealing.}
When a client speaking for principal $p$ wants to apply a disguise $d$,
the application invokes \fn{ApplyDisguise} with the client-provided data
capability and a set of locating capabilities. Each locating capability \lcapa{pd'} allows \sys to
access $p$'s disguise diffs from disguise $d'$, and to compose the new disguise on top of these
disguises during application. Applying a disguise returns the locating capability \lcapa{pd} that
the application sends to the client (via e.g., emailing the client a link).

In order to reveal data disguised by $d$ for principal $p$, the application invokes
\fn{RevealDisguise} on behalf of a client speaking for $p$. The client provides its data capability
\dcapa{p} and locating capability \lcapa{pd}. The application passes these to \sys to restore the
original, undisguised data with access to $p$'s diffs corresponding to $d$.

%\lyt{(ignore this) Why might we need multiple locating capabilities for reveal? This is because diffs may change
%other diffs. But in this case, why don't we have the diff storing the diff change also store the
%location of the diff? Also this might only affect "global" diffs.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Performing Permitted Application Actions.}
Imagine that HotCRP disguise $d$ anonymizes all reviewers and authors of a conference by
decorrelating them from their papers and reviews respectively. As described above, HotCRP emails the
client a link when that their data has been decorrelated, which contains the locating
capability in the URL. Assume that HotCRP sends a unique link for every piece of data (\eg every review
or paper); HotCRP could also send a single link for all decorrelated data.

The application normally ensures that only a client speaking for $p$ should have read-only access to
reviews for $p$'s authored papers, and read-write access to reviews $p$ wrote.

If the client speaking for $p$ wants to edit a review as it would normally, the application
(post-$d)$ will not grant the client any read/write permissions to perform actions on any reviews of
the conference: any previously correlated paper or review is now associated with pseudoprincipal
$q$.  

Instead, for the client speaking for $p$ to regain authorship or reviewership permissions of a
particular review or paper:
\begin{itemize}
    \item The client clicks on the URL emailed to the client for that piece of data when it was decorrelated, which
        opens a HotCRP page.
    \item Javascript on the webpage retrieves the client's data capability
        stored by the client's browser, and extracts the locating capability and the data object the client
        wants to access from the URL.
    \item The client then must log into HotCRP as principal $p$.
    \item HotCRP invokes \sys's \fn{CapEstablishesOwnership} for the data object in question,
        using the capabilities passed in by the client.
    \item If \sys returns \fn{true}, the application permits the client to view the object with ownership
        rights (\eg ability to see reviews on authored papers, or edit their review); otherwise, the
        application does not allow the client to perform privileged actions.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Disguise Operations.} 
Because disguises are inherently application-specific, the application developer 
specifies a disguise as a 
%provides disguise
%specifications that consist of a 
set of predicated disguise operations \op{d} to perform.

Operations \op{d} of disguise $d$ take data objects as input and execute updates to application
data.  \sys automatically generates database change records when applying \op{d}. 

Developers describe which principal(s) an operation's generated database change record corresponds
to. For example, a database change record generated by removing comment may correspond to the
principal whose ID is referenced by the author column.  

Developers also specify an application-aware pseudoprincipal generation policy, namely how to
generate new user accounts in a manner that the application can handle (e.g., pseudoprincipals may
not have email addresses).

Finally, developers specify which principals are authorized to apply the disguise: enforcing access
control for disguising is left to the application.  
%\lyt{It seems most reasonable for the
%pplication to enforce AC for the disguising API the application exposes to the client?}

\vspace{6pt}\noindent
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.  
\end{enumerate}

\noindent For each \op{d}, the application developer specifies:
\begin{itemize}
    \item An associated predicate over the application database that selects \op{d}'s input
        objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The corresponding principal(s) that should have the capability to access \op{d}'s
        generated disguise change or correlation record.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Database Diffs.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Every \op{d} produces a \emph{database diff} \tdata{pd} associated with the disguise $\delta$ and a principal $p$. 
%
Each \tdata{pd} contains the ID of the disguise, the associated principal $p$'s ID,
and a random nonce.
%
In addition to this data, a decorrelation \tdata{pd} contains the created pseudoprincipal's
ID; a removal \tdata{pd} contains the removed object's value; and a modification
\tdata{pd} contains the old and new value of the modified object.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Diff Access Control.} 

\head{Securing Access to Database Diffs.} 
\sys's design uses principal $p$'s private key \privk{p} as the data capability \dcapa{p}. \sys
secures $p$'s diffs \tdata{pd} by encrypting them with \pubk{p}. The diff's nonce ensures safety
against known-plaintext attacks. 
Only a client who knows \privk{p} can access diffs.

%\sys represents a data capability \dcapa{p} as a symmetric key specific to
%the disguise and principal.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Disguise History.}
\sys's design may leak information that $d$ disguised principal $p$ because an adversary may learn
that ciphertexts for \tdata{pd} exist for a particular $p$ and $d$.  This is a problem: for example,
\sys should not store information that a principal $p$ has invoked GDPR deletion.

To avoid this problem, \sys stores an array of \tdata{pd} ciphertexts at random location pointed to
by locating capability \lcapa{pd}.  This dissociates one disguise applied to a principal $p$ from
all other disguises, so an adversary only ever learns about a single disguise if \sys gains
permission to reveal or compose upon that disguise.

Note that an adversary without access to any \lcapa{pd} can learn that $n$ diffs exist for
\emph{some} $p$ and $d$, but cannot directly identify which $p$ or $d$.  If an adversary has access
to \lcapa{pd}, the adversary can learn that $d$ applied to $p$, and the number of \tdata{pd} diffs
for that $p$ and $d$. This metadata is out of scope of our threat model.
\lyt{An alternative design might remove the encrypted data completely (and email it to the client),
so that an adversary doesn't even know of its existence. However, since we're allowing disguised
data to be distinguished from undisguised data, this seems potentially unnecessary.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storage of Capabilities.}
\sys should not store \dcapa{p} or \lcapa{pd}: an adversary could then learn that $d$ has applied to
principal $p$. Thus, these capabilities must be stored externally, even when no client speaking for
$p$ is currently online.
%
%The only exception to this occurs when $p$ is a pseudoprincipal: in this case, \sys saves a
%(globally accessible) mapping from $p$ to \lcapa{pd}. This leaks the disguise history of
%pseudoprincipals, but is allowable because pseudoprincipals' data has already been decorrelated from their
%original principal owner.
%

Clients already hold \dcapa{p}: a client generates a keypair for a new principal $p$ and stores
\privk{p}, while registering \pubk{p} with \sys. \sys only stores \pubk{p}.

Because \sys generates \lcapa{pd} during disguising, \sys must communicate \lcapa{pd} to clients.
\sys emails \lcapa{pd} to the corresponding email address associated with $p$.  This allows \sys to
disguise data of principals even when no client authenticated as $p$ has an active session open.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Current Design: Discussion}
As the current design stands, \sys supports 1st-person and 3rd-person disguising, as well as
1st-person revealing.
%
Application developers can write GDPR-compliant and/or universal disguises with the primitives
exposed by \sys to write disguise specifications.
%
\sys uses diffs produced from disguising to reveal data when authorized to do so, and when
revealing does not revert updates made to the data since the time of disguise application.

%
\sys also supports ``Temporary Recorrelation without Database Changes'' because \sys can determine
the original owner of data as long as \sys has access to decorrelation diffs (which the client or
the application provides via the appropriate capabilities).
%
\sys can use information from decorrelation diffs to disguise decorrelated data as if it were owned
by the original user; and 
%
\sys can support the API discussed in \S\ref{s:api}, which allows applications to query \sys to
check ownership properties and grant authorized users personalized views and permissions to access
data objects.

Furthermore, \sys does this while meeting all security goals: \sys supports authorized disguises and
ensures the security of ownership claims, disguise diffs, and disguise history.

Our current design falls short, however, by failing to support ``Disguising Anonymized
Users'' which we explain next.
