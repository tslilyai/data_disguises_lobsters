\section{Design}
\label{s:design}

\subsection{Abstractions}
%
\sys interacts with the application through three key abstractions:
\one{} principals, \two{} diffs and speaks-for records, and
\three{} record locators.
%

%
Principals are holders of cryptographic keys and locators, and correspond to
uniquely identifiable application users (\eg via a user ID).
%
An application represents principals as a record in a \fn{users} table or some
other datastore abstraction.
%
\sys refers to human application users as \emph{natural principals}.
%
Natural principals have data rights (\eg under the GDPR) and interact with
the application.
%
By contrast, \emph{pseudoprincipals} are anonymous users generated as part of
\sys's disguises, and inserted into the application's principal storage
to maintain application-level functionality while decorrelating data.
%
A pseudoprincipal may or may not observably differ from a natural principal
at the application level.
%

%
When they invoke \sys's disguise and reveal APIs, they cause \sys to encrypt,
store, and retrieve \emph{diff records} and \emph{speaks-for records}.
%
A diff record stores a set of database changes that the disguise made.
%
A speaks-for record stores links between pseudoprincipals produced by a
disguise and another principal.
%
\sys securely stores these records for the application by encrypting records
with per-principal public keys.
%
Only clients hold the private keys for natural principals, so once disguised,
a natural principal's data can only be revealed with their involvement.
%

%
\sys stores record ciphertexts from disguise $d$ for principal $p$ in a record
bag indexed by \emph{record locator \lcapa{pd}}.
%
Locators are opaque byte strings that clients use to tell \sys which bag to
use in a reveal operation.
%
The application only handles locators transiently and should not store them;
instead, its role is to communicate the locators to clients.
%
Locators are strictly a performance optimization, and \sys's security
properties are unaffected by their existence.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{API}
\label{s:api}

\input{api}

\sys exposes two APIs:
\begin{enumerate}[nosep]
 \item A high-level API (Figure~\ref{f:api-high}) for applications that want \sys to do
   all the work of applying data disguises, including database modifications, based on
   a declarative disguise specification and a database schema with foreign key
   relationships.
 \item A low-level API (Figure~\ref{f:api-low}) that provides application developers with
   additional control. This API allows custom organization of disguised data, lets the application
   make its own database modifications, and is schema-agnostic. This API requires applications
   to produce and interpret diff records, and tell \sys about speaks-for links between
   principals and pseudoprincipals.
\end{enumerate}
%
\sys's high-level API is internally implemented in terms of the low-level API and its
abstractions. We primarily discuss the low-level API in this paper.
%
\S\ref{s:api-high} briefly describes the high-level API.
%

%
To use either API, applications provide \sys with a description of how the application represents
principals, how to interpret unique principal IDs, and how to
generate new principal objects.
%

%
We structure our discussion of the lower-level API around an example application, WebSubmit~\cite{websubmit-rs-anon}.
%
WebSubmit is a homework submission application written in Rust, based on the Rocket
framework~\cite{rocket-rs}, and is used by students at a U.S.\ university to submit homework assignments for classes.
%
It has a simple schema that consists of tables for lectures, questions, answers,
and user accounts.
%
Clients create an account, submit homework answers, and view their submissions.
%
Course staff can view all submitted answers, as well as add and edit lectures and
questions.
%
The original WebSubmit lacks privacy transformations and retains student
details and answers forever.
%

%
We wrote two disguises for WebSubmit using the low-level API: (1) instructor-initiated anonymization
of all answers (\eg at the end of the semester), and (2) GDPR-compliant user account deletion.
%
Anonymization performs per-user disguises that decorrelate lecture answers from the user, but keeps
the answers grouped by lecture (\ie one pseudoprincipal per set of lecture answers).
%
With \sys, WebSubmit also allows users to restore their deleted accounts, and allows students to
view and edit their answers after anonymization.

\subsection{How to disguise with \sys?}

\head{(1) Register principals.}
Prior to performing any disguises, WebSubmit registers every client who creates an account by
invoking \fn{RegisterPrincipal} with the new principal's UID $p$ (the value of the \fn{id} column in
the \fn{users} table) and a public key \pubk{p} from the client that pairs with the client's private
key \privk{p}.  \sys saves public key \pubk{p}.
%WebSubmit emails \privk{p} to the client; \privk{p} will allow the client to later access $p$'s
%disguised data. Both \sys and WebSubmit forget \privk{p} so that no attacker who compromises
%WebSubmit can gain the key.

\head{(2) Start a disguise.}
WebSubmit's disguises start when either a client wants to delete their account, or the admin wants
to anonymize the class.
When this occurs, WebSubmit first \fn{StartDisguise} to signal \sys that a new disguise has begun,
and receives back the ID $d$ of the disguise.

\head{(3) Perform disguise database transformations and store records.}
WebSubmit then performs the appropriate database updates.  To delete principal $p$'s account,
WebSubmit first retrieves the account record from the \fn{users} table and all the principal's
answers from the \fn{answers} table. WebSubmit then removes the answers and the account using
\fn{DELETE} queries.  WebSubmit creates a blob of bytes consisting of the $p$'s account and $p$'s
answers, and invokes \fn{StoreDiff} with $p$, $d$, and these bytes. \sys securely stores
these bytes until WebSubmit wants to retrieve them to operate on disguised data (\S\ref{s:op-disg}).

To anonymize principal $p$'s account, WebSubmit first retrieves the account record from the \fn{users}
table and all the principal's answers from the \fn{answers} table. WebSubmit then removes the
account using a \fn{DELETE} query, and then \emph{decorrelates} the principal's answers.
To decorrelate, WebSubmit
\begin{enumerate}
%
\item invokes \fn{CreatePseudoprincipal} to get \sys to generate a \fn{users} table record for a new
    pseudoprincipal, and a new principal UID $p_{\texttt{anon}}$;
%
\item \fn{UPDATE}s the answers' foreign keys to \fn{users} to point to $q$ instead of $p$;
%
\item and invokes \fn{StoreSpeaksFor} with $p$, $p_{\texttt{anon}}$, and $d$ to tell
    \sys to securely store the speaks-for link between $p$ and $p_{\texttt{anon}}$.
\end{enumerate}

\head{(4) End the disguise.}
When the disguise is complete, WebSubmit invokes \fn{EndDisguise}. This informs \sys to complete any
record encryption operations and return (and then forget) two locators \lcapa{pd} that will allow \sys
to later locate the (encrypted) diff and speaks-for records stored during $d$'s application.
%
WebSubmit emails these locators to the client speaking for $p$, and then forgets them to ensure that
attackers cannot learn that $d$ was applied to $p$.

\subsection{How to operate on disguised data?}
\label{s:op-disg}

WebSubmit can use \sys to operate on disguised data in the following three ways: (1) users can
restore deleted accounts; (2) users can view and edit answers even after their answers have been
anonymized; and (3) users who delete their account after their answers have been anonymized can
delete their anonymized answers.

\head{(1) Restoring $p$'s deleted account.}
When a client who deleted $p$'s account wants to restore it, the client retrieves its private key
\privk{p} as well as the locators \lcapa{pd} emailed to it by WebSubmit when account deletion disguise $d$ was applied to $p$.
The client sends these to WebSubmit, which invokes \fn{DiffsForDisguise} with the \lcapa{pd} and \privk{p}, which returns the set of (plaintext) diff records from disguise $d$ for principal $p$.
WebSubmit also invokes \fn{PseudoprincipalsOf} with the \lcapa{pd} and \privk{p} to determine which
pseudoprincipals' data should be recorrelated back with $p$.

In the case of account deletion, $p$ has no pseudoprincipals (deletion applies no decorrelations).
WebSubmit thus only has to handle diff records, which are blobs containing $p$'s deleted answers and
account data.  WebSubmit then \fn{INSERT}s these records back into the database, and account
restoration is complete.
%\lyt{Should we add details about how sometimes we need multiple locators
%from multiple disguises $d' \neq d$ because of pseudoprincipals?}

\head{(2) Accessing anonymized answers.}
When a client wants to edit their anonymized answer, the client retrieves private key
\privk{p} and the locators \lcapa{pd} emailed to it by WebSubmit when anonymization disguise $d$ was
applied to $p$. The client sends these along with the request to edit a particular lectures'
answers.

When it receives the request, WebSubmit invokes \fn{PseudoprincipalsOf} with the \lcapa{pd} and
\privk{p} to determine which pseudoprincipals $p$ may speak-for.  Once WebSubmit confirms that $p$
may speak-for the principal who owns the answers to be edited, WebSubmit authorizes $p$ to edit the
answers.

\head{(3) Deleting anonymized answers.} When a client wants to delete their account, but their
answers have been anonymized, the client retrieves private key \privk{p} and the locators \lcapa{pd}
emailed to it by WebSubmit when anonymization disguise $d$ was applied to $p$. The client sends
these along with the request to delete $p$'s account.

Similar to when a client wants to edit anonymized answers, WebSubmit invokes \fn{PseudoprincipalsOf}
with the \lcapa{pd} and \privk{p} to determine which pseudoprincipals $p$ may speak-for.  WebSubmit
then deletes the answers of these pseudoprincipals.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Disguising and Revealing with the High-Level API.}
\label{s:api-high} 
If an application developer does not want to handle writing the necessary
database transformations and generation/storage of diff and speaks-for records, the developer can
provide a disguise specification in a high-level language provided by \sys. This spec includes
schema annotations and supports a restricted set of SQL database modifications. When
\fn{ApplyDisguise} is invoked with the disguise specification, \sys applies the specified
modifications and automatically generates the appropriate diff and speaks-for records.

Similarly, when \fn{RevealDisguise} is invoked, \sys can interpret the automatically-generated diff
and speaks-for records and perform the data modifications to restore the original state of data
(given that no subsequent updates had been performed since disguising).

Application handling of locators and decryption capabilities remains the same: \fn{ApplyDisguise}
takes optional locators and decryption capabilities to support disguise composition (\eg deletion
after anonymization). \fn{ApplyDisguise} returns locators for the applied disguise.
\fn{RevealDisguise} takes locators and decryption capabilities to locate and access records to
reveal.
