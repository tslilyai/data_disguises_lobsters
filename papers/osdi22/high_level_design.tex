%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-Level Disguise Specifications.} 
\sys's high-level disguising API can be used for a restricted set of disguises in applications that
use SQL databases. \sys provides a disguise specification language that supports disguising and
revealing database objects corresponding to individual database rows, and can only decorrelate data
that is linked to principals directly via foreign key relationships.

Disguises specifications consist of a set of predicated disguise operation specifications that \sys knows
how to perform.  Operations take data objects as input and execute updates to
application data. \sys automatically generates tokens when applying each operations.

In addition to the application-aware pseudoprincipal generation policy (which is required for the
low-level API as well), developers specify, using foreign keys, how \sys can determine which
principal(s) to associate with an operation's generated database. For example, a token from a
comment removal operation should be associated with the principal whose ID is referenced by the
author column, a foreign key to the principals table.

\vspace{6pt}\noindent
\sys supports three high-level disguise specification operations:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a pseudoprincipal $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.  
\end{enumerate}

\noindent For each operation, the application developer specifies:
\begin{itemize}
    \item An associated predicate to select input objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The foreign keys to the principals table that determine which principal(s) to associate
        with the operation's tokens.
\end{itemize}
%
\sys then automatically generates tokens for each operation.
Decorrelation creates an ownership token \town{pd} containing the created pseudoprincipal's
ID; removal produces a diff token \tdiff{pd} with the removed object's value; and modification
produces a diff token \tdiff{pd} containing the old and new values of the modified object.

Tokens are stored by \sys using its lower-level secure token API.

\head{Disguise Application.}
To apply a disguise specification as disguise $d$, \sys applies each operation in the spec to
all data objects satisfying the operation's predicate. 

The \fn{ApplyDisguise} API call also allows for \sys to \emph{compose} disguise operations on top of
prior ownership changes.
If provided a decryption capability and locator \lcapa{pd'} from disguise $d'$, \sys can access all ownership tokens
\town{pd'}. \sys thus knows if some link exists between $p$ and a pseudoprincipal $q$ generated by
disguise $d'$.

If one of $d$'s operations has a predicate to apply the operation to $p$'s data, \sys
composes the operation on top of $d'$ by also applying the operation to data of $q$.

\head{Disguise Revealing.} 
To reveal disguise $d$, \sys retrieves all tokens accessible with the provided decryption capability
and locator. Because \sys can understand the token bytes, \sys can restore undisguised application
data by updating the relevant object rows in the database.  However, \sys must be
careful to not accidentally reveal data that has been updated since $d$ was applied.  

All tokens produced by applying disguise specification operations allow \sys to check that the data
to restore is still in its disguised state. Prior to revealing each token, if the state of data does
not match the disguised state recorded by the token, then \sys knows the token records a stale and
overwritten update, and will refuse to restore the data to its undisguised state.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse
\vspace{6pt}\noindent\textbf{\emph{Preventing Global Diff Information Leakage.}}
%and (2) \sys cannot let global
%diffs recording updates to data $x$ leak information if $x$ is subsequently (privately) disguised.

%The ONLY REASON we need to update diffs is if they're global!!! If they're private, we can use the
%retroactive application method... (optimization to update our "own" diffs though)
%
A disguise may optionally store diffs in global storage, accessible to \sys without any client
authorization.
Such a global disguise provides no privacy guarantees against an adversary who compromises 
the application server, but does transform the application database so external users see disguised
data.

If $d_1$ is a global disguise and $d_2$ a normal, privacy-preserving disguise,
\op{d_2} may update a data object $x$ previously updated by \op{d_1}. 

\op{d_1} produces a global diff \tdiff{pd_1}; \op{d_2} produces a normal,
encrypted and secured diff \tdiff{pd_2}.

If \sys simply performs \op{d_2}'s update to $x$, an adversary can still read undisguised data
from the \tdiff{pd_1} diff because the diff is global and records a now-stale state of $x$!
%
To prevent global diffs like \tdiff{pd_1} from leaking data that should be disguised, \sys
updates the data in \tdiff{pd_1} with \op{d_2}'s update. An update to a diff such as
\tdiff{pd_1} itself generates a (private) diff \tdiff{pd_2}, just as updating a data
object generates a diff.

Revealing $d_2$ uses \tdiff{pd_2} to reveal the modification to \tdiff{pd_1}. 
If $d_1$ has already been revealed, and the database state of $x$ updated to reflect the
contents of \tdiff{pd_1} (which were updated by the application of $d_2$), then \sys
simply uses \tdiff{pd_2} to reveal the current state of $x$ in the database. 

If a future $d_3$ has further updated \tdiff{pd_1} in a way that conflicts with $d_2$'s update, then
upon reversal of $d_2$, \sys will notice that \tdiff{pd_2} records an overwritten update to
\tdiff{pd_1}, and will not revert the state of \tdiff{pd_1} until the future disguise $d_3$ has been
revealed .

\lyt{Note that removal is just an interesting case of this, in which \tdiff{pd_1} is removed, by a
diff \tdiff{pd_2} stored in \lcapa{pd_2} that saves the removal of \tdiff{pd_1} for reversal.}

%\vspace{6pt}\noindent\textbf{\emph{diff Modification for Object Identification.}}
%diffs need to refer to the correct objects even if objects have been modified by future disguises.
%Prior diffs should be revised by future disguises so that they apply correctly to the disguised
%data.
%This allows an earlier disguise to be revealed correctly.
%An easy way to avoid needing to do this is to have all objects in the DB have unique, permanent
%identifiers.
\fi
