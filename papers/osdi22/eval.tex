%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%i
\subsection{Security Evaluation}
%
\vspace{6pt}\noindent\textbf{\emph{(1) Authorized Disguises.}}
%

\vspace{6pt}\noindent\textbf{\emph{(2) Secure Disguise Tokens.}}
%
\sys secures disguise tokens by encrypting them with the public key $\pubk{p}$ of a principal $p$.
After generating the public-private keypair for a principal, \sys does not store the corresponding
private key \privk{p} (principal $p$'s decryption capability). Only a client speaking for the
principal who provides \privk{p} to \sys can decrypt and access $p$'s disguise tokens.
This ensures that an attacker who compromises the system after $p$ has been registered (and has not
compromised the client with \privk{p}) cannot access $p$'s tokens generated by prior disguises.

However, no guarantees apply after compromise: an attacker can observe and record decryption
capabilities for new principals registered after compromise (regardless of whether \sys pregenerates
keypairs, or generates them at the time of principal registration). In addition, any use of
\privk{p} to apply disguise actions after compromise allows an attacker to gain the capability to
decrypt principal $p$'s tokens.
%

\vspace{6pt}\noindent\textbf{\emph{(3) Privacy of Disguise History.}}
%
\sys hides per-principal history of applied disguises, namely which disguises affect which
principals' data, using locators. A client must provide locator \lcapa{pd} for \sys (or an
adversary) to determine that a bag of encrypted tokens came from disguise $d$ applied to
(non-pseudoprincipal) $p$. \sys does not store these per-disguise and per-principal locators, and
thus contains no information to link bags of encrypted tokens to the same principal or to the
same disguise.

After compromise, no such privacy is guaranteed: any use of \lcapa{pd} to apply disguise actions
allows an attacker to learn that a disguise $d$ applied to $p$'s data. Furthermore, 
compromise of just \privk{p} allows an attacker---without any locators \lcapa{pd}---to decrypt \emph{all} tokens and
determine which tokens correspond to $d$ and $p$.

\subsection{Performance}

We evaluate performance in \sys-WebSubmit, \sys-HotCRP, and \sys-Lobsters to answer the
following two questions.
\begin{enumerate}
\item \emph{Cost of Disguise-Related Actions}: How expensive are \sys-enabled disguise actions
(disguise application with token storage, disguise revealing, and actions taken on anonymized data)?
How much does latency and storage use increase when an application uses \sys to gain disguising and post-disguise functionality?
\item \emph{Impact on Normal Application Use}: How do \sys-enabled disguise actions impact the
    performance of concurrently executing, normal (non-disguising) application user queries?
\end{enumerate}

\head{Setup.}
All benchmarks run on a machine with 20 dual-core Intel Xeon E5-2660 v3 CPUs.

\sys-WebSubmit benchmarks run on a WebSubmit database prepopulated with 2000 total users, 20 lectures
with 4 questions each, and answers for each question for each user.
We measure end-to-end latency, including the time for clients to contact a (local)
server and the time for server application code (including \sys's operations) to perform these
actions and return a response.

\sys-HotCRP benchmarks run on a HotCRP database prepopulated with 450 total users (50 PC members), 450
papers (50 accepted), and 4 reviews and 4 comments per paper distributed evenly among PC members.  
These benchmarks measure the server-side latency to perform disguising and application operations.

\sys-Lobsters benchmarks run on a Lobsters database prepopulated with \lyt{TODO}, following the
distribution from \lyt{TODO Jon's distribution stuff} (representative of Lobster's current
scale). These benchmarks also measure the server-side latency.

\head{Latency of Disguise-Related Actions.} 
\begin{figure}[t!] 
    \centering
    \includegraphics[width=0.5\textwidth]{figs/client_op_stats} 
    \caption{Latencies of disguise-related actions when implemented manually by the 
    application developer without \sys, and with \sys.  
    Each bar shows the median latency; ranges indicate the 5th to 95th
    percentile latencies.  } 
    \label{fig:client_opstats}
\end{figure}

\begin{table*}[h!]
\begin{center}
\begin{tabular}{ c c }
\textbf{DB Op} & \textbf{Time (ms)}\\
\hline
Update DB Row & 0.1\\ 
Select DB Rows & 0.2\\
Remove DB Rows & 0.2\\
Reveal Deleted Row (DB Select + Insert) & 0.2 \\
Create + Register Principal & 0.1\\
\end{tabular}
\quad
\begin{tabular}{ c c }
\textbf{Crypto Op} & \textbf{Time (ms)}\\
\hline
Generate Keypair & 301\\
Encrypt SpeaksFor Token & 0.4\\
Decrypt SpeaksFor Token & 3.0\\
Encrypt Diff Token & 0.3\\
Decrypt Diff Token & 3.0\\
\end{tabular}
\end{center}
\caption{Amount of time required to run different operations required to apply and reveal disguises.}
\label{tab:opstats}
\end{table*}

%
Figure~\ref{fig:client_opstats} shows the median cost across user accounts of performing disguise-related actions with and
without \sys, and with token batching enabled in \sys. 
Note that \sys enables editing of anonymized data and account restoration. Thus, we have no
comparable baseline latency without \sys for editing anonymized data or account restoration. 
Token batching also has no effect in creating user accounts and editing unanonymized data (as no
tokens are involved).

\sys-WebSubmit and \sys-HotCRP support the same disguise-related operations, namely
account creation, deletion/restoration, anonymization, and editing anonymized data.
\sys-Lobsters supports account creation and deletion/restoration as well, but has account decay (and
subsequent restoration) instead of account anonymization.  It does not support editing anonymized
data (accounts can be restored in order to edit decorrelated data).

\sys-WebSubmit users all have approximately the same amount of data (a set number of answers to
lecture questions). Thus, the spread in latencies is low. The simplicity of \sys-WebSubmit's
disguises---which touch at maximum two database tables---lead to fairly low latencies even for
expensive operations such as restoring deleted accounts (250ms).

\sys-HotCRP reviewers have slightly more variable amounts of data \lyt{TODO?} depending on the
assignment of papers to reviewers. \sys-HotCRP's disguises are far more complex than
\sys-WebSubmit's, touching 12 tables, and performing a mix of deletions and
decorrelations, leading to higher median latencies in general, even for the baseline.

\sys-Lobsters users' amount of data follows a skewed distribution, with most of the 5000 users having fewer than
10 stories and comments, and a handful of users having over 300 stories and comments.
\sys-Lobster supports more complex disguises than 
\sys-WebSubmit and \sys-HotCRP, touching 15 tables, and performing a mix of deletions, 
decorrelations, and modifications. This leads to a higher latency as the amount of user data grows
comparable to that of users in \sys-HotCRP and \sys-WebSubmit.

In general, using \sys without token batching increases the latency of
disguising and revealing accounts. Latency-critical tasks such as editing (unanonymized) data or
creating an account are largely unaffected by \sys. With token batching, we observe drastic
improvements in the latencies of account disguising and revealing, and in edits of anonymized data.
%
To explain these costs, we break them down into fine-grained operations shown in
Table~\ref{tab:opstats}: every disguise action requires some DB operations and,
if using \sys, may require cryptographic operations.

\textbf{Creating an account} with or without \sys performs a database insert. Using \sys additionally
requires registering the new user as a principal, which assigns the user a (pre-generated)
private-public key pair, stores metadata about the new principal's key in \sys's storage, and
returns the corresponding private key to the application.
Using \sys thus incurs only the cost of an extra database operation, since the high cost of key
generation is taken offline.

\textbf{Editing data} with or without \sys simply performs database updates. Editing anonymized
data, however, requires \sys to decrypt (with the client-provided decryption capability) \emph{all}
speaks-for tokens at the client-provided locator until it finds a speaks-for token linking the
client to the currently-owning pseudoprincipal.  For example, if anonymization of a user account
generates 20 speaks-for token ciphertexts at the same locator, then editing anonymized data may
perform up to 20 decryptions to determine which pseudoprincipals the client can act for.  Token
batching drastically decreases this cost by performing only one decryption to decrypt all speaks-for
tokens for a particular client and disguise.

\textbf{Account deletion or data decay} with or without \sys performs the same database operations to
remove, modify, or anonymize data. \sys incurs increased costs by additionally encrypting and
inserting one diff token for each deleted or modified object, and one speaks-for token for each
anonymized object. 
With token batching, encryption occurs once per account, rather than once per object. 

\textbf{Account restoration} is only possible with \sys. \sys decrypts a token for each
piece of modified/removed/anonymized data, and performs database checks to ensure the data can be restored
(\eg that the corresponding lecture of an answer to reinsert still exists). If the checks pass
(which they do in this benchmark), \sys restores the data stored in the diffs. 
Token batching drastically decreases this cost by performing only one decryption to decrypt all 
tokens to restore.

\textbf{Anonymization} with or without \sys generates one pseudoprincipal per object to anonymize
(\eg answers for lectures in WebSubmit, or reviews in HotCRP). Anonymization selects the relevant answers
to anonymize, generates new pseudoprincipals, and performs DB queries to insert new pseudoprincipals
and to update objects to point to these new pseudopricipals (\eg updating foreign keys).
\sys incurs increased costs by additionally generating per-pseudoprincipal speaks-for tokens, and 
encrypting and storing these speaks-for tokens with the appropriate public keys.
With token batching, encryption occurs once per account, rather than once per object. 

\begin{table*}[t!]
\begin{center}
\begin{tabular}{ c | c c }
& \multicolumn{2}{c}{\textbf{Prior Applied Disguises}} \\
    \textbf{Op} & None & Anonymization \\
\hline
WebSubmit Delete & 30 & 112 \\
WebSubmit Restore & 250 & 372\\
HotCRP Delete & 114 & 1612 \\
HotCRP Restore & 629 & 1856 \\
\end{tabular}
\quad
\begin{tabular}{ c | c c }
 & \multicolumn{2}{c}{\textbf{Prior Applied Disguises}} \\
    \textbf{Op w/Batching} & None & Anonymization \\
\hline
WebSubmit Delete  & 3 & 30 \\
WebSubmit Restore  & 18 & 86\\
HotCRP Delete  & 51 & 880 \\
HotCRP Restore  & 73 & 998 
\end{tabular}
\end{center}
\caption{Account delete and restore latencies before anonymization, and composed after anonymization.}
\label{tab:composition}
\end{table*}

\textbf{Composing Deletion After Anonymization.}
Account deletion post-anonymization requires \sys to perform temporary
recorrelation find data of pseudoprincipals that the user is authorized to remove along with their
account. \sys incurs latency increases from decrypting all speaks-for tokens of the user, and from
performing the deletion or modification queries for each discovered pseudoprincipal (in addition to
the original user).

Account restoration may also restore pseudoprincipal-associated data, which requires temporary recorrelation
to access to pseudoprincipal-associated tokens produced from the account deletion.  \sys thus
additionally decrypt speaks-for tokens for all pseudoprincipals of the user, which causes the the
increase in latency.\lyt{Numbers?}

\head{Storage Costs of Disguise-Related Actions.} 
Each generated pseudoprincipal adds an additional row to the users table in WebSubmit; \sys also
stores public-key metadata for each principal (and pseudoprincipal), and (in-memory) encrypted
ciphertexts for tokens.  Clients keep track of capabilities and locators that are emailed to them in
the form of URLs that allow for account restoration or post-anonymization editing.

\head{Impact on Normal Application Execution.} Figure~\ref{fig:concurrent} illustrates the
impacts of disguising when WebSubmit has 100 users continuously editing their lecture answers, with
250-500ms pauses between edits, and in a prepopulated database containing 2000 users, 20 lectures,
and 4 answers per lecture per user.

We imagine that a realistic normal amount of disguising would have 0 or 1 user at any point deleting
or restoring their account (in addition to the 100 editing users). With one disguiser, we observe no
increase in latency over the baseline with 0 disguisers (approximately \lyt{TODO}). 

To simulate a practical worst-case scenario, we imagine that anywhere from 10 to 25 additional
active users decide to simultaneously delete their account (\eg in response to some social media
campaign). At some later point in time, these users decide to come back and (in the worst case)
simultaneously restore their accounts. We observe that while 10 or 16 users disguising themselves at once
has minimal impact on edit latency for the 100 users, 25 users doing so causes spikes up to 2500ms.  
%
These spikes come in pairs, with the larger second spike in the pair coinciding with concurrent
revealing (and the first of the pair coinciding with disguising); revealing has greater impact due
to its higher latency and compute costs.

We imagine \sys can prevent such spikes by rate-limiting and queuing disguise actions when
necessary, in particular for non-time-sensitive disguises like GDPR-compliant account deletion.

\lyt{Include some note about how overloading the CPU with concurrent edits has some effects?}

\begin{figure*}[t!]
    \centering
        \includegraphics[width=0.45\textwidth]{figs/websubmit_concurrent_results_20lec_100users}
        \includegraphics[width=0.45\textwidth]{figs/lobsters_concurrent_results}
    \caption{Impact of disguising (account deletion and revealing) on 100 users concurrently running
    normal application answer edits. Low-to-medium disguising load (<16 concurrently disguising users) has
    minimal effects on the baseline edit latency; high load (up to 25 users) causes latency spikes
    up to 2500ms.} 
    \label{fig:concurrent}
\end{figure*}
