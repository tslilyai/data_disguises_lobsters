%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
\label{s:impl}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%i

%
We implemented our \sys prototype in 4k lines of Rust.
%
The prototype relies on a MySQL database for encrypted record storage, and
its high-level API assumes that the application database is also a MySQL
database, though the low-level API works with any application DB.
%
We also provide an API server that exposes a JSON-HTTP API that applications
can use to invoke \sys.
%
In the following, we discuss key implementation details that \sys relies for
security and performance.
%

\subsection{Secure Record Storage}
\label{s:impl-locators}
%
An application hands \sys database diffs and speaks-for records when it applies
a disguise.
%
\sys appends a random nonce to the plaintext to prevent known-plaintext attacks
and encrypts the records.
%
\sys encrypts the record data with AES with 128-bit keys (CBC mode) using a
fresh symmetric key, and then encrypts this key with the principal's public key.
%

%
\sys stores encrypted records, but hides that disguise $d$ applied to
principal $p$---for example, if \sys revealed that a principal has invoked
GDPR deletion, it might violate the GDPR.
%
Consequently, \sys avoids storing any mapping from $p$ or $d$ to a bag of
encrypted records.
%
Yet, given $p$, $d$, and $p$'s private key, \sys needs to decrypt and return
records to the application on \fn{DiffsForDisguise} or \fn{PseudoprincipalsOf}.
%
While \sys could attempt to decrypt \emph{all} encrypted records with $p$'s
private key, this is too slow for applications with a large amount
of data in \sys.
%
Instead, \sys relies on the client helping the application (and, thus, \sys)
identify the bag for $(p, d)$ using a locator \lcapa{pd}.
%
Each locator points to a bag of encrypted records, and \sys maintains an index
from locators to bags, but---crucially---forgets which $(p, d)$ produced the
locator.
%
Locators are drawn randomly from a large domain, so their values give
the attacker no additional information.
%

\subsection{Pre-generated Pseudoprincipal Keypairs}
%
Generating a single private-public keypair is expensive ($\approx$300ms), but
decorrelating disguises require creating many pseudoprincipals.
%
To make pseudoprincipal creation cheap, \sys maintains a pool of
pregenerated keypairs for pseudoprincipals that it periodically refreshes.
%
The application can tell \sys an appropriate size for the pool (\eg a reasonable
upper bound on how much data a user might have).
%

%
Security against an attacker who compromises the server and observes future
disguises is unaffected, as \sys only keys from the pool when it generates
pseudoprincipals during disguises (when the keys would otherwise have been
generated, and leaked to the attacker).
%
However, an attacker who compromises the server, exfiltrates the keys, and
leaves would be able to come back and use the keys later to reveal disguised
data.
%
A fixed-size pool and periodic refreshes bound the period of vulnerability and
amount of data such an attacker can reveal.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-Level Disguise Specifications}
%
\sys's high-level disguising API works for a restricted set of common-case
disguises in applications that use SQL databases, represent objects as
database rows and express principal data ownership via foreign-key
relationships.
%

%
Disguise specifications consist of predicated disguise operations
and a pseudoprincipal-generation template.
%
For each disguise operation, \sys selects the database rows that satisfy
the predicate; runs SQL queries to modify the objects; and generates and
stores database diffs for the operation performed via \fn{StoreDiff} in
\sys's lower-level API.
%
Our prototype supports modification and removal of rows, and decorrelation
by foreign key.
%
Decorrelation generates a pseudoprincipal $q$, and rewrites the foreign
key from original principal $p$ to instead point to $q$.
%
Decorrelation creates a speaks-for record that contains the new
pseudoprincipal's ID; removal and modification produce diffs that contain
the removed object's value and, for modification, the new value.
%
The pseudoprincipal generation template specifies how to generate a row
that describes a pseudoprincipal in the application database.
%

When revealing disguise $d$, \sys retrieves all records accessible with
the provided private key and locator, and restores the undisguised state
by updating the relevant object rows in the database.
%
To prevent accidental revealing of data that the application updated
since $d$ applied, \sys first checks that the disguised data in the
application DB is unmodified.
%
If it does not match the recorded disguised state (stored in the diffs),
\sys skips the diff and leaves the modified data in place.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
\sys enables HotCRP to support the following features:
\begin{itemize}
    \item\emph{1st-Party GDPR-Compliant Disguising:}
HotCRP supports user-invoked disguise(s) to modify, decorrelate and/or delete the user's data and
account, meeting the requirements of the GDPR's right to be forgotten.

    \item \emph{1st-Party Disguised Data Restoration}: HotCRP users who invoke GDPR deletion are given the
        option to return by revealing their disguise; however, between disguising and revealing
        their account, no other entity learns the identity or existence of the user (ensuring that
        the disguise complies with the GDPR).

    \item\emph{3rd-Party Disguising.}
\sys supports disguises applied by users (such as an admin) that transform data of other users in the system. For example, universal conference anonymization or
    comment removal alters data not associated with the invoking admin.

\item \emph{Data Decay}: After several years, the admin can decay identifiers in the conference data
    by decorrelating all users from their authored reviews and papers.  This helps protect reviewers
        and paper authors from being unblinded in the case of a data breach.

\item \emph{Temporary Recorrelation with Anonymized Data}:
Even after universal decorrelation, HotCRP allows users to apply GDPR account
deletion to delete even their decorrelated papers and reviews that they wrote.
%

%
Furthermore, HotCRP users can also view reviews on their papers, or edit their reviews, even if
        these papers and reviews have been decorrelated and belong to anonymous users.  HotCRP users
        interact with a personalized, temporary database view when they visit their decorrelated
        data.

Data disguising enables temporary recorrelation to support these use cases \emph{without} changing
        the database contents and revealing to other users of the system
which actual user authored these anonymized papers and reviews.

\item \emph{Further Disguising of Anonymized Users' Data}: A disguise such as universal comment
        removal can be applied after universal decorrelation, even though it now applies to data of anonymous users.
This allows disguises to be developed over time, and to remove identifying data potentially mistakenly missed by prior
disguises, but which now belongs to anonymous users.
\end{itemize}
\fi
