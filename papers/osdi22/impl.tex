%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%i

%
We implemented our \sys prototype in \note{XXX} lines of Rust.
%

\paragraph{Batching pseudoprincipal creation.}
%
Fixed-size pool that uses some application-info to avoid wasting compute/space

Representation of records? Persistence of stuff

\ms{dumped here}

\sys enables HotCRP to support the following features:
\begin{itemize}
    \item\emph{1st-Party GDPR-Compliant Disguising:}
HotCRP supports user-invoked disguise(s) to modify, decorrelate and/or delete the user's data and
account, meeting the requirements of the GDPR's right to be forgotten.

    \item \emph{1st-Party Disguised Data Restoration}: HotCRP users who invoke GDPR deletion are given the
        option to return by revealing their disguise; however, between disguising and revealing
        their account, no other entity learns the identity or existence of the user (ensuring that
        the disguise complies with the GDPR).

    \item\emph{3rd-Party Disguising.}
\sys supports disguises applied by users (such as an admin) that transform data of other users in the system. For example, universal conference anonymization or
    comment removal alters data not associated with the invoking admin.

\item \emph{Data Decay}: After several years, the admin can decay identifiers in the conference data
    by decorrelating all users from their authored reviews and papers.  This helps protect reviewers
        and paper authors from being unblinded in the case of a data breach.

\item \emph{Temporary Recorrelation with Anonymized Data}:
Even after universal decorrelation, HotCRP allows users to apply GDPR account
deletion to delete even their decorrelated papers and reviews that they wrote.
%

%
Furthermore, HotCRP users can also view reviews on their papers, or edit their reviews, even if
        these papers and reviews have been decorrelated and belong to anonymous users.  HotCRP users
        interact with a personalized, temporary database view when they visit their decorrelated
        data.

Data disguising enables temporary recorrelation to support these use cases \emph{without} changing
        the database contents and revealing to other users of the system
which actual user authored these anonymized papers and reviews.

\item \emph{Further Disguising of Anonymized Users' Data}: A disguise such as universal comment
        removal can be applied after universal decorrelation, even though it now applies to data of anonymous users.
This allows disguises to be developed over time, and to remove identifying data potentially mistakenly missed by prior
disguises, but which now belongs to anonymous users.
\end{itemize}

\ms{end dump}

\subsection{Secure Disguise Records Design}
Applications save disguise metadata in the form of records: speaks-for records \town{pd} save information linking
principals to anonymous pseudoprincipals, and diff records \tdiff{pd} save information about modifications
performed during the disguise.
We discuss here how the \sys securely stores records produced by applications upon disguising, and
how \sys allows applications to efficiently and securely retrieve these records.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Record Wrappers.}
In order to generically handle record data, \sys stores all records in record wrappers.
Wrappers store the bytes of the record \tdiff{pd} or \town{pd} (provided
by the application), a correlated principal ID $p$, and the disguise ID $d$ of the disguise producing the
record. In addition, \sys includes a random nonce in the record wrapper to prevent known plaintext
attacks.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Record Access.}
When a new principal $p$ is created, \sys produces a private-public keypair, and returns \privk{p} to
the application (which then sends it to the appropriate client). \sys stores \pubk{p} associated
with principal ID $p$.
If a principal $p$ is removed from the application during a disguise, \sys deletes any corresponding metadata, namely
the record of \pubk{p}.

\sys secures a principal $p$'s records by storing them in a record wrapper, and encrypting the wrapper
with \pubk{p}. Only a client holding the private key \privk{p}---the decryption
capability---can access these records.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Disguise History.}
\sys should not leak information that $d$ disguised principal $p$ if $p$ interacts with the system
to reveal or otherwise access disguised data. In particular, \sys should avoid an adversary learning
that encrypted records exist for a particular $p$ and $d$, since this allows the adversary to deduce
that $d$ disguised $p$. For example, \sys should not reveal that a principal $p$ has invoked GDPR
deletion.

A strawman solution could store all encrypted records in one large bag, so those from
$d$ for $p$ are indistinguishable from those from $d'$ for $p'$. When \sys then gets a request for
records from disguise $d$ and for principal $p$, \sys attempts to decrypt (using a provided
decryption capability \privk{p}) all records in order to find the relevant ones.

To make this process more efficient, \sys uses \emph{locators \lcapa{pd}}. For each $p$ and $d$,
\sys stores encrypted records \tdiff{pd} and \town{pd} in a randomly located bag pointed to by
locator \lcapa{pd}. \sys returns all locators produced by a disguise to the application; to ensure
that locators don't leak information that disguise $d$ applied to $p$, \sys then forgets all locator
information, and the application should ensure that locators are stored external to the application
server (\eg by emailing them to the corresponding users).

Note that with this design, an adversary without access to \lcapa{pd} can learn that $n$ diffs exist
for \emph{some} $p$ and $d$, but cannot identify \emph{which} $p$ or $d$.
%
Furthermore, an adversary with access to decryption capability \privk{p} would not need locators to
discover $p$'s disguise history: they can decrypt every record in every bag to see which bags they
can successful decrypt. Using locators just makes such an attack less efficient.
%
These scenarios are outside our threat model.

\lyt{
An alternative design might remove encrypted records completely (and \eg store them in external per-user
vaults or email them to the client).
This leaves no trace in \sys or the application, and would prevent the adversary from learning
anything. However, this places a large burden on the client.
Maybe put this in future work?
}

To summarize, when \sys saves a disguise record $\mathcal{T}_{pd}$ from disguise $d$ associated with principal $p$, \sys:
\begin{enumerate}
    \item creates a record wrapper $W$ for the record $\mathcal{T}_{pd}$
    \item encrypts $W$ with \pubk{p} to produce $\enc(\pubk{p}, W)$
    \item stores $\enc(\pubk{p}, W)$ at location \lcapa{pd}
    \item returns \lcapa{pd} to the application, where it is sent to the appropriate user and then
        forgotten by the server
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pseudoprincipal Records Design}

To apply one disguise on top of another in a way that supports, \eg comment removal after universal
decorrelation, \sys should support disguises that modify data belonging to pseudoprincipals, and which
produce records for pseudoprincipals.
%
For example, after universal decorrelation, pseudoprincipals own every paper or review. If the
application then performs a disguise to remove papers, the corresponding diff record would be
associated with pseudoprincipals.

To secure these records, \sys needs to encrypt them in some way. The simplest way would be to use
\pubk{p}, where $p$ is the real principal linked to the pseudoprincipal being disguised.
However, \sys does not know which real user corresponds to which pseudoprincipals (for
unlinkability, the application server/\sys cannot store pseudoprincipal-user correspondences). 

Instead, \sys associates each pseudoprincipal $q$ with a keypair \pubk{q} and \privk{q}, and treats
pseudoprincipals the same as any other principal in the system. \sys encrypts pseudoprincipal records
with \pubk{q}, and requires decryption capability \privk{q} to access these records. \sys must
securely store pseudoprincipal decryption capabilities \privk{q} such that only authorized
users---those who can speak for the original principal linked to pseudoprincipals---can
access them.

\head{Protecting Pseudoprincipal Decryption Capabilities.}
To secure access to pseudoprincipal private keys, \sys leverages the fact that 
when a disguise generates pseudoprincipals, the link between pseudoprincipal and original principal
is known. 

When disguise $d$ decorrelates data from $p$ and asks \sys to generate a pseudoprincipal $q$, \sys does the following: 
\begin{enumerate}
    \item \sys generates keypair (\pubk{q}, \privk{q}) for $q$
    \item encrypts the private key of $q$ with \pubk{p} to produce $\enc(\pubk{p}, \privk{q})$
    \item stores $\enc(\pubk{p}, \privk{q})$ at location \lcapa{pd} along with $p$'s encrypted diffs from disguise $d$
\end{enumerate}

Note that the application cannot simply send \privk{q} via \eg email to the corresponding
real user: the original principal whose data is being decorrelated may in fact be a pseudoprincipal
itself, and therefore unassociated with any real email!

This method ensures that only a client with \lcapa{pd} and \privk{p} can access \privk{q}, the data
capability of pseudoprincipal $q$. 
%Furthermore, only a client who holds \lcapa{pd} can learn
%that $p$ has decorrelated data because associated pseudoprincipal private keys are not stored
%publically with $p$'s ID.

\head{Securing Pseudoprincipal Record Access.}
When \sys saves a disguise record $\mathcal{T}_{pd}$ from disguise $d$ associated with pseudoprincipal $q$, \sys:
\begin{enumerate}
    \item creates a record wrapper $W$ for the record $\mathcal{T}_{qd}$
    \item encrypts $W$ with \pubk{q} to produce $\enc(\pubk{q}, W)$
    \item stores $\enc(\pubk{q}, W)$ at location \lcapa{qd}
    \item encrypts \lcapa{qd} with \pubk{q} to produce $\enc(\pubk{q}, \lcapa{qd})$
    \item stores \enc(\pubk{q}, \lcapa{qd}) associated with principal $q$'s ID
\end{enumerate}
Note that the process for pseudoprincipal records is the same as that for real principal records up to
step (4): \sys stores encrypted \lcapa{qd} associated with $q$'s ID, whereas \sys returns all locators to
the application when producing real principal records (and then forgets these locators).
This is because the application and \sys may not know which original principal can speak for $q$,
and therefore cannot \eg email \lcapa{qd} to the appropriate user.

Storing \lcapa{qd} ciphertexts on the server allows an adversary can learn that \emph{some} disguise has
applied to $q$. However, this falls out of scope in our threat model: $q$ is a pseudoprincipal
created by a disguise, and therefore any disguise metadata regarding $q$ has already been
dissociated from the original principal $p$'s identity.

With this extended design, a client speaking for $p$ that provides decryption capability \privk{p}
and locator \lcapa{dp} authorizes access to \emph{both} $p$'s records for disguise $d$ \emph{and} all
records of all pseudoprincipals $q$ created during disguise $d$ linked to $p$.

Given a data capability \privk{p}, \sys can can access \privk{q} by decrypting \enc(\pubk{p},
\privk{q}).
%
With \privk{q}, \sys can decrypt all \enc(\pubk{q}, \lcapa{qd}) to locate all $q$'s encrypted
records, and then decrypt these records with \privk{q}. 

Thus, \sys can recursively disguise pseudoprincipals of some original principal $p$ such that only a
user who can speak for $p$ can access these pseudoprincipals' associated records.
Importantly, these users can do so using only $p$'s decryption capability and locators.
Furthermore, this design still meets our security goals: decryption capabilities secure all disguise
records, and an adversary learns no disguise metadata about real users.

\lyt{Note somewhere that pseudoprincipals and recursive disguising are why we need asymmetric crypto; otherwise, we
could just send the symmetric key to the original user being disguised?}

\head{Retaining Pseudoprincipal Metadata.}
Recall that \sys removes any metadata about a principal when the principal is removed by the
application during a disguise.
However, \sys cannot simply remove pseudoprincipal metadata because this metadata includes \lcapa{qd}
ciphertexts. Removing \lcapa{qd} removes the ability to find any of the encrypted record bags
located at \lcapa{qd}. Thus, if \sys wanted to access $q$'s records for \eg disguise reversal, \sys
would need to attempt to decrypt every encrypted record bag at every location.

A pseudoprincipal is often deleted while \sys has knowledge of the link between $q$ and
original principal $p$ (\eg, when a client deletes $p$'s account and provides speaks-for records
to \sys to delete $p$'s anoymized data). In these scenarios, \sys can encrypt the
\lcapa{qd} ciphertexts with \pubk{p} and store the ciphertexts at some locator that is then emailed
to the real user speaking for $p$.

However, without knowledge of this link, \sys only has two choices when $q$ is removed by the
application: delete $q$'s metadata at the cost of losing (efficient) access to $q$'s records, or
retain $q$'s metadata at the cost slightly weaker security (an adversary learns that a
pseudoprincipal existed and some data had been decorrelated at some point, even if the corresponding
user or data has since been deleted).

For simplicity, \sys's current design retains pseudoprincipal metadata in all scenarios.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-Level Disguise Specifications.} 
\sys's high-level disguising API can be used for a restricted set of disguises in applications that
use SQL databases. \sys provides a disguise specification language that supports disguising and
revealing database objects corresponding to individual database rows, and can only decorrelate data
that is linked to principals directly via foreign key relationships.

Disguises specifications consist of a set of predicated disguise operation specifications that \sys knows
how to perform.  Operations take data objects as input and execute updates to
application data. \sys automatically generates records when applying each operations.

In addition to the application-aware pseudoprincipal generation policy (which is required for the
low-level API as well), developers specify, using foreign keys, how \sys can determine which
principal(s) to associate with an operation's generated database. For example, a record from a
comment removal operation should be associated with the principal whose ID is referenced by the
author column, a foreign key to the principals table.

\vspace{6pt}\noindent
\sys supports three high-level disguise specification operations:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a pseudoprincipal $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.  
\end{enumerate}

\noindent For each operation, the application developer specifies:
\begin{itemize}
    \item An associated predicate to select input objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The foreign keys to the principals table that determine which principal(s) to associate
        with the operation's records.
\end{itemize}
%
\sys then automatically generates records for each operation.
Decorrelation creates a speaks-for record \town{pd} containing the created pseudoprincipal's
ID; removal produces a diff record \tdiff{pd} with the removed object's value; and modification
produces a diff record \tdiff{pd} containing the old and new values of the modified object.

Records are stored by \sys using its lower-level secure record API.

\head{Disguise Application.}
To apply a disguise specification as disguise $d$, \sys applies each operation in the spec to
all data objects satisfying the operation's predicate. 

The \fn{ApplyDisguise} API call also allows for \sys to \emph{compose} disguise operations on top of
prior ownership changes.
If provided a decryption capability and locator \lcapa{pd'} from disguise $d'$, \sys can access all
speaks-for records
\town{pd'}. \sys thus knows if some link exists between $p$ and a pseudoprincipal $q$ generated by
disguise $d'$.

If one of $d$'s operations has a predicate to apply the operation to $p$'s data, \sys
composes the operation on top of $d'$ by also applying the operation to data of $q$.

\head{Disguise Revealing.} 
To reveal disguise $d$, \sys retrieves all records accessible with the provided decryption capability
and locator. Because \sys can understand the record bytes, \sys can restore undisguised application
data by updating the relevant object rows in the database.  However, \sys must be
careful to not accidentally reveal data that has been updated since $d$ was applied.  

All records produced by applying disguise specification operations allow \sys to check that the data
to restore is still in its disguised state. Prior to revealing each record, if the state of data does
not match the disguised state recorded by the record, then \sys knows the record records a stale and
overwritten update, and will refuse to restore the data to its undisguised state.
