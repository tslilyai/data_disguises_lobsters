%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%i

%
We implemented our \sys prototype in \note{XXX} lines of Rust.
%
We also provide an API server that exposes a JSON-HTTP API that applications
can use to invoke \sys.
%
In the following, we discuss key implementation details that \sys relies for
security and performance.
%

\subsection{Secure Record Storage}
%
An application hands \sys database diffs and speaks-for records when it applies
a disguise $d$.
%
Prior to encrypting these records, \sys appends a random nonce to the plaintext
to prevent known-plaintext attacks.
%
Encryption ensures that only a client with $p$'s private key can reveal these
records.
%

%
\sys must store encrypted records without leaking that disguise $d$ applied to
principal $p$.
%
For example, if \sys revealed that a principal has invoked GDPR deletion, it
might violate the GDPR.
%
Consequently, \sys must avoid storing any mapping from $p$ or $d$ to a bag of
encrypted records, as must the application.
%
However, \sys must also be able to---given $p$, $d$, and $p$'s private
key---decrypt and return records to the application when it invokes
\fn{DiffsForDisguise} or \fn{PseudoprincipalsOf}.
%
While \sys could attempt to decrypt \emph{all} encrypted records with $p$'s
private key, this is clearly too slow for applications with a large amount
of data in \sys.
%
But the client can help the application (and, thus, \sys) identify the bag
of encrypted records for $(p, d)$.
%
This is the role of \sys's locators: each \lcapa{pd} points to a bag of
encrypted records, and \sys maintains an index from locators to bags,
but---crucially---forgets which $(p, d)$ produced the locator.
%
Locators are drawn randomly from a large domain, so their values give
the attacker no additional information.
%

\subsection{Pre-generated Pseudoprincipal Keypairs}
%
Generating a single private-public keypair is expensive ($\approx$300ms), but
decorrelating disguises require creating many pseudoprincipals.
%
To make pseudoprincipal creation cheap, \sys maintains a pool of
pregenerated keypairs for pseudoprincipals that it periodically refreshes.
%
The application can tell \sys an appropriate size for the pool (\eg a reasonable
upper bound on how much data a user might have).
%
\ms{Need to discuss security implications. No guarantees from point of
compromise; bounded period of vulnerability to attacker who gets keys and
uses them later.}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-Level Disguise Specifications.}
\sys's high-level disguising API can be used for a restricted set of disguises in applications that
use SQL databases, represent objects as database rows and express principal data ownership via
foreign-key relationships.

Disguises specifications consist of predicated disguise operation specifications and a
pseudoprincipal-generation specification.
\sys performs each operation by selecting database objects that satisfy the predicate; performing SQL queries to modify the objects; and automatically generating and storing records corresponding to the operation performed using \sys's lower-level API.  \sys supports three high-level disguise specification
operations:
\begin{enumerate}[nosep]
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a pseudoprincipal $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
\end{enumerate}
Decorrelation creates a speaks-for record \town{pd} containing the created pseudoprincipal's
ID; removal produces a diff record \tdiff{pd} with the removed object's value; and modification
produces a diff record \tdiff{pd} containing the old and new values of the modified object.

Pseudoprincipal generation specifications consist of a list of per-column policies that each
include the column name, and the selected policy on how to generate values for that column.
\sys supports policies to set values as constants, or to generate random and/or unique strings, emails, past timestamps, phone
numbers, and numbers (in a range).

When revealing disguise $d$, \sys retrieves all records accessible with the provided decryption capability
and locator, and restores the undisguised state by updating the relevant object rows in the database.
To prevent accidental revealing of data that has been updated since $d$ was applied,
\sys will first check that the data to restore is still in its disguised state. If the state of data does
not match the recorded disguised state, then \sys knows the record corresponds to a stale and
overwritten update, and will refuse to restore the undisguised state.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
\sys enables HotCRP to support the following features:
\begin{itemize}
    \item\emph{1st-Party GDPR-Compliant Disguising:}
HotCRP supports user-invoked disguise(s) to modify, decorrelate and/or delete the user's data and
account, meeting the requirements of the GDPR's right to be forgotten.

    \item \emph{1st-Party Disguised Data Restoration}: HotCRP users who invoke GDPR deletion are given the
        option to return by revealing their disguise; however, between disguising and revealing
        their account, no other entity learns the identity or existence of the user (ensuring that
        the disguise complies with the GDPR).

    \item\emph{3rd-Party Disguising.}
\sys supports disguises applied by users (such as an admin) that transform data of other users in the system. For example, universal conference anonymization or
    comment removal alters data not associated with the invoking admin.

\item \emph{Data Decay}: After several years, the admin can decay identifiers in the conference data
    by decorrelating all users from their authored reviews and papers.  This helps protect reviewers
        and paper authors from being unblinded in the case of a data breach.

\item \emph{Temporary Recorrelation with Anonymized Data}:
Even after universal decorrelation, HotCRP allows users to apply GDPR account
deletion to delete even their decorrelated papers and reviews that they wrote.
%

%
Furthermore, HotCRP users can also view reviews on their papers, or edit their reviews, even if
        these papers and reviews have been decorrelated and belong to anonymous users.  HotCRP users
        interact with a personalized, temporary database view when they visit their decorrelated
        data.

Data disguising enables temporary recorrelation to support these use cases \emph{without} changing
        the database contents and revealing to other users of the system
which actual user authored these anonymized papers and reviews.

\item \emph{Further Disguising of Anonymized Users' Data}: A disguise such as universal comment
        removal can be applied after universal decorrelation, even though it now applies to data of anonymous users.
This allows disguises to be developed over time, and to remove identifying data potentially mistakenly missed by prior
disguises, but which now belongs to anonymous users.
\end{itemize}
\fi
