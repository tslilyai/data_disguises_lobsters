%-------------------------------------------------------------------------------
\section{Setting and Goals}
%-------------------------------------------------------------------------------
Our design considers typical database-backed applications that link a library provided by our disguising
tool (\sys).
%
This library provides an API that the application uses to specify disguises, apply them, and (in some
cases), reveal disguised data with proper authorization (Table~\ref{tab:client_api}).
%
\sys takes care of executing the database transformations required as part of a disguise, and stores
disguised data in a secure way, subject to the threat model we describe in \S\ref{s:threat}.

\subsection{Use Cases \sys Should Support}

\head{Example: HotCRP.}
We imagine three useful disguises to support in HotCRP: 
\begin{enumerate}
    \item Per-user GDPR account deletion, which
removes all of a particular user's data.
        \item Universal account pseudonymization, which modifies a user's
account to remove any personal identifiers.
        \item Universal decorrelation, which decorrelates users from
their authored reviews and papers.
\end{enumerate}

Users who invoke GDPR deletion are given the option to return by revealing their disguise; however,
between disguising and revealing their account, no other entity learns the identity or
existence of the user (ensuring that the disguise complies with the GDPR).

Admins can apply universal account pseudonymization to provide a weak form of pseudonymization after a
conference ends, erasing \eg identifying email accounts, usernames, and phone numbers. 
After several years, the admin can decay identifiers in the conference data futher by decorrelating
all users from their authored reviews and papers. Both disguises help protect reviewers and paper authors
from being unblinded in the case of a data breach.

Even after universal account pseudonymization or decorrelation, it would be nice if HotCRP allowed
users to still apply GDPR account deletion to delete (even decorrelated) papers and reviews that they
wrote: a disguise that applies to a user's data may, in some circumstances, apply to even decorrelated data.

Furthermore, account pseudonymization should not prevent the application of a universal
decorrelation disguise: disguises should be able to operate on top of already-disguised data, and if
revealed, return the data to the previously disguised state. 
%, and be
%similarly revealable as if they applied to undisguised data.

Finally, HotCRP would retain much of its usefulness if users could be permitted to view
reviews on their papers, or edit their reviews, even if these papers and reviews have been
decorrelated and belong to anonymous users.
However, this should be possible \emph{without} revealing to other users of the system which
actual user authored these anonymized papers and reviews.

\head{Usability.} These disguising properties should be achieved with minimal burden on
users: users should be able to apply and reveal disguises, or ask for permission to view
disguised data, by \eg logging in and clicking one url link. Application of universal disguises
should not require a user to be online in order to gain the capability to apply further disguises or
view their disguised data.

\head{General Use Cases.} 
From the HotCRP example, we generalize a handful of the most beneficial and practical use cases
that \sys should support:

\begin{itemize}
    \item\textbf{Per-User, GDPR-Compliant Disguising and Revealing.}
\sys should support user-invoked disguise(s) to modify, decorrelate and/or delete a user's data and
account that enable applications to meet the requirements of the GDPR's right to be forgotten.
%
These disguises can optionally be revealable, enabling users to \eg permanently restore their accounts and/or data ownership.

\item\textbf{Universal Disguising and Revealing.}
\sys should support universal, administrator-applied disguise to modify, decorrelate, and/or delete
        data of all users in the system.
%
%Universally-applied disguises can optionally be revealed by an administrator.
%\lyt{(universal revealing only makes sense for non-private disguises)}

\item\textbf{Per-User Revealed Views and Permissions.}
Users should be able to operate with ownership permissions on data previously correlated with their
account, but decorrelated by a disguise, \emph{without} changing the database views of others using
the application. In other words, the disguise can be temporarily revealed for a particular user.
        \lyt{Discuss reveal terminology}

\item\textbf{Disguising of Decorrelated Data.}
A disguise affecting a user's data can, if authorized, operate on data decorrelated from the user by
prior disguises.

\item\textbf{Support for Sequences of Disguises.}
Data can be disguised to different granularities (\eg anonymized vs. removed), and being disguised
once should not prevent data from being later disguised.
        \lyt{I know there is overlap here with disguising decorrelated data, but disguising
        disguised data (\eg pseudoprincipal data) requires a different mechanism, which is why I
        separated it out here.}
\end{itemize}

\subsection{\sys Abstractions}
\sys supports these use cases by exposing three abstractions to applications:
\begin{itemize}
    \item Application \emph{principals}, which correspond to users of the application, 
	and which are uniquely identifiable (\eg via a user ID).
        %natural persons using the application, and
        %
	We denote an application principal as $p \in P$, where $P$ is the set of all application principals.
	%
    \item Application \emph{pseudoprincipals}, which correspond to anonymous users not tied to any natural
    person, and which are uniquely identifiable (\eg via a user ID).
        %
	Pseudoprincipals are part of the set of application principals $p \in P$.
        \lyt{I don't see why they should be a different set?}
	%
    \item A disguise specification that consists of one or more disguises, $d \in D$, which each specify
	how \sys transforms the application database when $d$ is invoked by a principal $p$.
	%
	Each invocation of $d$ results in a unique \emph{disguise instance} $\delta_i$, identified by
        a global disguise sequence number $i$.
        \lyt{We can imagine the sequence number being split by disguise specification, but it
        doesn't seem important here? All it needs to be is uniquely identifiable.}
	%
\end{itemize}
%
%
\sys operates on two categories of data:
\begin{enumerate}
    \item \emph{\textbf{Database Contents}}: The application reads and writes database
        contents, which include visible, undisguised and currently-disguised data.
        \sys modifies the data database contents when it applies and reveals disguises.
    \item \emph{\textbf{Disguise Diffs}}: \sys records the set of disguise diffs---which contain the
        original database contents and the modifications performed to them---and uses diffs to
        compose disguises on top of one another, or to reveal the updates done by a disguise. 
\end{enumerate}

\head{Data Access Control.}
The application's normal permissions logic controls data access to database contents.  Only \sys
ever accesses and needs to parse diff contents directly: \sys exposes an API (\S\ref{s:api})
allowing the client or application to learn specific semantic information contained in diffs (\eg
whether a particular principal used to own a now-decorrelated piece of data) if
provided appropriate authorization. Clients can
additionally request that \sys access and use diff information to reveal or apply disguises.

\sys's access to diffs is controlled by a pair of capabilities: \lyt{(The application never directly
accesses diffs, which is why I say \sys's access)}
\begin{enumerate}
    \item \emph{\textbf{Data Capability \dcapa{p\delta_i}}}: Grants read access to disguise diff data
        associated with principal $p$ produced from applying $\delta_i$.
    \item \emph{\textbf{Locating Capability \lcapa{p\delta_i}}}: Allows locating the disguise
        diffs associated with principal $p$ produced from applying $\delta_i$, but grants no 
        access to the diffs' data.
\end{enumerate}

\noindent Possession of the pair of data and locating capabilities \pcapa{p\delta_i} is required in
practice to grant read access to disguise diff data.
Each capability in the pair alone is insufficient: an attacker who can spoof
\lcapa{p\delta_i} will not be able to access disguise diffs without
\dcapa{p\delta_i}, although they can learn that $\delta_i$ disguised some of $p$'s data;
and an attacker holding \dcapa{p\delta_i} cannot locate the disguise diffs to access without
\lcapa{p\delta_i}.

%-------------------------------------------------------------------------------
\subsection{Threat Model}
\label{s:threat}
%-------------------------------------------------------------------------------

%
Data disguises protect user information in a web application against external observation
and service compromise.
%
An external observer is a user of the web application (authenticated or unauthenticated) who
observes information exposed through using the application.
%
A service compromise occurs when an attacker compromises the web application and 
gains full access to the server.
%
The attacker therefore can access any data stored, perform any actions the application can
perform, and access any information available to \sys.
%

%
A data disguise guarantees that the disguised data is hidden from any future attackers unless
explicitly revealed by an authorized principal.
%
In particular, an attacker who compromises \sys at time $t$ learns \emph{nothing but}:
\begin{enumerate}[nosep]
  \item the (plaintext) contents of the application database at or after time $t$;
  \item the disguises invoked, and the identity of the principals invoking them, after time $t$; and
  \item the results of revealing, after time $t$, disguises applied prior to $t$.
\end{enumerate}
%
We make standard assumptions about the security of cryptographic primitives: attackers cannot
break encryption and keys stored with non-colluding clients are safe.
%

%
\sys operates in an honest-but-curious setting: even if compromised, \sys faithfully executes
its protocols, but exposes all data accessed to the attacker.
%

\subsection{Security Goals}
%
With this threat model, \sys seeks to meet four security goals:
%

%
\vspace{6pt}\noindent\textbf{\emph{(1) Authorized Disguises.}}
%
Only a client properly authenticated as a principal $p$ who is authorized to invoke $d$ can apply (and
later reveal) the corresponding disguise instance $\delta_i$.
%

%
\vspace{6pt}\noindent\textbf{\emph{(2) Secure Ownership.}}
%
Only a client who has both locating capability \lcapa{p\delta_i} and data capability
\dcapa{p\delta_i} can reestablish ownership by $p$ of data previously owned by $p$ but decorrelated by $\delta_i$.
Establishing ownership allows the application to grant permissions to $p$ to act upon data otherwise
decorrelated from $p$.
%

\vspace{6pt}\noindent\textbf{\emph{(3) Secure Disguise Diffs.}}
%
Only a client who has both locating capability \lcapa{p\delta_i} and data capability
\dcapa{p\delta_i} can grant \sys access to the disguise diffs from disguise instance $\delta_i$.
%
\lyt{I put this as a separate goal because diffs are used to check ownership, but also potentially
contain more information?}

\vspace{6pt}\noindent\textbf{\emph{(4) Privacy of Disguise History.}}
%
An attacker cannot learn the set of disguises that have disguised a principal's data.
%
An attacker only learns a disguise instance $\delta_i$ exists if an authenticated principal $p$ provides
locating capability \lcapa{p\delta_i} to \sys.

\vspace{6pt}\noindent\textbf{\emph{Non-Goals.}}
%
Under \sys's threat model, the following properties are out of scope:
%
\begin{itemize}
    \item Security of disguised data when an attacker has prior snapshots the system.
    %\item Authorized disguises if an attacker authenticates as a principal $p$. \ms{this seems trivial}
    %\item Security of disguise changes and disguise history applied to $p$ if $p$'s private key, \privk{p}, is compromised.
    %\item Security of disguise changes and disguise history of $\delta_i$ applied to $p$ if an
        %authorized client provides \lcapa{p\delta_i} and \dcapa{p\delta_i}. \ms{as above}
    \item Security of metadata such as the number of disguises applied to, or number of
	disguise change records associated with, a particular principal $p$.
    \item Privacy guarantees about undisguised data: if identifying data about $p$ is not covered by
        disguise specification $d$, it remains visible to attackers after corresponding instance $\delta_i$ applies.
        For example, a disguise that leaves contents of posts unmodified does not hide identifying references
	to users in that content.
    \item Hiding whether data is disguised or not. For example, if a post's author is anonymized as ``anonFox'',
        \sys leaks the fact that a post's author has been disguised.
\end{itemize}

