%-------------------------------------------------------------------------------
\section{\sys API.}
%-------------------------------------------------------------------------------
\begin{table*}[t!]
\centering
    \begin{tabular}{ p{.5\linewidth} p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($p$, Email email, PubKey $\pubk{p}$)} $\rightarrow$ () & Registers $p$ as
        a principal in \sys.\\
    \vspace{6pt}\\
    \fn{ApplyDisguise($p$, DisguiseSpec $d$,
        Vec<CapPair> caps)} $\rightarrow$\fn{(DisguiseInstance, Vec<LocCap>)} & Applies
        disguise $d$ and returns the corresponding disguise instance $\delta_i$ and locating
        capability \lcapa{p\delta_i}. The provided capability pairs allow \sys to locate and access
        disguise diffs, which \sys uses to compose disguise $d$ on top of
    prior disguises.
        \vspace{6pt}\\
    \fn{RevealDisguise($p$, DisguiseInstance $\delta_i$,
        Vec<CapPair> caps)} $\rightarrow$ ()& 
    Reveals disguise instance $\delta_i$. The provided capability pairs grant \sys access to database
    diffs from applying $\delta_i$, which allows \sys to reveal undisguised data.
        \vspace{6pt}\\
    \fn{GetEncryptedDataCap($p$, DisguiseInstance $\delta_i$,
        LocCap \lcapa{p\delta_i})} $\rightarrow$ \fn{EncryptedDataCap} & Returns the data capability \dcapa{p\delta_i} encrypted with
        \pubk{p}. \lcapa{p\delta_i} is required to retrieve the correct encrypted data capability.
\end{tabular}
\caption{Client-\sys API}
\label{tab:client_api}
\end{table*}

\begin{table*}[t!]
\centering
    \begin{tabular}{ p{.5\linewidth} p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
\fn{ActWithCapPairs($p$, Action $a$, Vec<CapPair> caps)} $\rightarrow$ bool & Requests
        a particular application action $a$ specific to the application's API (\eg read access to paper reviews) with the provided
        capabilities.
\end{tabular}
\caption{Client-Application API}
\label{tab:app_api}
\end{table*}


\begin{table*}[t!]
\centering
\begin{tabular}{ p{.5\linewidth} p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{CapPairEstablishesLink($p$, DatabaseObj $x$, CapPair \pcapa{p\delta_i})}
    $\rightarrow$ \fn{bool} & Returns
    whether principal $p$ is correlated with the provided database object. The capability pair
    acts as proof that there exists a link between $p$ and prior decorrelated objects. 
    %\lyt{This would be a row, or the table + object primary key depending on what
    %we want to assume.}
    \vspace{6pt}\\
    \fn{CapPairToDiffs}(\fn{CapPair \pcapa{p\delta_i}}) $\rightarrow$ \fn{Vec<Diff>} & Returns the
   disguise diffs accessible given the provided capability pair.
\end{tabular}
\caption{Server-Side API}
\label{tab:internal_api}
\end{table*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

At a high level, \sys's API is broken up into a client-side API (\ie calls made in Javascript from a
client browser), and a server-side API (\ie calls made by the application to \sys, or by \sys 
itself).

The client-side API in Table~\ref{tab:client_api} allows the client to retrieve register a principal, retrieve relevant
capabilities, and apply and reveal disguises. The server-side API in Table~\ref{tab:internal_api} allows the application/\sys to gain access to data using capabilities.
Applications integrating with \sys may also expose an extra API call to the client shown in
Table~\ref{tab:app_api} that allows the application to receive the capability along with the normal
API call.

We next describe example usages of the API.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Client-\sys: Retrieving Capabilities.}
%
Clients invoke API calls with capability \emph{pairs}. 
However, clients only ever receive and store locating capabilities \lcapa{p\delta_i} returned from
the application of $\delta_i$.
%
Thus, \sys provides a way for a client who has \lcapa{p\delta_i} to acquire the full capability pair
by retrieving an encrypted \dcapa{p\delta_i} via \fn{GetEncryptedDataCap} before invoking API calls.

\sys stores \dcapa{p\delta_i} encrypted with \pubk{p}, so only a client who has both
\lcapa{p\delta_i} and \privk{p} can decrypt the respond with \privk{p} to get the necessary
\pcapa{p\delta_i} capability pair. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Client-\sys: Disguising and Revealing.}
A client speaking for (registered) principal $p$ applies a disguise by providing the chosen disguise
spec, and a set of locating and data capability pairs. These capability pairs allow \sys to access
disguise diffs of the corresponding disguises to compose the new disguise on top of these disguises
during application. Applying a disguise returns the instance identifier $\delta_i$ and a locating
capability \lcapa{p\delta_i} that only the client stores. 

In order to reveal data disguised by $\delta$, a client speaking for $p$ invokes
\fn{RevealDisguise}.  The client provides the capability pair (\lcapa{p\delta_i},\dcapa{p\delta{i}})
to allow \sys to access disguise diffs that it can use to restore the original, undisguised data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Client-Application-\sys: Performing Application Actions with Permissions.}
Imagine the scenario in which an invoked disguise $\delta_i$ for HotCRP anonymizes all reviewers and
authors of a conference by decorrelating them from their papers and reviews respectively.

The application normally ensures that only a client speaking for $p$ should have read-only access to
reviews for $p$'s authored papers, and read-write access to reviews $p$ wrote.

If the client speaking for $p$ invokes application action $a$ such as ``edit review'' as it would
normally, the application
(post-$\delta_i)$ will not grant the client any read/write permissions to perform actions on 
any reviews of the conference: any previously correlated paper or review is now associated with
pseudoprincipal $q$.
Instead, to allow the client speaking for $p$ to regain authorship or reviewership permissions, the client first invokes the
\fn{ActWithCapabilities} API call to the application, passing in the action $a$ and a set of
capability pairs.  

When the application attempts to perform $a$, the application code may check that the invoking
principal $p$ is linked to object $x$ (\eg $p$ is the author of some paper or review). To work with
disguises, the application developer augments these these checks with queries to \sys of
\fn{CapPairEstablishesLink($p$, $x$, \pcapa{p\delta_i})} for all capability pairs provided by the
client.

If any query returns \fn{true}, the application can establish a link between $p$ and $x$, even if $x$
is currently linked (in the application database) to pseudoprincipal $q$. The application can thus
treat the client as if the client speaks for pseudoprincipal $q$, and permit the action $a$ (\eg 
read reviews on $q$'s authored papers, or read/write reviews belonging to $q$).







\iffalse
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \vspace{6pt}
    \fn{RegisterPrincipal($p$, email, $\pubk{p}$) $\rightarrow ()$} & Registers $p$ as a principal whose data can be privately disguised.\\
    \vspace{6pt}
    \fn{GetGlobalAddresses($p$)} $\rightarrow$ \{\addr{p\delta}\} & Retrieves the (globally 
    available) addresses associated with principal $p$; nonempty only if $p$ is a pseudoprincipal.\\
    \vspace{6pt}
    \fn{AddressesToEncTokenKeys(\{\addr{}\}) $\rightarrow$ \{Enc(\symk{})\}} & Uses the provided
    addresses to retrieve the corresponding encrypted symmetric keys that were used to encrypt tokens.\\
    \vspace{6pt}
    \fn{GetPseudoPrincipalEncPrivKeys($p$)} $\rightarrow$ \{\tpriv{pq}\} & Retrieves the
    encrypted private key tokens of pseudoprincipal created by decorrelating data from $p$.\\
    \vspace{6pt}
    \fn{Disguise($d$, \{\symk{pd'}\}) $\rightarrow$ \{\addr{}\}} & Applies disguise $d$.  The
    provided set of symmetric keys (potentially corresponding to several disguises and several
    principals) grant \sys access to tokens tokens from these disguises for these principals, which
    allow \sys to compose disguise $d$ on top of these previous disguises.  This function returns a
    set of addresses corresponding to the addresses of \tdata{} and \symk{} ciphertexts produced by this disguise.\\
    \vspace{6pt}
    \fn{Reveal($d$, \{\symk{p\delta}\}) $\rightarrow ()$} & 
    Reveals disguise $d$.  The provided set of symmetric keys corresponding to disguise $d$ and
    potentially several principals grant \sys access to tokens from disguise $d$ for these
    principals. \sys reveals the data stored in the tokens if possible.
\end{tabular}
\vspace{6px}

\caption{\sys API}
\label{tab:api}
\end{table*}

\sys takes these developer-provided specifications and exposes the API in Table~\ref{tab:api} to the
application. 

\head{Principal Public Key Registration.}
Figure~\ref{fig:acctreg} illustrates the principal registration protocol: every principal in the
system must register a public key with \sys in order to later reveal (for disguise reversal or
composition) any of privately disguised data. \sys remembers each public key \pubk{p} along with
$p$'s ID.

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\fn{RegisterPrincipal(p,$\pubk{p}$)}} \< \\
\<\< \fn{StorePubKey($\pubk{p}$)}
}
\caption{\textbf{Principal public key registration.}}
\label{fig:acctreg}
\end{figure*} 

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \fn{addrs} \gets \fn{LoadClientAddresses($p$)}\\
\fn{privKs} \gets \{p \mapsto \privk{p}\}\pclb
\pcintertext[dotted]{Recursively get addresses of all linked pseudoprincipals}
\fn{idsToProcess} \gets \{p\}\\
\pcwhile \fn{idsToProcess} \neq \{\}:\\
\quad q \gets \fn{idsToProcess.pop()}\\
\< \sendmessageright*{\fn{GetPseudoPrincipalEncPrivKeys($q$)}} \< \\
\<\< \fn{encPrivKs} \gets \fn{\sys.Principals[q].EncPKTokens}\\
\< \sendmessageleft*{\fn{encPrivKs}} \< \\
\quad \pcforeach \fn{encPrivK} \in \fn{encPrivKs}:\\
\quad \quad \privk{q} \gets \fn{privKeys}[q]\\
\quad \quad \tpriv{qr} \gets \dec(\privk{q}, \fn{encPrivK})\\
\quad\quad\fn{privKs.insert}(r\mapsto \tpriv{qr}.\fn{privKey}) \<\< \\
\quad\quad\fn{idsToProcess.insert($r$)} \<\< \\
\< \sendmessageright*{\fn{GetGlobalAddresses($q$)}} \< \\
\<\< \fn{globalAddrs} \gets \fn{\sys.Principals[q].GlobalAddrs}\\
\< \sendmessageleft*{\fn{globalAddrs}} \< \\
\quad\quad\fn{addrs.append(globalAddrs)}\\
\quad \pcendforeach\\
\pcendwhile\pclb
    \pcintertext[dotted]{Use addresses to get corresponding encrypted token keys}
\< \sendmessageright*{\fn{AddressesToEncTokenKeys(addrs)}} \< \\
    \<\< \fn{encsymkeys} \gets \fn{LoadEncTokenKeys(addrs)}\\
\< \sendmessageleft*{\fn{encsymkeys}}\\
\fn{symkeys} \gets \{\}\\
\pcforeach \fn{Enc(\symk{qd'})} \in \fn{encsymkeys}\\
\quad \pcif \text{authorizes access to $q$'s private tokens for $d'$}: \\
\quad\quad \privk{q} \gets \fn{privKs[q]}\\
\quad\quad \fn{symkeys.insert(\dec(\privk{q}, \symk{qd'}))}\\
\pcendforeach\pclb
\pcintertext[dotted]{Apply disguise with token keys}
\< \sendmessageright*{\fn{Disguise($d$,symkeys)}} \< \\
\<\< \{\addr{}\}\gets\fn{ApplyDisguise($d$,symkeys)} \pclb
\pcintertext[dotted]{Addresses can be emailed by \sys or returned to application}
}
\caption{\textbf{Disguise Application.}}
\label{fig:disgapp}
\end{figure*} 

\head{Disguise Application and Reversal with Addresses.}
As shown in Figure~\ref{fig:disgapp}, an \sys client can retrieve addresses both provided for an
original principal $p$ (for which the client is authenticated and has \privk{p}). 

The client can also retrieve addresses and private keys for all pseudoprincipals associated with $p$.

Using these addresses, the client can query for encrypted symmetric \symk{} keys corresponding to
the set of provided addresses; and decrypt and provide these \symk{}s to \sys to disguise (or reveal) using token data that can be decrypted using the provided \symk{}.

\iffalse
\vspace{6pt}\noindent\textbf{(2) \tdata{} Token Ciphertext Storage.}
\sys must hide which token ciphertexts correspond to which principals.  Naively, \sys can store
all ciphertexts in one bag; in order to determine which ciphertexts a client may access, the client
provides the decrypted \symk{p\delta} and \sys tries to decrypt every ciphertext in the bag. This clearly
has poor performance and is unscalable.
However, \sys cannot group the ciphertexts into bags indexed by principal ID: this leaks information
about the number of private tokens associated with a principal.

To provide metadata privacy while achieving better performance, \sys stores encrypted \tdata{p\delta} and
\tpriv{pq} tokens in a linked list of encrypted tokens produced by $d$ associated with $p$, notated
as \tokls{p\delta}. 
Tokens store links to the next token in the list with in an additional \fn{nextEncToken} field: this
field stores a pointer to the location of current tail of \tokls{p\delta} for $p$ and $d$.
Thus, only by decrypting tokens in the list one by one can the entire \tokls{p\delta} be discovered and
the ciphertexts in the list decrypted.

\sys stores current pointers to the tails of \tokls{p\delta} indexed by $p$ and $d$. This allows \sys to
know where to start decrypting the list of tokens given $p$ and $d$, and how to set
\fn{nextEncToken} for a new token in \tokls{p\delta} produced when applying $d$. \sys generates dummy
tail pointers for all principals not associated with disguise $d$ to hide metadata about which lists
exist.
Because \tokls{p\delta} tails point to (real or dummy) token ciphertexts, an adversary learns nothing
about the token contents or how many tokens are associated with a principal.

\vspace{6pt}\noindent\textbf{(3) \tpriv{} Token Ciphertext Storage.}
\lyt{For this, we would need to store in a linked list, each node would have to be sent one at a
time to the client because each token is encrypted with \pubk{p}}.

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.6\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \vspace{6pt}
    \fn{RegisterPrincipal($\pubk{p}$)} & Registers $p$ as a principal whose data can be privately disguised. \\
    \vspace{6pt}
    \fn{PseudoPrincipalKeysRequest($p$)} & Requests the encrypted private keys of pseudoprincipals
    created by decorrelating data from $p$.\\
    \vspace{6pt}
    \fn{PseudoPrincipalKeysResponse(encPrivKs)} & Sent from \sys to the client authenticated as $p$ with the set of encrypted
    private keys of pseudoprincipals linked to $p$.\\
    \vspace{6pt}
    \fn{StartDisguise($d$, addrs, ppIds)} & Begins the process of applying disguise
    $d$, granting \sys access to prior disguised data of $p$'s with the provided addresses in
    \texttt{addrs}, and access to prior disguised data of any pseudoprincipals in \texttt{ppIds}.\\
    \vspace{6pt}
    \fn{StartDisguiseReversal($d$, addrs, ppIds)} & Begins the process of reversing disguise $d$,
    granting \sys access to prior disguised data of $p$'s with the provided addresses in \texttt{addrs}, and access to prior disguised data of any pseudoprincipals in \texttt{ppIds}.\\
    \vspace{6pt}
    \fn{RequestTokenAccess(encSymKeys)} & Sent from \sys to a client authenticated as
    $p$, requesting the client decrypt all the encrypted symmetric keys in \fn{encSymKeys} with
    \privk{p} and uncover the corresponding \symk{p\delta}s. \\
    \vspace{6pt}
    \fn{GrantTokenAccess(\{\symk{p\delta}\})} & Grants \sys permission, for all \symk{p\delta} in the
    argument, to decrypt any privately-stored \tdata{p\delta} and \tpriv{pdq} with \symk{p\delta}.
\end{tabular}
    \vspace{6px}
\caption{API Calls for Client Authenticated as Principal $p$}
\label{tab:api_impl}
\end{table*}

Table~\ref{tab:api} describes all the API calls used in protocols between \sys and a client.
\lyt{Not sure if the admin- vs. user-authenticated client distinction is clear here..}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{PseudoPrincipal Private Key Retrieval.}
Figure~\ref{fig:userprivkeyretrieval} illustrates the protocol by which a client, authenticated as
principal $p$, can gain access to the private keys (and thus the tokens) of pseudoprincipals created
from decorrelating $p$'s data.

The client sends a request to \sys for the private keys of pseudoprincipals linked to $p$. \sys
loads the encrypted private key tokens for $p$, and sends these back in a response to the client.
%
The client then decrypts these tokens with \privk{p}, and saves the mapping from pseudoprincipal ID
$q$ to private key \privk{q} encoded in the token.

The client recursively retrieves the private keys of all pseudoprincipals linked to $q$ until
no more nested pseudoprincipals exist.

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\fn{privKs} \gets \{p \mapsto \privk{p}\}\\
\fn{idsToProcess} \gets \{p\}\\
\fn{ppIds} \gets \{\}\\
\pcwhile \fn{idsToProcess} \neq \{\}:\\
\quad q \gets \fn{idsToProcess.pop()}\\
\< \sendmessageright*{\fn{PseudoPrincipalKeysRequest($q$)}} \< \\
\<\< \fn{encPrivKs} \gets \fn{LoadEncPrivKTokens}(q)\\
\< \sendmessageleft*{\fn{PseudoPrincipalKeysResponse(encPrivKs)}} \< \\
\quad \pcforeach \fn{encPrivK} \in \fn{encPrivKs}:\\
\quad \quad \privk{q} \gets \fn{privKs}[q]\\
\quad \quad \tpriv{qd'r} \gets \dec(\privk{q}, \fn{encPrivK})\\
\quad \quad \pcif \text{authorizes access to $r$'s private tokens}: \\
\quad \quad\quad\fn{privKs.insert}(r\mapsto \tpriv{qd'r}.\fn{privKey}) \<\< \\
\quad \quad\quad\fn{idsToProcess.insert($r$)} \<\< \\
\quad \quad\pcfi\\
\quad \pcif q \neq p:\\
\quad\quad \fn{ppIds.append($q$)}\\
\quad \pcfi\\
\quad \pcendforeach\\
\pcendwhile
}
\caption{\textbf{PseudoPrincipal Key Retrieval.}}
\label{fig:userprivkeyretrieval}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{User-Authenticated Disguise Application.}
Figure~\ref{fig:userauthdisapp} illustrates the protocol for user-authenticated (as principal $p$) disguise application.

The client first performs pseudoprincipal private key retrieval for $p$, and retrieves all addresses from
prior disguises for which the client grants token access.
%
The client then invokes \fn{StartDisguise} with these addresses and the set of pseudoprincipals.

\sys takes the addresses of $p$ and the public addresses of all pseudoprincipals in the
provided set, and retrieves the corresponding encrypted \symk{}s.
\sys then requests to access all private tokens protected by these symmetric keys by sending a
\fn{RequestTokenAccess} to the client with the \symk{} ciphertexts.

The client decrypts the ciphertexts using the appropriate \privk{q} (proving
that the client has access to $q$'s private tokens). 
%
The client only includes the decrypted \symk{qd'} in the set of keys sent back to \sys via a
\fn{GrantTokenAccess} API call if the client wants to authorizes access to $q$'s private tokens
from disguise $d'$. 

\sys then uses each \symk{qd'} to decrypt $q$'s private tokens produced by disguise $d'$. Note that
if the client returns a false \symk{qd'}, the decryption will fail, and \sys will not reveal any
$q$'s private tokens from $d'$.

\sys combines all decrypted private tokens with the set of globally accessible tokens to produce
all tokens available to apply disguise $d$. 

\lyt{Note: this requires that a client be user-authenticated as $p$ to access $p$'s tokens, which
isn't necessarily fundamental.}

\begin{figure*}[t!]
\pcb{
\<\< \\[-1\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]\\
\texttt{//perform pseudoprincipal key retrieval}\\
\fn{addrs} \gets \{\}\\
\pcforeach \addr{pd'} \in \fn{client.Addresses}:\\
\quad \pcif \text{authorizes access to $d'$ tokens for $p$}: \\
\quad\quad\fn{addrs.insert(\addr{pd'})} \<\< \\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{StartDisguise($d$,addrs,ppIds)}} \< \\
\<\< \fn{symKeyEncs} \gets \{\}\\
    \<\< \fn{symKeyEncs.insert(LoadEncSymKeys(addrs))}\\
\<\< \pcforeach q \in \fn{ppIds}:\\
\<\< \quad\quad\fn{ppAddrs} \gets \fn{\sys.PseudoPAddrs[q]}\\
\<\< \quad\quad\fn{symKeyEncs.insert(}\\
\<\< \quad\quad\quad\quad \fn{LoadEncSymKeys(ppAddrs))}\\
\<\< \quad\pcendif\\
\<\< \pcendforeach\\
\< \sendmessageleft*{\fn{RequestTokenAccess(symKeyEncs)}} \< \\
\fn{symKeys} \gets \{\}\\
\pcforeach \fn{encSymKey} \in \fn{symKeyEncs}:\\
\quad q \gets \fn{encSymKey.principalId}\\
\quad d' \gets \fn{encSymKey.disguiseId}\\
\quad \privk{q} \gets \fn{privKeys}[q]\\
\quad \pcif \text{authorizes access to $d'$ tokens for $q$}: \\
\quad\quad \fn{symKeys.insert(\dec(\privk{q}, \fn{encSymKey})}\\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{GrantTokenAccess(\fn{symKeys})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
    \<\< \quad\fn{tokens.insert(}\\
    \<\<\quad\quad\fn{ReadGlobalTokens}(d'))\\ 
\<\< \pcendforeach\\
\<\< \pcforeach \symk{qd'} \in \fn{symKeys}: \\
\<\< \quad\fn{tokens.insert(}\\
\<\< \quad \quad \fn{ReadPrivateTokens(\symk{qd'}))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{User-Authenticated disguise application.}}
    \label{fig:userauthdisapp}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Admin-Authenticated Disguise Application.}
In contrast to user-authenticated disguise application, \sys does not request access to any private
tokens, and instead simply applies the disguise with only globally-accessible tokens (shown in Figure~\ref{fig:adminauthdisapp}).

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Admin-authenticated Client} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \< \sendmessageright*{\fn{StartDisguise($d$,\{\},\{\})}} \< \\
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\fn{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Admin-authenticated disguise application}. }
    \label{fig:adminauthdisapp}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Disguise Reversal.}
User- and admin-authenticated disguise
reversal protocols follow the same logic as disguise application protocols, with the only
differences being the API call invoked by the client 
(\fn{StartDisguiseReversal}\fn{($d$,addrs,ppIds)}) and the
function that \sys calls at the end (\fn{ReverseDisguise} \fn{($d$,tokens)}).
\fi
\fi
