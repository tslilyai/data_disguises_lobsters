\section{Disguise Application and Reversal Semantics}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Internal Disguise Functions.}}
Table~\ref{tab:funcs} describe \sys's internal functions run server-side to implement its API 
and apply or reverse disguises. 

Figures~\ref{fig:appdisg} and \ref{fig:revdisg} describe how \sys implements disguise application and
reversal respectively. Figure~\ref{fig:opexec} describes how disguise operations update application
state and produce and modify tokens, and 
Figure~\ref{fig:revtoken} describes how \sys uses a token's recorded
modification to reverse an applied disguise operation. 
Figure~\ref{fig:rpt} describes how \sys accesses the private tokens
corresponding to disguise $d$ and principal $p$ by recursively decrypting tokens and traversing
\tokls{pd}.

\sys's implementations of the remaining functions in Table~\ref{tab:funcs} simply read or write into
persistent maps indexed by principal and/or disguise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Some Notation.}}
We describe disguise histories as a list of \app{d} and \rev{d} actions, where \app{d} corresponds
to the application of disguise $d$, and \rev{d} corresponds to the reversal of $d$. Time moves to
the right in the list.

For every data object $O$ in the system, \ostart describes its initial state, and
\ohist{[\app{d_1}, \dots]} describes its state after \sys has applied the history [\app{d_1},
$\dots$].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Composing Multiple Disguise Applications.}}
Let $d_1$ and $d_2$ be two disguises, where $d_1$ is applied after $d_2$.
to produce disguise history [\app{d_1}, \app{d_2}]. 
%
Let $O$ be some data object in the system, where \ostart is its initial state, and
\ohist{[\app{d_1}, \app{d_2}]} be the final state after \sys applies $d_1$ and $d_2$.
%
If both $d_1$ and $d_2$ update $O$, what is \ohist{[\app{d_1}, \app{d_2}]}?
We consider two possible end states: 
%
\begin{enumerate}
\item[(\appcompone)] \ohist{[\app{d_1}, \app{d_2}]} reflects the application of $d_1$ \textbf{and} $d_2$ to \ostart. In other
words, at least one of the \op{d_2}s' predicates \texttt{pred} matches \ostart, and thus \op{d_2} is
applied to \ohist[\app{d_1}] even if \texttt{pred} does not match \ohist[\app{d_1}]. 
\op{d_2} updates are applied on top of any $d_1$'s' updates if the two conflict.

\item[(\appcomptwo)] \ohist{[\app{d_1}, \app{d_2}]} reflects the application of $d_1$ to \ostart, followed
by the application of $d_2$ to \ohist{[\app{d_1}]}. \op{d_2} predicates match only against
\ohist{[\app{d_1}]}, and are not aware of the original state \ostart.
\end{enumerate}

\noindent
For example, let \op{d_1} decorrelate all posts from authors predicated
on \texttt{author = Bea}, and let \op{d_2} remove all posts predicated on \texttt{author = Bea}.
%
\begin{enumerate}
\item[(\appcompone)] Both \op{d_1} and \op{d_2} update posts originally having author ``Bea'', resulting in the
removal of all posts originally with author Bea.

\item[(\appcomptwo)] Applying \op{d_1} results in all posts with author ``Bea'' having
pseudoprinicipal authors such as ``anonFox.'' \op{d_2} only knows the state of posts after
\op{d_1} occurs, and does not remove any posts because no post has author ``Bea''.
\end{enumerate}

The choice of whether \ohist{[\app{d_1}, \app{d_2}]} should result in \appcompone or \appcomptwo depends on the
specific application and is left to the developer to specify. 

However, only \appcomptwo may be possible in certain scenarios.
In order to achieve \appcompone, $d_2$ must evalute predicates against \ostart, and therefore must know
how $d_1$ modified $O$ (\eg knowing that a post with author ``anonFox'' originally was a post with
author ``Bea'').  This information, however, is stored in tokens produced by $d_1$. 

These tokens may be inaccessible \sys when applying $d_2$, as they could be stored privately for
principal $q$: a client who invokes $d_2$ while either unauthenticated, or authenticated as
principal $p \neq q$, cannot access $q$'s tokens for $d_1$. 
In this case, $d_2$ can only match against \ohist{[\app{d_1}]} and achieve \appcomptwo.
This is shown in Table~\ref{tab:composeapp}.

\begin{table}[h]
\centering
\begin{tabular}{ c | c c }
& \multicolumn{2}{c}{\textbf{$d_1$ Tokens for $O$}}\\
\textbf{Client Invoking $d_2$ }& \textbf{Global} & \textbf{Private to $p$}\\
\hline
{Unauthenticated} & \appcompone or \appcomptwo & \appcomptwo\\
{Authenticated as $p$} & \appcompone or \appcomptwo & \appcompone or \appcomptwo \\
{Authenticated as $q \neq p$} & \appcompone or \appcomptwo & \appcomptwo
\end{tabular}
\vspace{6pt}

\caption{Possibilities for \ohist{[\app{d_1},\app{d_2}]} depending on the state of the client invoking $d_2$, and the
state of tokens from $d_1$ regarding $O$.}
\label{tab:composeapp}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[t]
\centering
\begin{tabular}{ c | c c }
& \multicolumn{2}{c}{\textbf{$d$ Tokens for $O$}}\\
\textbf{Client Invoking $\rev{d}$ }& \textbf{Global} & \textbf{Private to $p$}\\
\hline
{Unauthenticated} & \ostart & \ohist{[\app{d}]}\\
{Authenticated as $p$} & \ostart & \ostart\\
{Authenticated as $q \neq p$} & \ostart & \ohist{[\app{d}]}\\
\end{tabular}
\vspace{6pt}
\caption{\ohist{[\app{d},\rev{d}]} depending on the state of the client invoking
\rev{d}, and the state of tokens from $d$ regarding $O$.}
\label{tab:composeapprev}
\end{table}

\begin{table}[t]
\centering
\begin{tabular}{ c | c c }
& \multicolumn{2}{c}{\textbf{$d_1$ Tokens for $O$}}\\
\textbf{Client Invoking $\rev{d_1}$ }& \textbf{Global} & \textbf{Private to $p$}\\
\hline
{Unauthenticated} & \ohist{[\app{d_2}]} & \ohist{[\app{d_1},\app{d_2}]}\\
{Authenticated as $p$} & \ohist{[\app{d_2}]} & \ohist{[\app{d_2}]}\\
{Authenticated as $q \neq p$} & \ohist{[\app{d_2}]} & \ohist{[\app{d_1},\app{d_2}]}\\
\end{tabular}
\vspace{6pt}
\caption{\ohist{[\app{d_1},\app{d_2},\rev{d_1}]} depending on the state of the client invoking
\rev{d_1}, and the state of tokens from $d_1$ regarding $O$.}
\label{tab:composeapprev1}
\end{table}

\vspace{6pt}\noindent\textbf{\emph{Interleaving Disguise Applications with Reversals.}}
We now consider composition of disguises in the presence of disguise reversals.

We first consider \ohist{[\app{d},\rev{d}]}. Table~\ref{tab:composeapprev}
illustrates end state depending on which client invokes \rev{d}, and how $d$'s tokens for $O$
are stored.
When the client is either unauthenticated or authenticated as a principal without access to $d$'s
private tokens, then the updates applied by $d$ to $O$ cannot be reversed.

We next consider reversing a disguise $d_1$ after a subsequent disguise $d_2$ has been applied.
\ohist{[\app{d_1},\app{d_2},\rev{d_1}]}. Table~\ref{tab:composeapprev1} illustrates the end state depending on which client invokes \rev{d_1}, and how $d_1$'s tokens for $O$
are stored. Similar to the prior scenario, when the client is either unauthenticated or authenticated as a principal without access to $d_1$'s private tokens, then the updates applied by $d_1$ to $O$ cannot be reversed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Retroactive Disguise Application.}}
In certain scenarios, \sys must retroactively apply a disguise in order to achieve the end states
described in Table~\ref{tab:composeapprev1}. 

Concretely, consider the history [\app{d_1},\app{d_2}].  As we described in composing disguise
applications, \appcomptwo may be the only possible outcome for \ohist{[\app{d_1},\app{d_2}]}: if $d_1$'s tokens
about $O$ tokens are private to principal $p$, and $d_2$ is invoked by an unauthenticated client or
a client authenticated as a different principal $q$, then some \op{d_2} may not update $O$ because
its predicate only matches again \ohist{[\app{d_1}]}.

However, even in this case, \sys needs to ensure that \ohist{[\app{d_1},\app{d_2},\rev{d_1}]}
achieves the semantics described in Table~\ref{tab:composeapprev1}. In particular, even when $d_1$'s
tokens are private to $p$, a client authorized as $p$ should be able to reverse $d_1$ such that the
state of $O$ is \ohist{[\app{d_2}]}, namely $d_2$ applied to \ostart. 

This requires \sys to retroactively apply $d_2$ during reversal of disguise $d_1$, when \sys has
access to $d_1$'s private tokens for $p$. \sys can use these private tokens to reveal \ostart, and
then match each \op{d_2}'s predicate with \ostart to see if \op{d_2} should update $O$.

\sys uses the disguise history to know what disguises to retroactively apply when a prior disguise
reveals token data.
\lyt{Disguising should based on only contents of data in application database, and
not predicated \eg on the current time.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Retroactive Disguise Reversal.}}
% NOTE TODO this is an issue in a history that does rev d2 after rev d1, not the ones shown above..
In certain scenarios, \sys must retroactively reverse a disguise. 

Concretely, consider the history $H = [\app{d_1},\app{d_2},\rev{d_1},\rev{d_2}]$.
We expect that \ohist{H} is equivalent in \ostart.

When $d_1$'s tokens for $O$ are accessible by the client reversing $d_1$, achieving this requires
only having access to $d_2$'s tokens (as shown in Table~\ref{tab:composeapprev1}).

However, if the client reversing $d_2$ does not have access to $d_1$'s tokens, then'
then \sys cannot restore the state to \ostart unless . 

TODO 

\sys logs the reversal of $d_1$ in the disguise history, and uses this history to detect if it
should reverse any conflicting updates performed by $d_1$ when $d_2$ is reversed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Modifying Tokens to Prevent Global Token Information Leakage.}}
%The ONLY REASON we need to update tokens is if they're global!!! If they're private, we can use the
%retroactive application method... (optimization to update our "own" tokens though)
%
Let $d_1$ be a global disguise and $d_2$ be a private disguise applied in sequence.
Consider the scenario in which \op{d_1} updates (decorrelates, modifies, or removes) a data object
$O$, producing a global token \tdata{pd_1}. Later, \sys determines that \op{d_2} would have applied to the
removed $O$ by checking if the corresponding \op{d_2} predicate matches recorded object data stored in \tdata{pd_1}.

If \sys simply performs \op{d_2}'s update to $O$ in the application database, an adversary can still
read undisguised data from \tdata{pd_1} since is it global and records a now-stale state of $O$!
%
%Furthermore, this means that \sys cannot restore the state of $O$ in the database to
%\ohist{[\app{d_2}]} when reversing $d_1$, because the revealing the data in \tdata{pd_1} would
%reveal data that $d_2$ should have disguised.
%
To prevent global tokens like \tdata{pd_1} from leaking information that should be disguised, \sys
updates the data in \tdata{pd_1} with \op{d_2}'s update. An update to a token such as \tdata{pd_1}
itself generates a (private) token \tdata{pd_2}, just as updating a data object generates a token.

Reversing $d_2$ uses this \tdata{pd_2} to reverse the modification to \tdata{pd_1}. 
If $d_1$ has already been reversed, and the database state of $O$ updated to reflect the contents
of \tdata{pd_1} (which were updated by the application of $d_2$), 
then \sys simply uses \tdata{pd_2} to reverse the current state of $O$ in the database. 

If a future $d_3$ has further updated \tdata{pd_1} in a way that conflicts with $d_2$'s update,
then upon reversal of $d_2$, \sys will notice that \tdata{pd_2} records a stale update to \tdata{pd_1}, 
and will not revert
the state of \tdata{pd_1} until the future disguise $d_3$ has been reversed.

\lyt{Note that removal is just an interesting case of this, in which \tdata{pd_1} is removed, by a
token \tdata{pd_2} is stored in \tokls{pd_2} that saves the removal of \tdata{pd_1} for reversal.}

%\vspace{6pt}\noindent\textbf{\emph{Token Modification for Object Identification.}}
%Tokens need to refer to the correct objects even if objects have been modified by future disguises.
%Prior tokens should be revised by future disguises so that they apply correctly to the disguised
%data.
%This allows an earlier disguise to be reversed correctly.
%An easy way to avoid needing to do this is to have all objects in the DB have unique, permanent
%identifiers.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse
\subsection{Handling Interleaved Application Updates}
\noindent\textbf{\emph{Application Updates to Present Disguised Data.}}
\sys will not reveal disguised data still present in the database that has been updated by the
application. Application updates are equivalent to irreversible disguise operations.
\sys checks the current state of data against the latest disguised state
expected as recorded in the token; if they do not match, then an application update has occurred
since disguising, and \sys will not alter the data.

\vspace{6pt}\noindent\textbf{\emph{Application Updates to Removed Disguised Data.}}
Application updates fail to update data removed by a disguise, which can later be revealed in
original form.
\sys requires all application updates that must immediately apply to revealed data (that is
currently disguised and removed) to be disguises themselves; otherwise, the application must handle
the possibility of non-updated data being revealed.
%\sys stores a query log of all application update queries, and reapplies them to any removed data by a disguise prior to revealing the data

\begin{table}[h]
\footnotesize
\centering
\begin{tabular}{ c | c c c }
& \textbf{$d_2$ Decorrelates} & \textbf{$d_2$ Modifies} & \textbf{$d_2$ Removes}\\
\hline
\textbf{$d_1$ Decorrelates}  & \ohist{[\app{d_2}]} & \ohist{[\app{d_2}]} &\ohist{[\app{d_2}]} \\
\textbf{$d_1$ Modifies} & \ohist{[\app{d_2}]} & \ohist{[\app{d_2}]}\checkmark
&\ohist{[\app{d_2}]}\checkmark \\
\textbf{$d_2$ Removes}  & \ohist{[\app{d_2}]}\checkmark & \ohist{[\app{d_2}]}\checkmark
&\ohist{[\app{d_2}]}\checkmark \\
\end{tabular}
\vspace{6pt}
\caption{\ohist{[\app{d_2}, \app{d_2}, \rev{d_1}]} when $d_1$ is global, and $d_2$ is private.}
\label{tab:revinternal}
\end{table}

\begin{table*}[h]
\centering
\begin{tabular}{ c | c c c c }
\textbf{History} & \textbf{(Global $d_1$, Global $d_2$)} & \textbf{(Private $d_1$, Private $d_2$)} &
\textbf{(Private $d_1$, Global $d_2$)} & \textbf{(Global $d_1$, Private $d_2$)} \\
\hline
\ohist{[\app{d_1}, \app{d_2}]} & \appcompone or \appcomptwo & \appcompone or \appcomptwo & \appcomptwo & \appcompone or \appcomptwo \\

\ohist{[\app{d_1}, \app{d_2}, \rev{d_2}]} & \ohist{[\app{d_1}]} & \ohist{[\app{d_1}]} & \ohist{[\app{d_1}]} & \ohist{[\app{d_1}]}\\

\ohist{[\app{d_2}, \app{d_2}, \rev{d_1}]} & \ohist{[\app{d_2}]} & \ohist{[\app{d_2}]} &
\ohist{[\app{d_2}]} & \ohist{[\app{d_2}]} or \ohist{[\app{d_1}, \app{d_2}]}\\
\vspace{6pt}
\end{tabular}

\caption{End state of object $O$ for various histories, depending on whether $d_1$ and
$d_2$ are private or global.}
\label{tab:compose}
\end{table*}

\fi
