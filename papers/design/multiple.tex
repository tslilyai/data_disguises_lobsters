%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Supporting Universal Disguising of Anonymized Users}

\begin{table*}[t!]
\centering
    \begin{tabular}{ p{.5\linewidth} p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($p$, Email email, PubKey $\pubk{p}$)} $\rightarrow$ () & Registers $p$ as
        a principal in \sys.\\
    \vspace{6pt}\\
    \fn{GetEncryptedCapPairs($p$) $\rightarrow$
        \fn{Vec<Enc\pcapa{p\delta_i}>}} & Returns the set of corresponding \pcapa{p\delta_i} encrypted with
        \pubk{p}, for all $\delta_i$ that applied to $p$.\\
    \vspace{6pt}\\
    \fn{GetEncryptedPseudoPrincipals($p$) $\rightarrow$
        \fn{Vec<Enc($q$,\privk{q})>}} & Returns the set of encrypted pseudoprincipals and their
        private keys created when decorrelating $p$'s data.
\end{tabular}
\caption{Additional Client-\sys API Calls for Asymmetric Encryption}
\label{tab:client_api_ext}
\end{table*}

To apply one disguise on top of another in a way that supports, \eg universal decorrelation after
account pseudonymization, \sys must support \emph{pseudoprincipal diffs}, namely diffs 
associated with pseudoprincipals. 

These diffs can occur after at least one disguise has been applied: subsequent disguises may
associate diffs with pseudoprincipals. For example, after account pseudonymization, every user account
 with a paper or review is a pseudoprincipal user. When \sys applies universal decorrelation,
 decorrelation of all papers and reviews generates correlation diffs for these pseudoprincipals.

This causes a problem: because diffs are encrypted with \dcapa{p\delta_i} and stored at
\lcapa{p\delta_i}, capabilities are emailed or otherwise sent to (potentially offline) clients
so \sys never holds onto capabilities. However, pseudoprincipals have no corresponding real user
(and \sys cannot store which real user each pseudoprincipal corresponds with to provide
unlinkability), so \sys has no way to communicate capabilities to a real user!
%, so pseudoprincipals' capabilities can either be insecurely stored by \sys, or lost forever!

We have three potential approaches to solve this problem. Two we see as strawmen because they fail
to meet our secury and use case goals respectively:
\begin{enumerate}
    \item \emph{Weak Security:} \sys can store \pcapa{p\delta_i} for pseudoprincipal $p$. This means
        an adversary will be able to learn $p$'s undisguised data, even if it had been disguised by
        $\delta_i$.

    \item \emph{Permanent Disguises:} \sys throws away \pcapa{p\delta_i} for pseudoprincipal $p$. This means that the
        disguise modifications are permanent, and no links (to determine ownership) between
        $p$ and other pseudoprincipals can be made. This affects temporary recorrelation, because
        decorrelation links between principals cannot be derived from discarded diffs.
\end{enumerate}

We next describe a third option, which uses asymmetric encryption and meets our security and use
case goals, at the cost of usability.

\subsubsection{Asymmetric Encryption} 

\sys can use asymmetric encryption to grant a client speaking for original principal $p_0$ access to
a pseudoprincipal $p$'s \pcapa{p\delta_i}. In this scheme, each principal (real or pseudo) has an
associated private-public key pair, of which \sys knows only the public key. 

When a pseudoprincipal $p$ is generated to decorrelate data from $p_0$, \sys also generates a
keypair (\pubk{p}, \privk{p}) for $p$, and encrypts \privk{p} with the original principal $p_0$'s
public key \pubk{p_0}. 

\sys then encrypts \pcapa{p\delta_i} with \pubk{p} and stores only the ciphertext, allowing \sys to avoid
the need to send capabilities to some email address, while retaining strong security of $p$'s
database diffs. 

To achieve security (so no adversary can learn how many pieces of decorrelated data a principal
has), \sys stores both the encrypted private key of $p$, and \pcapa{p\delta_i} at location
\lcapa{p_0\delta_i} along with $p_0$'s encrypted diffs from disguise $\delta_i$. The client can thus
use \lcapa{p_0\delta_i} to retrieve all encrypted private keys and capabilities associated with
pseudoprincipals generated by $\delta_i$.

If $p_0$ itself is a pseudoprincipal, then \sys simply stores these ciphertexts associated with
$p_0$'s ID.  This implies that an adversary can learn that \emph{some} disguise has applied to and
decorrelated data from $p_0$, but \emph{only if} $p_0$ is a pseudoprincipal and therefore already
dissociated from the original principal's identity.  
\lyt{How to integrate this into our threat model???}

\head{Usability Analysis.}
A client speaking for $p_0$ first needs to prove it can access \privk{p} by decrypting the \privk{p}
ciphertext with \privk{p_0}. Only then can the client decrypt the encrypted \pcapa{p\delta_i}
associated with pseudoprincipal $p$ with the decrypted \privk{p}. \pcapa{p\delta_i} then gives the
client the ability to reveal, disguise, or perform application actions with access to diffs from
$\delta_i$ applying to $p$.

This introduces another round-trip for any client using the API: a client speaking for $p_0$ that
wants to reveal or compose on top of pseudoprincipal diffs must (1) query for all pseudoprincipal
\privk{p} ciphertexts associated with $p_0$ for all \lcapa{p_0\delta_i} (for
all $\delta_i$), (2) retrieve the capabilities corresponding to all
pseudoprincipals $p$, and (3) actually invoke the action with the decrypted capability pairs.

This makes it difficult to implement a userflow where the user can click on a single URL to grant \sys diff
access: in this design, the user has to first retrieve all possible URLs.

Table~\ref{tab:client_api_ext} shows the additional API calls added by \sys to support asymmetric
encryption of capabilities. 
\lyt{TODO protocol diagrams for this vs. the simple design without asymmetric encryption}

