\section{Disguise Tokens}

Operations \op{d} of disguise $d$ generate tokens. Operations are one of three types:
\begin{enumerate}
    \item Decorrelate: generate a new anonymous principal $p'$, and rewrite the ownership (foreign key)
        relationship from the data object (row) to the original principal $p$ to instead point to $p'$.
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
\end{enumerate}

\noindent
Every \op{d} produces data tokens \tdata{pd} with the following fields, which record changes
performed by \op{d}.
\begin{itemize}
\item \fn{tokenID}:  unique ID for this token
\item \fn{objID}:  unique ID for the data object modified by \op{d}
\item \fn{updateType}:  decorrelate, modify, or remove
\item \fn{oldValue}:  original value of object \fn{objID}
\item \fn{newValue}:  updated value of object \fn{objID}
\end{itemize}

%\lyt{XXX We don't actually need insert tokens?}
%Note that a decorrelation \op{d} produces two tokens, one recording an insert of the new data object representing 

\subsection{Private Token Access Design}

To achieve our security goals, \sys encrypts private tokens recording modifications to $p$'s data such that only \user{p} can
decrypt it, and stores ciphertexts such that nothing distinguishes $p_1$'s tokens from $p_2$'s
tokens.

\vspace{6pt}
\noindent\textbf{An Initial Strawman.}
As a strawman design, \sys saves a public key \pubk{p} for every principal $p$, and 
encrypts each private token of $p$'s with \pubk{p}. 
\sys stores all tokens in a bag of ciphertexts.

When \user{p} wants to access $p$'s tokens, \sys sends \user{p} the bag of ciphertexts and \user{p}
tries to decrypt all ciphertexts with its private key \privk{p}.
\user{p} then sends \sys the tokens it could decrypt.

\vspace{6pt}
\noindent\textbf{A Better Strawman.}
Clearly, the initial strawman achieves both security goals but is impractical.


\lyt{TODO: Discuss additions (linked list pointers, private key tokens) necessary to support our
design for private tokens!}

\sys adds support for private tokens by allowing \op{d}s to be either global (\globalop{d}) or
private (\privop{d}).  All parties can learn what data updates \globalop{d} performed, whereas only
principals whose data \privop{d} updates can learn what updates \privop{d} performed.

%\item \fn{nextEncToken}:  pointer to the next token in the list of private tokens produced by disguise $d$ for
    %principal $p$, \texttt{NULL} if none exists or if token is global

\noindent
A decorrelation \op{d} additional generates a \emph{private key} token \tpriv{pdp'}.
\begin{itemize}
    \item \tdata{pd}: token storing undisguised data belonging to $p$.
    Every disguise operation generates a \tdata{pd} for every principal $p$ whose data the operation
    updates.
\item \tpriv{pdp'}: token storing private key $\pubk{p'}$. Produced when a \globalop{d} or \privop{d} 
    decorrelates data from $p$ and creates a new anonymous principal $p'$ with corresponding private key $\pubk{p'}$.
\end{itemize}

If a \globalop{d} produces \tdata{pd}, \sys stores \tdata{pd} in plaintext.
However, if a \privop{d} produces \tdata{pd}, \sys encrypts \tdata{pd} 
such that only $p$ can authorize access to \tdata{pd} plaintext.\
Any produced \tpriv{pdp'} is also encrypted such that only $p$ can authorize access to \tpriv{pdp'} plaintext.

\sys encrypts each token with symmetric key \symk{pd} during disguise application. 
To ensure only $p$ can authorize the decryption of its associated \tdata{pd} and \tpriv{pdp'}
ciphertexts, \symk{pd} itself is encrypted with \pubk{p} to create \ek{pd}, and \sys stores a mapping
from $p$ and $d$ to \ek{pd}. This additionally allows \sys to support \fn{LoadEncKey/LoadEncKeys}
calls.

\lyt{Not mentioning the strawman solution that encrypts each token with \pubk{p} for now.}
%An alternative strawman solution would encrypt each token with \pubk{p}; however, this requires
%sending all tokens 

\paragraph{Hiding Token Metadata.}
\sys must determine which token ciphertexts to decrypt after $p$ authorizes access by
decrypting \ek{pd} with \privk{p} and returning \symk{pd}. 
Naively, \sys could map $p$ and $d$ to all associated \fn{Enc(\tdata{pd}) and Enc(\tpriv{pdp'})} 
However, this allows an adversary to learn \emph{how many} private tokens correspond to $p$, metadata that
\sys should keep private.

An impractical strawman solution could require \sys to attempt to decrypt \emph{all} tokens with
\symk{pd}.  \sys utilizes a better solution, namely storing encrypted tokens for $p$ and $d$ in an
encrypted linked list \tokls{pd}, and only remembering the tail of the list \toklstail{pd}.  When a
new \tdata{pd} or \tpriv{pdp'} token is produced, \sys sets the token's \fn{nextEncToken} field to
point to the current \toklstail{pd} before encrypting it.

With this linked-list design, no party except for $p$ can traverse the list and determine how
many\tdata{pd} and \tpriv{pdp'} tokens exist for any $d$.

\begin{table}[t]
\centering
\begin{tabular}{ c p{.8\linewidth} }
\fn{tokenID} & unique ID for this token\\
\fn{anonPrivKey} & \privk{p'} of generated anonymous principal $p'$\\
\fn{nextEncToken} & pointer to the next token in the list of private tokens produced by disguise $d$ for
principal $p$, \texttt{NULL} if none exists or if token is global\\
\end{tabular}
\caption{\tpriv{pdp'} Attributes}
\label{tab:privtokens}
\end{table}
