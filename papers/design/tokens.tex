\section{Disguise Operations} 
Operations \op{d} of disguise $d$ take data objects as input, execute updates to application
data, and produce (token, principal) pairs
as output. This means that the disguise specification determines how tokens correspond to
principals: for example, a comment may correspond to the principal whose ID is referenced by the
author column.
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.

        To support private tokens associated with $q$, decorrelation generates a
        public-private key pair (\pubk{q} and \privk{q}).
\end{enumerate}
Every \op{d} has an associated predicate over the application database that selects which objects
act as \op{d} inputs.

\section{Disguise Tokens} 
Disguise tokens come in two forms: data tokens and privkey tokens.

\vspace{6pt}
\noindent\textbf{\emph{Data Tokens.}}
Every \op{d} produces data tokens associated with the disguise $d$ and a
principal $p$, notated as \tdata{pd}. \tdata{pd} tokens are either be private or global depending on
whether the producing \op{d} is global or private. 
A \tdata{pd} contains the following fields, which record changes performed by \op{d}:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{objID}: unique ID for the data object modified by \op{d}
\item \fn{updateType}: decorrelate, modify, or remove
\item \fn{oldValue}: original value of object \fn{objID}
\item \fn{newValue}: updated value of object \fn{objID}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent\textbf{\emph{PrivKey Tokens.}}
Decorrelation operations generate a second form of token, namely a privkey token associated with the disguise $d$, principal $p$, and the pseudoprincipal $q$ created
during decorrelation (notated as \tpriv{pdq}).
\tpriv{pdq} contains the following fields:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}
\sys always stores \tpriv{pdq} privately and associated with $p$. This ensures that only a client
with access to \privk{p} can access \privk{q} (and therefore access $q$'s private tokens).

\vspace{12pt}
\noindent\textbf{\emph{Enforcing Token Access.}}
As described in \S\ref{sec:achievegoals}, \sys ensures the security of private disguise tokens as
follows: \sys encrypts private \tdata{pd} and \tpriv{pdq} tokens with a symmetric key \symk{pd} specific to
the disguise and principal. The token's nonce ensures safety against
known-plaintext attacks. \sys then encrypts \symk{pd} with public key \pubk{p}.
%a key only known to \sys, \sysk, and encrypts the resulting ciphertext with public key \pubk{p}. 
A client needs to prove it has \privk{p} by decrypting \symk{pd}, %$\enc(\sysk, \symk{pd})$, 
which then allows \sys to decrypt $p$'s private tokens produced from applying $d$.

\sys stores all global \tdata{pd} tokens in plaintext, where any party can access it.


\vspace{12pt}
\noindent\textbf{\emph{Hiding Private Token Metadata.}}
With \sys's design, token metadata about which principals own which tokens can leak in two ways:
\begin{enumerate}
    \item If an adversary learns that \symk{pd} exists for $p$ and $d$, 
        then an adversary knows that $d$ updated some data associated with $p$ (and produced a token
        recording the update)
    \item If an adversary can differentiate between token ciphertexts belonging to different
        principals, then the adversary learns how many tokens belong to each principal.
\end{enumerate}

\noindent
\sys prevents both leakage channels as follows:

\vspace{6pt}\noindent\textbf{(1) \symk{} Storage.}
\sys stores a mapping from $p$ and $d$ to the encrypted \symk{pd}. To ensure that this does not leak
metadata about which principals have disguised data, \sys generates dummy ciphertexts for all
principals that do not have encrypted \symk{pd}s for disguise $d$.

\vspace{6pt}\noindent\textbf{(2) Token Ciphertext Storage.}
\sys must hide which token ciphertexts correspond to which principals.  Naively, \sys can store
all ciphertexts in one bag; in order to determine which ciphertexts a client may access, the client
provides the decrypted \symk{pd} and \sys tries to decrypt every ciphertext in the bag. This clearly
has poor performance and is unscalable.
However, \sys cannot group the ciphertexts into bags indexed by principal ID: this leaks information
about the number of private tokens associated with a principal.

To provide metadata privacy while achieving better performance, \sys stores encrypted \tdata{pd} and
\tpriv{pdq} tokens in a linked list of encrypted tokens produced by $d$ associated with $p$, notated
as \tokls{pd}. 
Tokens store links to the next token in the list with in an additional \fn{nextEncToken} field: this
field stores a pointer to the location of current tail of \tokls{pd} for $p$ and $d$.
Thus, only by decrypting tokens in the list one by one can the entire \tokls{pd} be discovered and
the ciphertexts in the list decrypted.

\sys stores current pointers to the tails of \tokls{pd} indexed by $p$ and $d$. This allows \sys to
know where to start decrypting the list of tokens given $p$ and $d$, and how to set
\fn{nextEncToken} for a new token in \tokls{pd} produced when applying $d$. \sys generates dummy
tail pointers for all principals not associated with disguise $d$ to hide metadata about which lists
exist.
Because \tokls{pd} tails point to (real or dummy) token ciphertexts, an adversary learns nothing
about the token contents or how many tokens are associated with a principal.
\lyt{TODO implement dummy}
