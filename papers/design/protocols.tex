%-------------------------------------------------------------------------------
\section{\sys API Calls}
%-------------------------------------------------------------------------------
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.6\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($\pubk{p}$)} & Registers $p$ as a principal whose data can be privately disguised. \\
    \fn{StartDisguise($d$, Option<$p$>)} & Begins the process of applying disguise $d$, optionally 
    on behalf of $p$.\\
    \fn{StartDisguiseReversal($d$, Option<$p$>)} & Begins the process of reversing disguise $d$,
    optionally on behalf of $p$.\\
    \fn{RequestTokenAccess(encSymKeys)} & Sent from \sys to a client authenticated as
    $p$, requesting the client decrypt all the encrypted symmetric keys in \fn{encSymKeys} with
    \privk{p} and uncover the corresponding \symk{pd}s. \\
    \fn{GrantTokenAccess(\{\symk{pd}\})} & Grants \sys permission, for all \symk{pd} in the
    argument, to decrypt any privately-stored \tdata{pd} and \tpriv{pdq} with \symk{pd}.
\end{tabular}
    \vspace{12px}
\caption{API Calls for Client Authenticated as Principal $p$}
\label{tab:api}
\end{table*}

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.7\linewidth} }
\textbf{Function} & \textbf{Description} \\
\hline
    \fn{ReadPrivateTokens(\symk{pd})} & Decrypts all of $p$'s private tokens produced by disguise
    $d$ using \symk{pd}. \\
    \fn{ReadGlobalTokens($d$)} & Retrieves all global tokens produced by disguise $d$. \\
    \fn{ApplyDisguise($d$,tokens)} & Applies disguise $d$, selectively composing $d$'s
    updates with prior disguises using the tokens's data. \\
    \fn{\op{d}.execute(tokens)} & Executes the disguise operation \op{d}, composing the operation
    with prior disguises using the tokens' data.\\
    \fn{ReverseDisguise($d$,tokens)} & Reverses disguise $d$ using the tokens' data.\\
    \fn{ReverseTokenOp(token)} & Reverses the data modification performed by the disguise operation
    that produced the token.\\
    \fn{StorePubKey($\pubk{p}$)} & Persistently saves the public key \pubk{p} indexed by $p$.\\
    \fn{LoadPubKey($p$)} & Retrieves public key \pubk{p} for $p$.\\
    \fn{LoadEncSymKey($p,d$)} & Retrieves \symk{pd} ciphertext.\\
    \fn{LoadEncSymKeys($p$)} & Retrieves \symk{pd} ciphertexts for all previously applied disguises $d$.\\
    \fn{StoreEncSymKey($p,d$)} & Persistently saves the \symk{pd} ciphertext indexed by $p$ and $d$.\\
    %\fn{VerifySymKey($p,d$,symKey)} & Verifies that the symmetric key plaintext has not been falsified by the client\\
    \fn{LoadListTail}$(p,d)$ & Gets the first encrypted private token in \tokls{pd}, the list of
    tokens associated with $p$ produced by $d$.\\
    \fn{StoreListTail}$(p,d)$ & Persistently saves the first encrypted private token in \tokls{pd}
    indexed by $p$ and $d$.
\end{tabular}
    \vspace{12px}
\caption{Internal \sys functions}
\label{tab:funcs}
\end{table*}

Table~\ref{tab:api} describes all the API calls used in protocols between \sys and a client.
These protocols also illustrate the internal functions fun server-side when the protocol occurs
(described in Table~\ref{tab:funcs}).

Figure~\ref{fig:acctreg} illustrates the principal registration protocol: every principal in the
system must register a public key with \sys in order to later reveal (for disguise reversal or
composition) any of privately disguised data. \sys remembers each public key \pubk{p} along with
$p$'s ID.

Figures~\ref{fig:authdisapp} and \ref{fig:unauthdisapp} illustrate the protocols for authenticated
and unauthenticated disguise application respectively. Authenticated and unauthenticated disguise
reversal protocols follow the same logic as disguise application protocols, with the only
differences being the API call invoked by the client (\fn{StartDisguiseReversal($d$)}) and the
function that \sys calls at the end (\fn{ReverseDisguise($d$ tokens)}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[h!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\texttt{RegisterPrincipal(p,$\pubk{p}$)}} \< \\
\<\< \texttt{StorePubKey($\pubk{p}$)}
}
\caption{\textbf{Principal public key registration.}}
\label{fig:acctreg}
\end{figure*} 


\begin{figure*}[h]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \< \sendmessageright*{\fn{StartDisguise($d$)}} \< \\
\<\< \fn{symKeyCiphertxts} \gets \fn{LoadEncKeys}(p)\\
\< \sendmessageleft*{\fn{RequestTokenAccess(symKeyCiphertxts)}} \< \\
\texttt{symKeys} \gets \{\}\\
\pcforeach \fn{encSymKey} \in \fn{symKeyCiphertxts}:\\
\quad \symk{pd'} \gets \dec(\privk{p}, \fn{encSymKey})\\
\quad \pcif \text{authorizes access to $d'$-produced tokens}: \\
    \quad\quad\texttt{symKeys.insert(\symk{pd'})} \<\< \\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\texttt{GrantTokenAccess(\texttt{symKeys})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \texttt{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \pcforeach \symk{pd'} \in \texttt{symKeys}: \\
\<\< \quad\texttt{tokens.insert(\fn{ReadPrivateTokens(\symk{pd'})})}\\ 
\<\< \pcendforeach\\
\<\< \texttt{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Authenticated disguise application.} 
The client first invokes the \fn{StartDisguise} API call, authenticated as principal $p$.  
    Prior to applying the disguise, \sys requests to access $p$'s private tokens by sending a
    \fn{RequestTokenAccess} to the client with all \symk{pd} ciphertexts for all $d$ in the disguise
    history.  \\
    The client decrypts the ciphertexts if it has $p$'s private key \privk{p} (proving
    that the client has access to $p$'s private tokens).  \\
    The client only includes the decrypted \symk{pd'} in the set of keys sent back to \sys via a
    \fn{GrantTokenAccess} API call if the client wants to authorizes access to $p$'s private tokens
    from disguise $d'$. \\
    \sys uses each \symk{pd'} to decrypt $p$'s private tokens produced by disguise $d'$. 
    \sys combines all decrypted private tokens with the set of globally accessible tokens to produce
    all tokens available for disguise composition of $d$ on top of $d'$. 
    \lyt{Note: this requires that a client be authenticated as $p$ to access $p$'s tokens, which
    isn't necessarily fundamental.}}
    \label{fig:authdisapp}
\end{figure*}

\begin{figure*}[h]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Unauthenticated Client} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\fn{StartDisguise($d$)}} \< \\
\<\< \texttt{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \texttt{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Unauthenticated disguise application}. In contrast to authenticated disguise
    application, \sys does not request access to any private tokens, and instead simply applies the disguise  
    with only globally-accessible tokens.}
    \label{fig:unauthdisapp}
\end{figure*}


