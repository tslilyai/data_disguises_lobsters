%-------------------------------------------------------------------------------
\section{\sys API Calls}
%-------------------------------------------------------------------------------
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.6\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($\pubk{p}$)} & Registers $p$ as a principal whose data can be privately disguised. \\
    \fn{StartDisguise($d$, Option<$p$>)} & Begins the process of applying disguise $d$, optionally 
    on behalf of $p$.\\
    \fn{StartDisguiseReversal($d$, Option<$p$>)} & Begins the process of reversing disguise $d$,
    optionally on behalf of $p$.\\
    \fn{RequestTokenAccess(encSymKeys)} & Sent from \sys to a client authenticated as
    $p$, requesting the client decrypt all the encrypted symmetric keys in \fn{encSymKeys} with
    \privk{p} and uncover the corresponding \symk{pd}s. \\
    \fn{GrantTokenAccess(\{\symk{pd}\})} & Grants \sys permission, for all \symk{pd} in the
    argument, to decrypt any privately-stored \tdata{pd} and \tpriv{pdq} with \symk{pd}.
\end{tabular}
    \vspace{12px}
\caption{API Calls for Client Authenticated as Principal $p$}
\label{tab:api}
\end{table*}

Table~\ref{tab:api} describes all the API calls used in protocols between \sys and a client.
\lyt{Not sure if the admin- vs. user-authenticated client distinction is clear here..}

\head{Principal Public Key Registration.}
Figure~\ref{fig:acctreg} illustrates the principal registration protocol: every principal in the
system must register a public key with \sys in order to later reveal (for disguise reversal or
composition) any of privately disguised data. \sys remembers each public key \pubk{p} along with
$p$'s ID.

 User-authenticated and admin-authenticated disguise
reversal protocols follow the same logic as disguise application protocols, with the only
differences being the API call invoked by the client (\fn{StartDisguiseReversal($d$,Some($p$))}) and the
function that \sys calls at the end (\fn{ReverseDisguise($d$,tokens)}).

\head{PseudoPrincipal Private Key Retrieval.}

\head{User-Authenticated Disguise Application.}
Figure~\ref{fig::userauthdisapp} illustrates the protocol for user-authenticated disguise application.
%
The client first invokes the \fn{StartDisguise} API call, user-authenticated as principal $p$.  
%
Prior to applying the disguise, \sys requests to access $p$'s private tokens by sending a
\fn{RequestTokenAccess} to the client with all \symk{pd} ciphertexts for all $d$ in the disguise
history. 
%
The client decrypts the ciphertexts if it has $p$'s private key \privk{p} (proving
that the client has access to $p$'s private tokens). 
%
The client only includes the decrypted \symk{pd'} in the set of keys sent back to \sys via a
\fn{GrantTokenAccess} API call if the client wants to authorizes access to $p$'s private tokens
from disguise $d'$. 
%
\sys uses each \symk{pd'} to decrypt $p$'s private tokens produced by disguise $d'$. Note that
if the client returns a false \symk{pd'}, the decryption will fail, and \sys will not reveal any
$p$'s private tokens from $d'$.
%
\sys combines all decrypted private tokens with the set of globally accessible tokens to produce
all tokens available for disguise composition of $d$ on top of $d'$. 
%
\lyt{Note: this requires that a client be user-authenticated as $p$ to access $p$'s tokens, which
isn't necessarily fundamental.}

\head{Admin-Authenticated Disguise Application.}
In contrast to user-authenticated disguise application, \sys does not request access to any private
tokens, and instead simply applies the disguise with only globally-accessible tokens (shown in Figure~\ref{fig:adminauthdisapp}).

\begin{figure*}[h!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\fn{RegisterPrincipal(p,$\pubk{p}$)}} \< \\
\<\< \fn{StorePubKey($\pubk{p}$)}
}
\caption{\textbf{Principal public key registration.}}
\label{fig:acctreg}
\end{figure*} 

\begin{figure*}[h]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\fn{privKs} \gets \{p \mapsto \privk{p}\}\\
\fn{idsToProcess} \gets \{p\}\\
\fn{principalIds} \gets \{\}\\
\pcwhile \fn{idsToProcess} \neq \{\}:\\
\quad q \gets \fn{idsToProcess.pop()}\\
\< \sendmessageright*{\fn{LinkedPseudoPKeysRequest($d$,$q$)}} \< \\
\<\< \fn{encPrivKs} \gets \fn{LoadEncPrivKTokens}(q)\\
\< \sendmessageleft*{\fn{LinkedPseudoPKeysResponse(encPrivKs)}} \< \\
\quad \pcforeach \fn{encPrivK} \in \fn{encPrivKs}:\\
\quad \quad \privk{q} \gets \fn{privKs}[q]\\
\quad \quad \tpriv{qd'r} \gets \dec(\privk{q}, \fn{encPrivK})\\
\quad \quad \pcif \text{authorizes access to $r$'s private tokens}: \\
\quad \quad\quad\fn{privKs.insert}(r\mapsto \tpriv{qd'r}.\fn{privKey}) \<\< \\
\quad \quad\quad\fn{idsToProcess.insert($r$)} \<\< \\
\quad \quad\pcfi\\
\quad \fn{principalIds.append($q$)}\\
\quad \pcendforeach\\
\pcendwhile
}
\caption{\textbf{PseudoPrincipal Key Retrieval.}}
\label{fig:userprivkeyretrieval}
\end{figure*}

\begin{figure*}[h]
\pcb{
\<\< \\[-1\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]\\
\texttt{//perform pseudoprincipal key retrieval}\\
\fn{caps} \gets \{\}\\
\pcforeach \rptr{pd'} \in \fn{client.Capabilities}:\\
\quad \pcif \text{authorizes access to $d'$ tokens for $p$}: \\
\quad\quad\fn{caps.insert(\rptr{pd'})} \<\< \\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{StartDisguise($d$,principalIds,caps)}} \< \\
\<\< \fn{symKeyEncs} \gets \{\}\\
\<\< \pcforeach q \in \fn{principalIds}:\\
\<\< \quad\pcif q = p:\\
    \<\< \quad\quad\fn{symKeyEncs.insert(}\\
    \<\< \quad\quad\quad\quad \fn{LoadEncSymKeys(caps))}\\
\<\< \quad\pcelse:\\
\<\< \quad\quad\fn{pseudoPCaps} \gets \fn{\sys.PseudoPCaps[q]}\\
\<\< \quad\quad\fn{symKeyEncs.insert(}\\
\<\< \quad\quad\quad\quad \fn{LoadEncSymKeys(pseudoPCaps))}\\
\<\< \quad\pcendif\\
\<\< \pcendforeach\\
\< \sendmessageleft*{\fn{RequestTokenAccess(symKeyEncs)}} \< \\
\fn{symKeys} \gets \{\}\\
\pcforeach \fn{encSymKey} \in \fn{symKeyEncs}:\\
\quad q \gets \fn{encSymKey.principalId}\\
\quad d' \gets \fn{encSymKey.disguiseId}\\
\quad \privk{q} \gets \fn{privKeys}[q]\\
\quad \pcif \text{authorizes access to $d'$ tokens for $q$}: \\
\quad\quad \fn{symKeys.insert(\dec(\privk{q}, \fn{encSymKey})}\\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{GrantTokenAccess(\fn{symKeys})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
    \<\< \quad\fn{tokens.insert(}\\
    \<\<\quad\quad\fn{ReadGlobalTokens}(d'))\\ 
\<\< \pcendforeach\\
\<\< \pcforeach \symk{qd'} \in \fn{symKeys}: \\
\<\< \quad\fn{tokens.insert(}\\
\<\< \quad \quad \fn{ReadPrivateTokens(\symk{qd'}))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{User-Authenticated disguise application.}}
    \label{fig:userauthdisapp}
\end{figure*}

\begin{figure*}[h]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Admin-authenticated Client} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\fn{StartDisguise($d$,None)}} \< \\
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\fn{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Admin-authenticated disguise application}. }
    \label{fig:adminauthdisapp}
\end{figure*}

