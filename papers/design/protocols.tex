%-------------------------------------------------------------------------------
\section{\sys API Calls}
%-------------------------------------------------------------------------------
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.6\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \vspace{6pt}
    \fn{RegisterPrincipal($\pubk{p}$)} & Registers $p$ as a principal whose data can be privately disguised. \\
    \vspace{6pt}
    \fn{PseudoPrincipalKeysRequest($p$)} & Requests the encrypted private keys of pseudoprincipals
    created by decorrelating data from $p$.\\
    \vspace{6pt}
    \fn{PseudoPrincipalKeysResponse(encPrivKs)} & Sent from \sys to the client authenticated as $p$ with the set of encrypted
    private keys of pseudoprincipals linked to $p$.\\
    \vspace{6pt}
    \fn{StartDisguise($d$, caps, ppIds)} & Begins the process of applying disguise
    $d$, granting \sys access to prior disguised data of $p$'s with the provided capabilities in
    \texttt{caps}, and access to prior disguised data of any pseudoprincipals in \texttt{ppIds}.\\
    \vspace{6pt}
    \fn{StartDisguiseReversal($d$, caps, ppIds)} & Begins the process of reversing disguise $d$,
    granting \sys access to prior disguised data of $p$'s with the provided capabilities in \texttt{caps}, and access to prior disguised data of any pseudoprincipals in \texttt{ppIds}.\\
    \vspace{6pt}
    \fn{RequestTokenAccess(encSymKeys)} & Sent from \sys to a client authenticated as
    $p$, requesting the client decrypt all the encrypted symmetric keys in \fn{encSymKeys} with
    \privk{p} and uncover the corresponding \symk{pd}s. \\
    \vspace{6pt}
    \fn{GrantTokenAccess(\{\symk{pd}\})} & Grants \sys permission, for all \symk{pd} in the
    argument, to decrypt any privately-stored \tdata{pd} and \tpriv{pdq} with \symk{pd}.
\end{tabular}
    \vspace{6px}
\caption{API Calls for Client Authenticated as Principal $p$}
\label{tab:api}
\end{table*}

Table~\ref{tab:api} describes all the API calls used in protocols between \sys and a client.
\lyt{Not sure if the admin- vs. user-authenticated client distinction is clear here..}

\head{Principal Public Key Registration.}
Figure~\ref{fig:acctreg} illustrates the principal registration protocol: every principal in the
system must register a public key with \sys in order to later reveal (for disguise reversal or
composition) any of privately disguised data. \sys remembers each public key \pubk{p} along with
$p$'s ID.

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\fn{RegisterPrincipal(p,$\pubk{p}$)}} \< \\
\<\< \fn{StorePubKey($\pubk{p}$)}
}
\caption{\textbf{Principal public key registration.}}
\label{fig:acctreg}
\end{figure*} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{PseudoPrincipal Private Key Retrieval.}
Figure~\ref{fig:userprivkeyretrieval} illustrates the protocol by which a client, authenticated as
principal $p$, can gain access to the private keys (and thus the tokens) of pseudoprincipals created
from decorrelating $p$'s data.

The client sends a request to \sys for the private keys of pseudoprincipals linked to $p$. \sys
loads the encrypted private key tokens for $p$, and sends these back in a response to the client.
%
The client then decrypts these tokens with \privk{p}, and saves the mapping from pseudoprincipal ID
$q$ to private key \privk{q} encoded in the token.

The client recursively retrieves the private keys of all pseudoprincipals linked to $q$ until
no more nested pseudoprincipals exist.

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\fn{privKs} \gets \{p \mapsto \privk{p}\}\\
\fn{idsToProcess} \gets \{p\}\\
\fn{ppIds} \gets \{\}\\
\pcwhile \fn{idsToProcess} \neq \{\}:\\
\quad q \gets \fn{idsToProcess.pop()}\\
\< \sendmessageright*{\fn{PseudoPrincipalKeysRequest($q$)}} \< \\
\<\< \fn{encPrivKs} \gets \fn{LoadEncPrivKTokens}(q)\\
\< \sendmessageleft*{\fn{PseudoPrincipalKeysResponse(encPrivKs)}} \< \\
\quad \pcforeach \fn{encPrivK} \in \fn{encPrivKs}:\\
\quad \quad \privk{q} \gets \fn{privKs}[q]\\
\quad \quad \tpriv{qd'r} \gets \dec(\privk{q}, \fn{encPrivK})\\
\quad \quad \pcif \text{authorizes access to $r$'s private tokens}: \\
\quad \quad\quad\fn{privKs.insert}(r\mapsto \tpriv{qd'r}.\fn{privKey}) \<\< \\
\quad \quad\quad\fn{idsToProcess.insert($r$)} \<\< \\
\quad \quad\pcfi\\
\quad \pcif q \neq p:\\
\quad\quad \fn{ppIds.append($q$)}\\
\quad \pcfi\\
\quad \pcendforeach\\
\pcendwhile
}
\caption{\textbf{PseudoPrincipal Key Retrieval.}}
\label{fig:userprivkeyretrieval}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{User-Authenticated Disguise Application.}
Figure~\ref{fig:userauthdisapp} illustrates the protocol for user-authenticated (as principal $p$) disguise application.

The client first performs pseudoprincipal private key retrieval for $p$, and retrieves all capabilities from
prior disguises for which the client grants token access.
%
The client then invokes \fn{StartDisguise} with these capabilities and the set of pseudoprincipals.

\sys takes the capabilities of $p$ and the public capabilities of all pseudoprincipals in the
provided set, and retrieves the corresponding encrypted \symk{}s.
\sys then requests to access all private tokens protected by these symmetric keys by sending a
\fn{RequestTokenAccess} to the client with the \symk{} ciphertexts.

The client decrypts the ciphertexts using the appropriate \privk{q} (proving
that the client has access to $q$'s private tokens). 
%
The client only includes the decrypted \symk{qd'} in the set of keys sent back to \sys via a
\fn{GrantTokenAccess} API call if the client wants to authorizes access to $q$'s private tokens
from disguise $d'$. 

\sys then uses each \symk{qd'} to decrypt $q$'s private tokens produced by disguise $d'$. Note that
if the client returns a false \symk{qd'}, the decryption will fail, and \sys will not reveal any
$q$'s private tokens from $d'$.

\sys combines all decrypted private tokens with the set of globally accessible tokens to produce
all tokens available to apply disguise $d$. 

\lyt{Note: this requires that a client be user-authenticated as $p$ to access $p$'s tokens, which
isn't necessarily fundamental.}

\begin{figure*}[t!]
\pcb{
\<\< \\[-1\baselineskip]\\
\textbf{Client User-Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]\\
\texttt{//perform pseudoprincipal key retrieval}\\
\fn{caps} \gets \{\}\\
\pcforeach \rptr{pd'} \in \fn{client.Capabilities}:\\
\quad \pcif \text{authorizes access to $d'$ tokens for $p$}: \\
\quad\quad\fn{caps.insert(\rptr{pd'})} \<\< \\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{StartDisguise($d$,caps,ppIds)}} \< \\
\<\< \fn{symKeyEncs} \gets \{\}\\
    \<\< \fn{symKeyEncs.insert(LoadEncSymKeys(caps))}\\
\<\< \pcforeach q \in \fn{ppIds}:\\
\<\< \quad\quad\fn{ppCaps} \gets \fn{\sys.PseudoPCaps[q]}\\
\<\< \quad\quad\fn{symKeyEncs.insert(}\\
\<\< \quad\quad\quad\quad \fn{LoadEncSymKeys(ppCaps))}\\
\<\< \quad\pcendif\\
\<\< \pcendforeach\\
\< \sendmessageleft*{\fn{RequestTokenAccess(symKeyEncs)}} \< \\
\fn{symKeys} \gets \{\}\\
\pcforeach \fn{encSymKey} \in \fn{symKeyEncs}:\\
\quad q \gets \fn{encSymKey.principalId}\\
\quad d' \gets \fn{encSymKey.disguiseId}\\
\quad \privk{q} \gets \fn{privKeys}[q]\\
\quad \pcif \text{authorizes access to $d'$ tokens for $q$}: \\
\quad\quad \fn{symKeys.insert(\dec(\privk{q}, \fn{encSymKey})}\\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\fn{GrantTokenAccess(\fn{symKeys})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
    \<\< \quad\fn{tokens.insert(}\\
    \<\<\quad\quad\fn{ReadGlobalTokens}(d'))\\ 
\<\< \pcendforeach\\
\<\< \pcforeach \symk{qd'} \in \fn{symKeys}: \\
\<\< \quad\fn{tokens.insert(}\\
\<\< \quad \quad \fn{ReadPrivateTokens(\symk{qd'}))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{User-Authenticated disguise application.}}
    \label{fig:userauthdisapp}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Admin-Authenticated Disguise Application.}
In contrast to user-authenticated disguise application, \sys does not request access to any private
tokens, and instead simply applies the disguise with only globally-accessible tokens (shown in Figure~\ref{fig:adminauthdisapp}).

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Admin-authenticated Client} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \< \sendmessageright*{\fn{StartDisguise($d$,\{\},\{\})}} \< \\
\<\< \fn{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\fn{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \fn{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Admin-authenticated disguise application}. }
    \label{fig:adminauthdisapp}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Disguise Reversal.}
User- and admin-authenticated disguise
reversal protocols follow the same logic as disguise application protocols, with the only
differences being the API call invoked by the client 
(\fn{StartDisguiseReversal}\fn{($d$,caps,ppIds)}) and the
function that \sys calls at the end (\fn{ReverseDisguise} \fn{($d$,tokens)}).


