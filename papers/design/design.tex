%-------------------------------------------------------------------------------
\section{System Components}
%-------------------------------------------------------------------------------
\begin{itemize}
\item Disguising Tool (``Edna''): adds support for disguise API calls to applications.
\item Principal: an application user account that owns DB objects that are correlated via e.g., foreign key relationships to the account.
\item Client: external devices that contact the application via the application API, and can be authenticated to speak for one or more principals via the application authentication protocol (e.g., logging in with a password, or using access tokens to establish a session).
\item Tokens: 
\begin{itemize}
    \item Correlation tokens (linking an old principal to a created principal from disguise decorrelation operations). These tokens give Edna the ability to disguise the data of these principals when disguising the data of P, or to permanently recorrelate data back with P.
    \item Data tokens save the pre-modified or removed data. These tokens give Edna the ability to compose a future disguise on top of the original data, or permanently restore the original data.
    \item Private key tokens save the private key of a created anonymous principal
\end{itemize}
\item Disguise Capabilities have two forms, and can be held by a 1st-party (a client acting on
behalf of a principal) or 3rd-party (e.g., the application).
\begin{itemize}
\item Application Capability: authorizes the holder to apply a disguise.
\item Revealing Capability: authorizes the holder to reveal disguised data.
\end{itemize}
If a disguise is 1st-party-revealable, no 3rd-party actor can reveal data disguised when applying the
disguise.
If a disguise is 3rd-party-revealable, both 1st- and 3rd-party actors can reveal data disguised when applying the
disguise.
\end{itemize}

%-------------------------------------------------------------------------------
\section{Threat Model}
%-------------------------------------------------------------------------------
An adversary can access any data stored as plaintext by the application or Edna, including data not exposed via its
client-facing API. We assume that an adversary cannot access prior snapshots of the application database, or observe modifications or memory accesses performed during disguise application. Furthermore, undisguised content and implicit correlations based on this content (e.g., a comment that mentions the authorâ€™s name) are out of scope.

We assume Edna is honest but curious: when applying or reversing a disguise, Edna may temporarily
hold (in memory) plaintext token data, as well as private or symmetric keys, but is trusted to
forget them once the disguise action is complete.  

Finally, we assume standard security of public key and
symmetric key primitives~\note{under a random oracle model?}.

%-------------------------------------------------------------------------------
\section{Client-Edna Protocols}
%-------------------------------------------------------------------------------
\createpseudocodeblock{pcb}{center,boxed}{}{}{}
\createprocedureblock{procb}{center,boxed}{}{}{}

\begin{figure}[h!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{1stParty c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
(\pk_c, \sk_c) \sample \kgen() \<\< \\
\< \sendmessageright*{\texttt{RegisterClient(c, $\pk_c$)}} \< \\
\<\< \texttt{StorePubKey($\pk_c$)}
}
\caption{1p protocol for public key registration}
\label{fig:acctreg}
\end{figure}

\paragraph{1p Public Key Registration.}
Every principal in the system must register a public key with Edna in order to later reveal (for
disguise reversal or composition) any of its data disguised by 1p-revealable disguises
(Fig~\ref{fig:acctreg}). Edna remembers each public key \texttt{pk}$_c$, indexed by the 
principal ID $c$.

\paragraph{1p Disguise Application.}
When a 1st party (authenticated as some principal $c$) wishes to apply a disguise $d$, the
client invokes the \texttt{ApplyDisguise} API call. 

Prior to applying the disguise, Edna requests access to tokens owned by the client. It does so by
sending a \texttt{AuthorizeToken}-\texttt{AccessRequest} to the invoking client $c$ with the all ciphertexts of 
encrypted symmetric keys \texttt{enck}$_{cd'}$ from all prior disguises $d'$. If the client
authorizes Edna to access its tokens from disguise $d'$, the client decrypts \texttt{enck}$_{cd'}$
to get \texttt{k}$_{cd'}$. All plaintext symmetric keys are sent back to Edna via an
\texttt{AuthorizeTokenAccessReply}. 
Using each \texttt{k}$_{cd'}$, Edna can decrypt the tokens produced by disguise $d'$ and use them
in disguise composition when applying disguise $d$ (See Fig~\ref{fig:algos} for a description of Edna's
token retrieval and disguise application algorithms).

Fig~\ref{fig:disgapp1p} illustrates this protocol.

\paragraph{3p Disguise Application.}
When a 3rd party wishes to apply a disguise $d$, a third party cannot authorize access to any encrypted user data tokens, so Edna does not
send a \texttt{AuthorizeToken}\texttt{AccessRequest}. Instead, Edna simply applies the disguise  
without any keys to decrypt tokens (See Fig~\ref{fig:algos} for a description of Edna's
token retrieval and disguise application algorithms).

Fig~\ref{fig:disgapp3p} illustrates this protocol.

\paragraph{1p Disguise Reversal.}
When a 1st party (authenticated as some principal $c$) wishes to reverse a disguise $d$, the client
invokes the \texttt{ReverseDisguise} API call. Edna then retrieves all tokens of the client's that
it can access for all disguises up to and including $d$. It does so by sending a
\texttt{AuthorizeToken}\texttt{AccessRequest} to the invoking client $c$ with the all ciphertexts of
encrypted symmetric keys \texttt{enck}$_{cd'}$ from all disguises $d'$ before and including $d$. If
the client authorizes Edna to access its tokens from disguise $d'$, the client decrypts
\texttt{enck}$_{cd'}$ to get \texttt{k}$_{cd'}$. All plaintext symmetric keys are sent back to Edna
via an \texttt{AuthorizeToken}-\texttt{AccessReply}. 

Using each \texttt{k}$_{cd'}$, Edna can decrypt the tokens produced by disguise $d'$ and use them to
reverse the disguise $d$ (See Fig~\ref{fig:algos} for a description of Edna's token retrieval and
disguise reversal algorithms).

Fig~\ref{fig:revdisg1p} illustrates this protocol.

\paragraph{3p Disguise Reversal.}
When a 3rd party wishes to reverse a disguise $d$, Edna can only access those tokens stored as
plaintext. 
Fig~\ref{fig:revdisg3p} shows the protocol to reverse a disguise when a disguise is 1p-revealable.


\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{1stParty c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ApplyDisguise(c,d)}} \< \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\sk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{composition\_tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ApplyDisguise($d$,composition\_tokens)}
}
\caption{1p protocol for disguise application}
\label{fig:disgapp1p}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{3rdParty} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ApplyDisguise(*,d)}} \< \\
\<\< \texttt{composition\_tokens} \gets \texttt{ReadTokens([]))} \\
\<\< \texttt{ApplyDisguise($d,$composition\_tokens)}
}
\caption{3p protocol for disguise application}
\label{fig:disgapp3p}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{1stParty c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ReverseDisguise(c,d)}} \< \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\sk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ReverseDisguise($d$,tokens)}
}
\caption{1p protocol for disguise reversal}
\label{fig:revdisg1p}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{3rdParty} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ReverseDisguise(*,d)}} \< \\
\<\< \texttt{tokens} \gets \texttt{ReadTokens([]))} \\
\<\< \texttt{ReverseDisguise($d$,tokens)}
}
\caption{3p protocol for disguise reversal}
\label{fig:revdisg3p}
\end{figure*}

%-------------------------------------------------------------------------------
\subsection{Algorithms}
%-------------------------------------------------------------------------------
\paragraph{ReadTokens.} Edna is given a set of plaintext symmetric keys, indexed by principal and disguise
ID. For each key \texttt{key}$_{cd}$, Edna decrypts all tokens produced by the application of disguise
$d$ to principal $c$'s data with \texttt{key}$_{cd}$. 

If the token stores \texttt{sk}$_{c'}$, the private key of a
anonymous principal $c'$ generated during $d$'s application, Edna decrypts with \texttt{sk}$_{c'}$
all the symmetric keys produced when disguising $c'$'s data. Edna then recursively uses these
symmetric keys to read all of $c'$'s tokens, appending the result to the set of tokesn to
return.

Otherwise, Edna simply adds the token to the set of tokens to return. 

This is shown in Fig~\ref{fig:algos}.

\lyt{I should maybe add another subfunction of ApplyDisguise that shows how exactly
disguise operations produce various types of tokens, such as these private key tokens.}

\paragraph{ApplyDisguise.} Edna applies a disguise given the disguise specification and available tokens
for composition by interating through all disguise operations in the specification.

For each principal $c$ whose data is touched by the disguise, Edna generates a principal- and disguise-specific symmetric key \texttt{k}$_{cd}$, encrypts it with \texttt{pk}$_c$, and stores the ciphertext. This ensures that only a client with the correct private key can decrypt and access
\texttt{k}$_{cd}$. 

Edna then applies each disguise operation, producing tokens for each operation. If the disguise is
1p-revealable, Edna encrypts tokens with the corresponding principals' \texttt{k}$_{cd}$s and stores
these tokens as the tails of the principals' linked list of
encrypted tokens. This is shown in Fig~\ref{fig:algos}.

If the disguise is 3p-revealable, Edna simply stores the token plaintexts.


\begin{figure*}
\procb{\texttt{ReadTokens(keys)}}{
    \< \\
\texttt{tokens} \gets []\\
\pcfor \texttt{$\key_{cd}$ in keys:} \\
\t[1]\texttt{encToken} \gets \texttt{LoadEncTokenListTail}(c,d)\\
\t[1]\pcwhile \texttt{encToken != NULL:}\\
\t[2]\texttt{token} \gets \dec(\key_{cd}, \texttt{encToken})\\
\t[2]\texttt{encToken} \gets \texttt{token.nextEncToken}\\
\t[2]\pcif \texttt{token.type = AnonPrivateKey:}\\
\t[3]c' \gets \texttt{token.anon\_uid}\\
\t[3]\sk_{c'} \gets \texttt{token.priv\_key}\\
\t[3]\texttt{keys}' \gets []\\
\t[3]\pcforeach d':\\
\t[4]\texttt{enck} \gets \texttt{LoadEncKey}(c',d')\\
\t[4]\texttt{keys}'\texttt{.append}(\dec(\sk_{c'}, \texttt{enck}))\\
\t[4]\texttt{tokens.extend(ReadTokens(keys}'))\\
\t[3]\pcendforeach\\
\t[2]\pcelse:\\
\t[3]\texttt{tokens.append(token)}\\
\t[2]\pcfi\\
\t[1]\pcendwhile\\
\pcendfor\\
\texttt{tokens.append(GetGlobalTokens())}\\
\pcreturn \texttt{tokens}\\
}{}

\procb{\texttt{ApplyDisguise}$(d$,\texttt{composition\_tokens})}{
    \< \\
\t[0]\pcfor \texttt{op}_{c} \in \texttt{GetDisguise($d$)}:\\
\t[1]\pcif \texttt{LoadEncKey($c,d$) = NULL}:\\
\t[2] \key_{cd} \sample \kgen() \\
\t[2] \pk_{c} \gets \texttt{LoadPubKey}(c) \\
\t[2] \texttt{enck$_{cd}$} \gets \enc(\pk_c, \key_{cd}) \\
\t[2] \texttt{StoreEncKey(enck$_{cd}$)} \\
\t[1]\pcfi\\
\t[1]\key_{ck} \gets \texttt{LoadEncKey($c,d$)}\\
\t[1]\texttt{token} \gets \texttt{op$_{c}$.execute(composition\_tokens)}\\
\t[1]\texttt{token.nextEncToken} \gets \texttt{LoadEncTokenlistTail}(c,d)\\
\t[1]\texttt{token.nonce} \gets \texttt{RandomU64}()\\
\t[1]\texttt{encToken} \gets \enc(\key_{cd}, \texttt{token})\\
\t[1]\texttt{StoreEncTokenListTail}(c,d,\texttt{encToken})\\
\pcendfor
}{}

\procb{\texttt{ReverseDisguise}$(d$,\texttt{tokens})}{
    \< \\
    \texttt{Apply missed updates from disguise log to tokens of disguise $d$}\\
    \texttt{Reveal data in tokens of disguise $d$}\\
    \texttt{Undo modifications to any prior disguise's tokens by disguise $d$}
}{}

\caption{Edna Algorithms (assuming all tokens are user-vault encrypted tokens, and ignoring global vault tokens for now)}
\label{fig:algos}
\end{figure*}
