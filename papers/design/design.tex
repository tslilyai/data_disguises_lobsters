%-------------------------------------------------------------------------------
\section{Design} 
%-------------------------------------------------------------------------------

\subsection{Disguise Specifications.} 
Because disguises are inherently application-specific, the application developer provides disguise
specifications that consist of a set of predicated disguise operations \op{d} to perform during the
disguise.

Operations \op{d} of disguise $d$ take data objects as input and execute updates to application
data.  \sys automatically generates database change records when applying \op{d}. 

Developers describe in the specification which principals an operation's generated database change
record corresponds to.  For example, a database change record generated by removing comment may
correspond to the principal whose ID is referenced by the author column.  
%A disguise specification also includes whether tokens produced by disguise application are

Developers also specify an application-aware pseudoprincipal generation policy, namely how to
generate new user accounts in a manner that the application can handle (e.g., pseudoprincipals may
not have email addresses).

\vspace{6pt}\noindent
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.
\end{enumerate}

\noindent For each \op{d}, the application developer specifies:
\begin{itemize}
    \item An associated predicate over the application database that selects \op{d}'s input
        objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The corresponding principal(s) that should have the capability to access \op{d}'s
        generated disguise change or correlation record.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\noindent\textbf{\emph{Decorrelation and Locked Private Keys.}}
Decorrelation generates a public-private key pair \pubk{q} and \privk{q} for pseudoprincipal $q$
created during decorrelation.
\sys stores \pubk{q} associated with $q$'s user ID, and puts \privk{q} in a \emph{locked private key}
associated with the original principal $p$ and $q$, notated as \tpriv{p}{q}. \tpriv{p}{q} contains the
following fields, encrypted with \pubk{p}:
\begin{itemize}
\item \fn{principalID}: original principal $p$
\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}
\noindent Because \tpriv{p}{q} is encrypted with \pubk{p}, only a client who has
\privk{p} can access pseudoprincipal $q$'s private key \privk{q}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Database Diffs.}
Every \op{d} produces a \emph{database diff} \tdata{p\delta_i} associated with the disguise instance $\delta$ and a
principal $p$. 
%
\tdata{p\delta_i} contains the following fields, which record any changes made when applying \op{d}:
%
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: ID of disguise $d$ being applied
\item \fn{principalID}: associated principal $p$
\item \fn{objID}: unique ID for the data object modified by \op{d}
\item \fn{updateType}: decorrelate, modify, or remove
\item \fn{oldValue}: original value of object \fn{objID}
\item \fn{newValue}: updated value of object \fn{objID}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent\sys uses \tdata{p\delta_i} to:
\begin{itemize}
    \item Compose updates of $d'$ on top of updates of disguise $d$ to $p$
    \item Reveal updates performed by disguise $d$ to $p$ if no conflicting updates have been
        performed since
\lyt{This is slightly vague and may not handle all situations? \eg if the application made updates
        that don't conflict, but may be dependent on the status of the disguised object}.
\end{itemize}

\subsection{Security and Capabilities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Access to Database Diffs.} 
\sys represents a data capability \dcapa{p\delta_i} as a symmetric key specific to
the disguise instance and principal.
%
\sys protects access to database diffs \tdata{p\delta_i} by encrypting \tdata{p\delta_i} with the
\dcapa{p\delta_i}. The token's nonce ensures safety against known-plaintext attacks. \sys then encrypts
\dcapa{p\delta_i} with public key \pubk{p}.  
%
Thus, only a client who has \privk{p} can decrypt the data capability, and return in the capability pair the plaintext symmetric key that enables \sys to decrypt $p$'s database diffs produced from applying $d$.

%\sys stores all global \tdata{p\delta_i} tokens in plaintext, where any party can access it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Hiding Invoked Disguises Metadata.}
\sys's design may leak information that principal $p$ has been disguised by disguise
$d$ because an adversary may learn that ciphertexts for \dcapa{p\delta_i} and \tdata{p\delta_i} tokens exists for a particular $p$ and $d$.
This is a problem: for example, \sys should not store information that a principal $p$ has
invoked GDPR deletion.

To avoid this problem, \sys stores (1) the \dcapa{p\delta_i} ciphertext and (2) an array of
\tdata{p\delta_i}
ciphertexts at random location addressed by \lcapa{p\delta_i} (e.g., a random number or string).
This dissociates one disguise applied to a principal $p$ from all other disguises, so an adversary only ever
learns about a single disguise if \sys gains permission to reveal or compose upon that disguise.

Note that an adversary can learn the number of \tdata{p\delta_i} tokens for each $p$ and $d$; this
metadata is out of scope of our threat model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{External Storage of \lcapa{p\delta_i}.} 
\sys should not store \lcapa{p\delta_i}: existence of \lcapa{p\delta_i} allows an adversary to
learn that disguise $d$ has applied to principal $p$. Thus, \lcapa{p\delta_i} must be stored externally,
even when no client speaking for $p$ is currently online.

The only exception to this occurs when $p$ is a pseudoprincipal: in this case, \sys saves a (globally
accessible) mapping from $p$ to \lcapa{p\delta_i}; this leaks disguise-principal associations, but only for pseudoprincipals whose data is already decorrelated from their original principal owner.

If $p$ is an actual principal, we consider two options: 
\begin{enumerate}
    \item \sys can email (or otherwise communicate)
\lcapa{p\delta_i} to a party that can authenticate as $p$. If no email is present (\eg $p$ is a pseudoprincipal),
\sys can save a (globally accessible) mapping from $p$ to \lcapa{p\delta_i}; this leaks disguise-principal associations, but
only for pseudoprincipals whose data is already decorrelated from their original principal owner.
\lyt{This assumes that every real user must have an email.}
\item Alternatively, \sys can simply return the addresses back to the application; the application
then must handle the logic of contacting the respective parties and saving addresses externally.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Pseudoprincipal Capabilities}
Because \sys can access locating capabilities \lcapa{q\delta_i}s for pseudoprincipal $q$ without a
client providing it, a client only needs to prove it has \privk{q} to gain \dcapa{qd} for all $d$.
A client that can acquire private key token \tpriv{pq} and decrypt it with \privk{p} can access
\privk{q}, and gain the capability to reveal or compose upon disguises' updates for pseudoprincipals
$q$ of $p$. 

Note that each part of the capability in isolation is insufficient: an attacker who can spoof
\dcapa{p\delta_i} will not be able to access the plaintext of $p$'s records from $d$ without
\privk{p}, although they can learn if $d$ disguised some of $p$'s data.

%-------------------------------------------------------------------------------
\subsection{Does this design achieve our security goals?}
\label{sec:achievegoals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Authorized Disguises.}}
\sys ensures that only properly authenticated clients speaking for authorized principals can apply or
reveal a disguise, achieving security goal (1).

\vspace{6pt}\noindent\textbf{\emph{(2) Secure Linking.}}
\lyt{TODO}

\vspace{6pt}\noindent\textbf{\emph{(3) Secure Disguise Diffs.}}
\sys encrypts \tdata{p\delta_i} diffs associated with $p$ with the data capability \dcapa{p\delta_i}---a symmetric key
specific to each disguise instance $\delta$ and principal $p$. \sys then encrypts \dcapa{p\delta_i} with public key \pubk{p}.  
A client needs to prove it has \privk{p} by return data capability
$\dcapa{p\delta_i}$, which only then allows decryption
of $p$'s records from $\delta_i$, achieving our goal to restrict access to $p$'s disguise diffs.

\vspace{6pt}\noindent\textbf{\emph{(4) Privacy of Disguise History.}}
We describe how \sys hides which disguises affect each principals' data by requiring a client to
provide a locating capability \lcapa{p\delta_i} in order to find encrypted data from disguise $d$ applied
to (non-pseudoprincipal) $p$. Because \sys does not store these locations, and the locationsare per-disguise, \sys
cannot link different disguises' encrypted data to the same principal.

\iffalse
\begin{table}[t!]
\centering
\begin{tabular}{ c | c c }
    & \multicolumn{2}{c}{\textbf{\tdata{p\delta_i} Token Access}}\\
\textbf{Client Proof}& \textbf{Global} & \textbf{Private to $p$}\\
\hline
    $\emptyset$ & plaintext & \\
    \privk{p} & plaintext & \\
    \dcapa{p\delta_i} & plaintext & ciphertext \\
    \privk{p}, \dcapa{p\delta_i} & plaintext & plaintext \\
\end{tabular}
\vspace{6pt}
\caption{Client access to disguise $d$'s tokens, depending on what proof the client can provide and the state of the tokens.}
\label{tab:access}
\end{table}

Table~\ref{tab:access} illustrates which clients can access a disguise $d$'s tokens, depending on
what the client presents as proof, and the state of the tokens.

\sys ensures that private tokens are properly secured such that only a client with private key
\privk{p} and capability \dcapa{p\delta_i} can access tokens produced by disguise $d$ associated with $p$.
%
Furthermore, \sys ensures that only a client with capability \dcapa{p\delta_i} can learn if a disguise $d$
applies to principal $p$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storing \tpriv{pq} Tokens.}
\tpriv{pq} tokens are encrypted with \pubk{p} and the resulting ciphertexts stored in one array
corresponding to the original principal $p$. These token ciphertexts are not separated by disguise
as \tdata{p\delta_i} ciphertexts are, since \tpriv{pq} tokens grant the holder authorization to access
tokens from any disguise for pseudoprincipal $q$.

\sys (and equivalently an attacker) cannot learn which disguises applied to principal $p$ from
observing the array of \tpriv{pq} ciphertexts. However, \sys can learn how many disguises were
applied to---and in particular, decorrelated---$p$'s data, as well as the number of pseudoprincipals
in the system linked to $p$. This metadata is out of scope of our threat model.
\fi
