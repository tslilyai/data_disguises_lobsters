\section{Design} 

\subsection{Disguise Operations} 
Operations \op{d} of disguise $d$ take data objects as input, execute updates to application
data, and produce (\texttt{token, principal}) pairs
as output. This means that the disguise specification determines how tokens correspond to
principals: for example, a comment may correspond to the principal whose ID is referenced by the
author column.
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.

        To support private tokens associated with $q$, decorrelation generates a
        public-private key pair \pubk{q} and \privk{q}.
\end{enumerate}
Every \op{d} has an associated predicate over the application database that selects \op{d}'s input objects.

\subsection{Disguise Tokens} 
Disguise tokens come in two forms: data tokens and privkey tokens.

\vspace{6pt}
\noindent\textbf{\emph{Data Tokens.}}
Every \op{d} produces data tokens associated with the disguise $d$ and a
principal $p$, notated as \tdata{pd}. \tdata{pd} tokens are either private or global depending on
whether the disguise $d$ is global or private. 
\lyt{Note: making explicit decision that global/private is a per-disguise setting. An
admin-authenticated 
client can still apply private disguises, but won't be able to access any non-global tokens.
Furthermore, a private disguise may produce tokens private to many different principals.}

A \tdata{pd} contains the following fields, which record changes performed by \op{d}:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{objID}: unique ID for the data object modified by \op{d}
\item \fn{updateType}: decorrelate, modify, or remove
\item \fn{oldValue}: original value of object \fn{objID}
\item \fn{newValue}: updated value of object \fn{objID}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent\textbf{\emph{PrivKey Tokens.}}
Decorrelation operations generate a second form of token, namely a privkey token associated with the disguise $d$, principal $p$, and the pseudoprincipal $q$ created
during decorrelation (notated as \tpriv{pdq}).
\tpriv{pdq} contains the following fields:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}
\sys always stores \tpriv{pdq} privately and associated with $p$. This ensures that only a client
with access to \privk{p} can access \privk{q} (and therefore access $q$'s private tokens).

\vspace{12pt}
\noindent\textbf{\emph{Enforcing Private Token Access.}}
\sys ensures the security of private disguise data tokens as follows: \sys encrypts private \tdata{pd}
with a symmetric key \symk{pd} specific to the disguise and principal. The
token's nonce ensures safety against known-plaintext attacks. \sys then encrypts \symk{pd} with
public key \pubk{p}.
A client needs to prove it has \privk{p} by decrypting \symk{pd}, 
which then allows \sys to decrypt $p$'s data tokens produced from applying $d$.

%\sys ensures security of \tpriv{pdq} tokens by encrypting them with a special \symk\pubk{p}.

\sys stores all global \tdata{pd} tokens in plaintext, where any party can access it.

\begin{table}[t!]
\centering
\begin{tabular}{ c | c c }
& \multicolumn{2}{c}{\textbf{$d$ Tokens}}\\
\textbf{Client}& \textbf{Global} & \textbf{Private to $p$}\\
\hline
{Authenticated as $q \neq p$} & \checkmark & \\
{Authenticated as $p$} & \checkmark & \checkmark
\end{tabular}
\vspace{6pt}
\caption{Client access to disguise $d$'s tokens, depending the client's authentication and the state of the tokens.}
\label{tab:access}
\end{table}
Table~\ref{tab:access} illustrates which clients can access a disguise $d$'s tokens, depending on
how the client is authorized, and the state of the tokens.

\vspace{12pt}
\noindent\textbf{\emph{Hiding Private Token Metadata.}}
With \sys's design, token metadata about which principals own which tokens can leak in two ways:
\begin{enumerate}
    \item If an adversary learns that \symk{pd} exists for $p$ and $d$, 
        then an adversary knows that $d$ updated some data associated with $p$ (and produced a token
        recording the update)
    \item If an adversary can differentiate between token ciphertexts belonging to different
        principals, then the adversary learns how many tokens belong to each principal.
\end{enumerate}

\noindent
\sys prevents both leakage channels as follows:

\vspace{6pt}\noindent\textbf{(1) \symk{} Storage.}

\emph{Original design}: \sys stores a mapping from $p$ and $d$ to encrypted \symk{pd}.
To ensure that this does not leak metadata about which principals have disguised data, \sys generates dummy ciphertexts for all
principals that do not have encrypted \symk{pd}s for disguise $d$.

Note that if we don't generate dummy ciphertexts, the problem here is that \sys/an attacker can always
learn which and how many disguises applied to $p$'s data.

\vspace{12pt}
\emph{Alternative design 1}:
\sys stores a mapping from $p$ to encrypted \emph{disguise keys}. 
%
Each disguise key, notated \dk{p}, is encrypted with \pubk{p}. 
\sys uses \dk{p} to encrypt the locations of the encrypted \symk{pd} for all $d$ that produced
tokens associated with $p$.
A client must first decrypt (with \privk{p}) and return the \dk{p} plaintext; only then can \sys find the appropriate
encrypted \symk{pd} to send to the client to decrypt with \privk{p}. The plaintext \symk{pd} then allows decryption of
$d$'s tokens associated with $p$.

This ensures that \sys (and equivalently, any adversary) only sees the plaintext tokens for disguise
$d$ and no other disguise if the client wishes to reveal them; 
furthermore, the adversary only learns how many disguises applied to $p$'s data if $p$ reveals a
disguise.

\lyt{Compared to the original design, this simply delays the adversary's knowledge of which/how
many disguises applied to a principal's data to when the client reveals a disguise. Not sure if it's
actually more secure given our threat model?}

\vspace{12pt}
\emph{Alternative design 2}: When a disguise is applied, \sys hands client a pointer to the
encrypted disguise's \symk{pd} location. The client has to bring pointers to the locations to give
to \sys if it wants to reveal tokens for that disguise.  

While this hides how many disguises were
applied to a particular $p$, it leaks how many (principal, disguise) keys there are in total; so if
only one principal's data has been disguised, for example, then this leaks how many disguises apply
to that principal.

\lyt{This also puts a lot more work on the client to remember disguise pointers...}

\vspace{6pt}\noindent\textbf{(2) Token Ciphertext Storage.}
\sys must hide which token ciphertexts correspond to which principals.  Naively, \sys can store
all ciphertexts in one bag; in order to determine which ciphertexts a client may access, the client
provides the decrypted \symk{pd} and \sys tries to decrypt every ciphertext in the bag. This clearly
has poor performance and is unscalable.
However, \sys cannot group the ciphertexts into bags indexed by principal ID: this leaks information
about the number of private tokens associated with a principal.

To provide metadata privacy while achieving better performance, \sys stores encrypted \tdata{pd} and
\tpriv{pdq} tokens in a linked list of encrypted tokens produced by $d$ associated with $p$, notated
as \tokls{pd}. 
Tokens store links to the next token in the list with in an additional \fn{nextEncToken} field: this
field stores a pointer to the location of current tail of \tokls{pd} for $p$ and $d$.
Thus, only by decrypting tokens in the list one by one can the entire \tokls{pd} be discovered and
the ciphertexts in the list decrypted.

\sys stores current pointers to the tails of \tokls{pd} indexed by $p$ and $d$. This allows \sys to
know where to start decrypting the list of tokens given $p$ and $d$, and how to set
\fn{nextEncToken} for a new token in \tokls{pd} produced when applying $d$. \sys generates dummy
tail pointers for all principals not associated with disguise $d$ to hide metadata about which lists
exist.
Because \tokls{pd} tails point to (real or dummy) token ciphertexts, an adversary learns nothing
about the token contents or how many tokens are associated with a principal.

%-------------------------------------------------------------------------------
\subsection{Does this design achieve our security goals?}
\label{sec:achievegoals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Security of Restricted Disguise Application.}}
\sys ensures that only properly authenticated clients can apply or
reverse a disguise, achieving security goal (1).

\vspace{6pt}\noindent\textbf{\emph{(2) Security of Private Disguise Tokens.}}
Our design requires \sys to encrypt private tokens associated with $p$ with a symmetric key
\symk{pd} for each disguise $d$. \sys then encrypts \symk{pd} with public key \pubk{p}.  
A client needs to prove it has \privk{p} by decrypting \symk{pd}, which only then allows decryption
of $p$'s private tokens of disguise $d$, achieving our goal to restrict access to $p$'s private
tokens.
%\lyt{Not mentioning the strawman solution that encrypts each token with \pubk{p} for now.}


\vspace{6pt}\noindent\textbf{\emph{(3) Security of Private Disguise Token Metadata.}}
We describe how \sys both hides which principals' data has
been disguised by inserting dummy \symk{pd} ciphertexts for all principals $p$ not disguised by $d$;
and how \sys ensures it does not know how many private tokens belong to $p$ by storing all private token
ciphertexts in encrypted linked-lists.
