%-------------------------------------------------------------------------------
\section{System Components}
%-------------------------------------------------------------------------------
\begin{itemize}
\item Disguising Tool (``Edna''): adds support for disguise API calls to applications.
\item Principal: an application user account that owns DB objects that are correlated via e.g., foreign key relationships to the account.
\item Client: external devices that contact the application via the application API, and can be authenticated to speak for one or more principals via the application authentication protocol (e.g., logging in with a password, or using access tokens to establish a session).
\item Tokens: 
\begin{itemize}
    \item Correlation tokens (linking an old principal to a created principal from disguise decorrelation operations). These tokens give Edna the ability to disguise the data of these principals when disguising the data of P, or to permanently recorrelate data back with P.
    \item Data tokens save the pre-modified or removed data. These tokens give Edna the ability to compose a future disguise on top of the original data, or permanently restore the original data.
    \item Private key tokens save the private key of a created anonymous principal
\end{itemize}
\item Disguise Capability: authorizes access to tokens.
\end{itemize}

%-------------------------------------------------------------------------------
\section{Threat Model}
%-------------------------------------------------------------------------------
An adversary can access any data stored as plaintext by the application or Edna, including data not exposed via its
client-facing API. We assume that an adversary cannot access prior snapshots of the application database, or observe modifications or memory accesses performed during disguise application. Furthermore, undisguised content and implicit correlations based on this content (e.g., a comment that mentions the authorâ€™s name) are out of scope.

We assume Edna is honest but curious: when applying or reversing a disguise, Edna may temporarily
hold (in memory) plaintext token data, as well as private or symmetric keys, but is trusted to
forget them once the disguise action is complete.  

Finally, we assume standard security of public key and
symmetric key primitives~\note{under a random oracle model?}.

%-------------------------------------------------------------------------------
\section{Disguise API}
%-------------------------------------------------------------------------------
\createpseudocodeblock{pcb}{center, boxed}{}{}{}
\createprocedureblock{procb}{center,boxed}{}{}{}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
(\pk_c, \sk_c) \sample \kgen() \<\< \\
\< \sendmessageright*{\texttt{RegisterClient(c, $\pk_c$)}} \< \\
\<\< \texttt{StorePubKey($\pk_c$)}
}
\caption{Client protocol for account registration}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ApplyDisguise(c,d)}} \< \\
\<\< \key_{cd} \sample \kgen() \\
\<\< \pk_{c} \gets \texttt{LoadPubKey}(c) \\
\<\< \texttt{enck$_{cd}$} \gets \enc(\pk_c, \key_{cd}) \\
\<\< \texttt{StoreEncKey(enck$_{cd}$)} \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\sk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{composition\_tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ApplyDisguise($c,d,\key_{cd}$,composition\_tokens)}
}
\caption{Client protocol for disguise application}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ReverseDisguise(c,d)}} \< \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\sk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ReverseDisguise($c,d$,tokens)}
}
\caption{Client protocol for disguise reversal}
\end{figure*}

\begin{figure*}
\procb{\texttt{ReadTokens(keys)}}{
    \< \\
\texttt{tokens} \gets []\\
\pcfor \texttt{$\key_{cd}$ in keys:} \\
\t[1]\texttt{encToken} \gets \texttt{LoadEncTokenListTail}(c,d)\\
\t[1]\pcwhile \texttt{encToken != NULL:}\\
\t[2]\texttt{token} \gets \dec(\key_{cd}, \texttt{encToken})\\
\t[2]\texttt{encToken} \gets \texttt{token.nextEncToken}\\
\t[2]\pcif \texttt{token.type = AnonPrivateKey:}\\
\t[3]c' \gets \texttt{token.anon\_uid}\\
\t[3]\sk_{c'} \gets \texttt{token.priv\_key}\\
\t[3]\texttt{keys}' \gets []\\
\t[3]\pcforeach d':\\
\t[4]\texttt{enck} \gets \texttt{LoadEncKey}(c',d')\\
\t[4]\texttt{keys}'\texttt{.append}(\dec(\sk_{c'}, \texttt{enck}))\\
\t[4]\texttt{tokens.extend(ReadTokens(keys}'))\\
\t[3]\pcendforeach\\
\t[2]\pcelse:\\
\t[3]\texttt{tokens.append(token)}\\
\t[2]\pcfi\\
\t[1]\pcendwhile\\
\pcendfor\\
\pcreturn \texttt{tokens}\\
}{}

\procb{\texttt{ApplyDisguise}$(c,d,\key_{cd}$,\texttt{composition\_tokens})}{
    \< \\
\pcfor \texttt{op} \in \texttt{GetDisguise($d$)}\\
\t[1]\texttt{token} \gets \texttt{op.execute($c$,composition\_tokens)}\\
\t[1]\texttt{token.nextEncToken} \gets \texttt{LoadEncTokenlistTail}(c,d)\\
\t[1]\texttt{token.nonce} \gets \texttt{RandomU64}()\\
\t[1]\texttt{encToken} \gets \enc(\key_{cd}, \texttt{token})\\
\t[1]\texttt{StoreEncTokenListTail}(c,d,\texttt{encToken})\\
\pcendfor
}{}

\procb{\texttt{ReverseDisguise}$(c,d$,\texttt{tokens})}{
    \< \\
    \texttt{Apply missed updates from disguise log to tokens of disguise $d$}\\
    \texttt{Reveal data in tokens of disguise $d$}\\
    \texttt{Undo modifications to any prior disguise's tokens by disguise $d$}
}{}

\caption{Edna Algorithms (assuming all tokens are user-vault encrypted tokens, and ignoring global vault tokens for now)}
\end{figure*}
