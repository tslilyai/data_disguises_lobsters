\section{Design} 

\subsection{Disguise Operations} 
Operations \op{d} of disguise $d$ take data objects as input, execute updates to application
data, and produce (\texttt{token, principal}) pairs
as output. This means that the disguise specification determines how tokens correspond to
principals: for example, a comment may correspond to the principal whose ID is referenced by the
author column.
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.

        To support private tokens associated with $q$, decorrelation generates a
        public-private key pair \pubk{q} and \privk{q}.
\end{enumerate}
Every \op{d} has an associated predicate over the application database that selects \op{d}'s input objects.

\subsection{Disguise Tokens} 
Disguise tokens come in two forms: data tokens and privkey tokens.

\vspace{6pt}
\noindent\textbf{\emph{Data Tokens.}}
Every \op{d} produces data tokens associated with the disguise $d$ and a
principal $p$, notated as \tdata{pd}. \tdata{pd} tokens are either private or global depending on
whether the disguise $d$ is global or private. 
\lyt{Note: making explicit decision that global/private is a per-disguise setting.}
%An admin-authenticated client can still apply private disguises, but won't be able to access any
%non-global tokens.  Furthermore, a private disguise may produce tokens private to many different
%principals.}

A \tdata{pd} contains the following fields, which record changes performed by \op{d}:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{objID}: unique ID for the data object modified by \op{d}
\item \fn{updateType}: decorrelate, modify, or remove
\item \fn{oldValue}: original value of object \fn{objID}
\item \fn{newValue}: updated value of object \fn{objID}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent\textbf{\emph{PrivKey Tokens.}}
Decorrelation operations generate a second form of token, namely a privkey token associated with the disguise $d$, principal $p$, and the pseudoprincipal $q$ created
during decorrelation (notated as \tpriv{pdq}).
\tpriv{pdq} contains the following fields:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}
\sys always stores \tpriv{pdq} privately and associated with $p$. This ensures that only a client
with access to \privk{p} can access \privk{q} (and therefore access $q$'s private tokens).

\vspace{12pt}
\noindent\textbf{\emph{Enforcing Private Token Access.}}
\sys ensures the security of private disguise data tokens as follows: \sys encrypts private
\tdata{pd} with a symmetric key \symk{pd} specific to the disguise and principal. The token's nonce
ensures safety against known-plaintext attacks. \sys then encrypts \symk{pd} with public key
\pubk{p}.  
%
A client needs to prove it has \privk{p} by decrypting \symk{pd}, which then allows \sys
to decrypt $p$'s data tokens produced from applying $d$.

\sys ensures security of \tpriv{pdq} tokens by encrypting them with \pubk{p}. Only a client who has
\privk{p} can decrypt \tpriv{pdq} and gain access to pseudoprincipal $q$'s private key \privk{q}
(and thus access to $q$'s private tokens).

\sys stores all global \tdata{pd} tokens in plaintext, where any party can access it.

\begin{table}[t!]
\centering
\begin{tabular}{ c | c c }
& \multicolumn{2}{c}{\textbf{$d$ Tokens}}\\
\textbf{Client}& \textbf{Global} & \textbf{Private to $p$}\\
\hline
    {Authenticated as $q \neq p$, has \privk{q}} & \checkmark & \\
    {Authenticated as $p$, has \privk{p}} & \checkmark & \checkmark\\
\end{tabular}
\vspace{6pt}
\caption{Client access to disguise $d$'s tokens, depending the client's authentication and the state of the tokens.}
\label{tab:access}
\end{table}

Table~\ref{tab:access} illustrates which clients can access a disguise $d$'s tokens, depending on
how the client is authorized, and the state of the tokens.

\vspace{12pt}
\noindent\textbf{\emph{Hiding the Set of Disguises Applied to a Principal.}}
As described, \sys's design may leak information that principal $p$ has been disguised by disguise
$d$ by storing a map from $p$ and $d$ to \symk{pd} ciphertexts and \tdata{pd} or \tpriv{pdq}
ciphertexts. 
This is a problem: for example, \sys should not store information that a principal $p$ has
invoked GDPR deletion.

\vspace{6pt}\noindent\textbf{Storing \symk{pd} and \tdata{pd}}.
When a disguise $d$ generates tokens for principal $p$, \sys generates a random number \rptr{pd} and saves
a map from \rptr{pd} to:
\begin{enumerate}
    \item the \symk{pd} ciphertext
    \item an array of \tdata{pd} ciphertexts
\end{enumerate}
\rptr{pd} acts as the capability to locate (and thus access) the \symk{pd} and \tdata{pd}
ciphertexts.

Because no client speaking for $p$ may be currently online, \sys emails (or otherwise communicates)
\rptr{pd} to a party that can authenticate as $p$. If no email is present (\eg $p$ is a pseudoprincipal),
\sys publically saves a mapping from $p$ to \rptr{pd}; this leaks disguise-principal associations, but
only for pseudoprincipals whose data is already decorrelated from their original principal owner.
\lyt{This assumes that every real user must have an email.}

In order to reveal tokens for $p$ from disguise $d$, the client must prove it has the capability
\rptr{pd},
which allows \sys to return to the client the encrypted \symk{pd}. The client then has to prove it
can access $p$'s tokens for $d$ by decrypting \symk{pd} with \privk{p}.  Only with the plaintext
\symk{pd} can the array of \tdata{pd} ciphertexts be decrypted by \sys.

Thus, even an attacker who can spoof \rptr{pd} will not be able to access $p$'s tokens for $d$ without
\privk{p}.

However, note that \sys does learn the number of \tdata{pd} tokens for each $p$ and $d$; this
metadata is out of scope of our threat model.

\vspace{6pt}\noindent\textbf{Storing \tpriv{pdq}}.
\tpriv{pdq} token ciphertexts are stored in one array corresponding to the original principal $p$, but are not
separated by disguise $d$ as \tdata{pd} ciphertexts are.

\sys (and equivalently an attacker) cannot learn which disguises applied to principal $p$ from
observing the array of \tpriv{pdq} ciphertexts. However, \sys can learn how many disguises were
applied to---and in particular, decorrelated---$p$'s data, as well as the number of pseudoprincipals
in the system linked to $p$. This metadata is out of scope of our threat model.

%While this hides which disguises were applied to a particular $p$, it leaks how many (principal, disguise) keys there are in total; so if
%only one principal's data has been disguised, for example, then this leaks how many disguises apply
%to that principal.

%\emph{Original design}: 
%\sys stores a mapping from $p$ and $d$ to encrypted \symk{pd}.
%To ensure that this does not leak metadata about which principals have disguised data, \sys generates dummy ciphertexts for all
%principals that do not have encrypted \symk{pd}s for disguise $d$.


%-------------------------------------------------------------------------------
\subsection{Does this design achieve our security goals?}
\label{sec:achievegoals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Security of Restricted Disguise Application.}}
\sys ensures that only properly authenticated clients can apply or
reverse a disguise, achieving security goal (1).

\vspace{6pt}\noindent\textbf{\emph{(2) Security of Private Disguise Tokens.}}
Our design requires \sys to encrypt private \tdata{} tokens associated with $p$ with a symmetric key
\symk{pd} for each disguise $d$. \sys then encrypts \symk{pd} with public key \pubk{p}.  
A client needs to prove it has \privk{p} by decrypting \symk{pd}, which only then allows decryption
of $p$'s private tokens of disguise $d$, achieving our goal to restrict access to $p$'s private
tokens.

Each private \privk{pdq} is encrypted with \pubk{p}, and thus also requires a client to prove it has
\privk{p} before the client can gain access to $q$'s private tokens.
%\lyt{Not mentioning the strawman solution that encrypts each token with \pubk{p} for now.}

\vspace{6pt}\noindent\textbf{\emph{(3) Security of Disguises Applied to Principal.}}
We describe how \sys hides which disguises affect each principals' data by introducing one layer of
indirection that separates a principal $p$'s data by disguise without tying the data directly back to
$p$. The client must additionally provide the correct random number generated by \sys in order to
access the corresponding disguise $d$'s tokens for $p$.

\iffalse
\vspace{6pt}\noindent\textbf{(2) \tdata{} Token Ciphertext Storage.}
\sys must hide which token ciphertexts correspond to which principals.  Naively, \sys can store
all ciphertexts in one bag; in order to determine which ciphertexts a client may access, the client
provides the decrypted \symk{pd} and \sys tries to decrypt every ciphertext in the bag. This clearly
has poor performance and is unscalable.
However, \sys cannot group the ciphertexts into bags indexed by principal ID: this leaks information
about the number of private tokens associated with a principal.

To provide metadata privacy while achieving better performance, \sys stores encrypted \tdata{pd} and
\tpriv{pdq} tokens in a linked list of encrypted tokens produced by $d$ associated with $p$, notated
as \tokls{pd}. 
Tokens store links to the next token in the list with in an additional \fn{nextEncToken} field: this
field stores a pointer to the location of current tail of \tokls{pd} for $p$ and $d$.
Thus, only by decrypting tokens in the list one by one can the entire \tokls{pd} be discovered and
the ciphertexts in the list decrypted.

\sys stores current pointers to the tails of \tokls{pd} indexed by $p$ and $d$. This allows \sys to
know where to start decrypting the list of tokens given $p$ and $d$, and how to set
\fn{nextEncToken} for a new token in \tokls{pd} produced when applying $d$. \sys generates dummy
tail pointers for all principals not associated with disguise $d$ to hide metadata about which lists
exist.
Because \tokls{pd} tails point to (real or dummy) token ciphertexts, an adversary learns nothing
about the token contents or how many tokens are associated with a principal.

\vspace{6pt}\noindent\textbf{(3) \tpriv{} Token Ciphertext Storage.}
\lyt{For this, we would need to store in a linked list, each node would have to be sent one at a
time to the client because each token is encrypted with \pubk{p}}.
\fi
