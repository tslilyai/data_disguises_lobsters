%-------------------------------------------------------------------------------
\section{Design} 
%-------------------------------------------------------------------------------

\subsection{Disguise Specifications.} 
Because disguises are inherently application-specific, the application developer provides disguise
specifications that consist of a set of predicated disguise operations \op{d} to perform during the
disguise.

Operations \op{d} of disguise $d$ take data objects as input and execute updates to application
data.  \sys automatically generates database change records when applying \op{d}. 

Developers describe in the specification which principals an operation's generated database change
record corresponds to.  For example, a database change record generated by removing comment may
correspond to the principal whose ID is referenced by the author column.  

Developers also specify an application-aware pseudoprincipal generation policy, namely how to
generate new user accounts in a manner that the application can handle (e.g., pseudoprincipals may
not have email addresses).

\vspace{6pt}\noindent
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.
\end{enumerate}

\noindent For each \op{d}, the application developer specifies:
\begin{itemize}
    \item An associated predicate over the application database that selects \op{d}'s input
        objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The corresponding principal(s) that should have the capability to access \op{d}'s
        generated disguise change or correlation record.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Database Diffs.}
Every \op{d} produces a \emph{database diff} \tdata{p\delta_i} associated with the disguise instance $\delta$ and a
principal $p$. 
%
\tdata{p\delta_i} contains the following fields, which record any changes made when applying \op{d}:
%
\begin{itemize}
\item \fn{diffID}: unique ID for this diff
\item \fn{disguiseID}: ID of disguise $d$ being applied
\item \fn{principalID}: associated principal $p$
\item \fn{objID}: unique ID for the data object modified by \op{d}
\item \fn{updateType}: decorrelate, modify, or remove
\item \fn{oldValue}: original value of object \fn{objID}
\item \fn{newValue}: updated value of object \fn{objID}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent\sys uses \tdata{p\delta_i} to:
\begin{itemize}
    \item Compose updates of $\delta_j$ on top of updates of disguise $\delta_i$ associated with
        $p$'s data.
    \item Reveal updates performed by disguise $\delta_i$ associated with $p$, if no conflicting updates have been
        performed since.
\lyt{This is slightly vague and may not handle all situations? \eg if the application made updates
        that don't conflict, but may be dependent on the status of the disguised object}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Decorrelation and Locked Private Keys.}
Decorrelation generates a public-private key pair \pubk{q} and \privk{q} for pseudoprincipal $q$
created during decorrelation.
\sys stores \pubk{q} associated with $q$'s user ID, and puts \privk{q} in a \emph{locked private key}
associated with the original principal $p$ and $q$, notated as \tpriv{p}{q}. \tpriv{p}{q} contains the
following fields, encrypted with \pubk{p}:
\begin{itemize}
\item \fn{principalID}: original principal $p$
\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}
\noindent Because \tpriv{p}{q} is encrypted with \pubk{p}, only a client who has
\privk{p} can access pseudoprincipal $q$'s private key \privk{q}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Security and Capabilities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Access to Database Diffs.} 
\sys represents a data capability \dcapa{p\delta_i} as a symmetric key specific to
the disguise instance and principal.
%
\sys protects access to database diffs \tdata{p\delta_i} by encrypting \tdata{p\delta_i} with the
\dcapa{p\delta_i}. The diff's nonce ensures safety against known-plaintext attacks. \sys then encrypts
\dcapa{p\delta_i} with public key \pubk{p}.  
%
Thus, only a client who has \privk{p} can decrypt the data capability, and return in the capability pair the plaintext symmetric key that enables \sys to decrypt $p$'s database diffs produced from applying $d$.

%\sys stores all global \tdata{p\delta_i} tokens in plaintext, where any party can access it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Protecting Disguise History.}
\sys's design may leak information that $\delta_i$ disguised principal $p$ 
because an adversary may learn that ciphertexts for \dcapa{p\delta_i} and
\tdata{p\delta_i} exist for a particular $p$ and $\delta_i$.
This is a problem: for example, \sys should not store information that a principal $p$ has
invoked GDPR deletion.

To avoid this problem, \sys stores (1) the \dcapa{p\delta_i} ciphertext and (2) an array of
\tdata{p\delta_i} ciphertexts at random location \lcapa{p\delta_i} (\eg a random number or string).
This dissociates one disguise applied to a principal $p$ from all other disguises, so an adversary only ever
learns about a single disguise instance if \sys gains permission to reveal or compose upon that
disguise instance.

Note that an adversary can learn the number of \tdata{p\delta_i} diffs for each $p$ and $d$; this
metadata is out of scope of our threat model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{External Storage of \lcapa{p\delta_i}.} 
\sys should not store \lcapa{p\delta_i}: existence of \lcapa{p\delta_i} allows an adversary to
learn that $\delta_i$ has applied to principal $p$. Thus, \lcapa{p\delta_i} must be stored externally,
even when no client speaking for $p$ is currently online.

The only exception to this occurs when $p$ is a pseudoprincipal: in this case, \sys saves a
(globally accessible) mapping from $p$ to \lcapa{p\delta_i}. This leaks the disguise history of
pseudoprincipals, but is allowable because pseudoprincipals' data has already been decorrelated from their
original principal owner.

If $p$ is an actual principal, we consider two options: 
\begin{enumerate}
    \item \sys can email (or otherwise communicate)
\lcapa{p\delta_i} to a party that can authenticate as $p$. If no email is present (\eg $p$ is a pseudoprincipal),
\sys can save a (globally accessible) mapping from $p$ to \lcapa{p\delta_i}; this leaks disguise-principal associations, but
only for pseudoprincipals whose data is already decorrelated from their original principal owner.
\lyt{This assumes that every real user must have an email.}
\item Alternatively, \sys can simply return the addresses back to the application; the application
then must handle the logic of contacting the respective parties and saving addresses externally.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Acquiring Pseudoprincipal Capabilities}
As discussed above, \sys can access locating capabilities \lcapa{q\delta_i}s for pseudoprincipal $q$ without a
client providing it. 
%
However, a client still needs to acquire \dcapa{q\delta_i} for \sys to have full capability pairs
to disguise, reveal, or otherwise act on behalf of pseudoprincipal $q$.

\sys adds a \fn{GetPrincipalLockedPrivateKeys} Client API call, which returns all locked private
keys \tpriv{p}{q} generated when decorrelating data from $p$.
A client then must prove it has \privk{p} to decrypt \tpriv{p}{q} and extract pseudoprincipal ID $q$ and \privk{q}.

With $q$ and \privk{q}, the client can get all encrypted \dcapa{q\delta_i} for all $\delta_i$, and
provide these to \sys so \sys has the full capability pair \pcapa{q\delta_i}. With
this pair, \sys can retrieve diffs or establish links for $q$'s data.

\lyt{TODO: Add an internal server-side API call that retrieves globally accessible location capabilities?}

%-------------------------------------------------------------------------------
\subsection{Does this design achieve our security goals?}
\label{sec:achievegoals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Authorized Disguises.}}
\sys ensures that only properly authenticated clients speaking for authorized principals can apply or
reveal a disguise, achieving security goal (1).

\vspace{6pt}\noindent\textbf{\emph{(2/3) Secure Linking and Secure Disguise Diffs.}}
\lcapa{p\delta_i} is required to find the encrypted \dcapa{p\delta_i}---a symmetric key
specific to each disguise instance $\delta$ and principal $p$ encrypted with \pubk{p}.
Because \sys encrypts \tdata{p\delta_i} diffs associated with $p$ with \dcapa{p\delta_i}, a client
needs to first decrypt $\dcapa{p\delta_i}$ with \privk{p}, and then hand the pair \pcapa{p\delta_i}
to \sys for \sys to decrypt of $p$'s diffs from $\delta_i$.

Thus, \sys ensures that only clients who can provide \lcapa{p\delta_i} and \dcapa{p\delta_i} (and,
by consequence, have \privk{p}) can access $p$'s disguise diffs, or learn what links can be
established between $p$ and data objects.

\vspace{6pt}\noindent\textbf{\emph{(4) Privacy of Disguise History.}}
We describe how \sys hides which disguises affect each principals' data by requiring a client to
provide a locating capability \lcapa{p\delta_i} in order to find encrypted data from disguise $d$ applied
to (non-pseudoprincipal) $p$. Because \sys does not store these locations, and the locationsare per-disguise, \sys
cannot link different disguises' encrypted data to the same principal.

\iffalse
\begin{table}[t!]
\centering
\begin{tabular}{ c | c c }
    & \multicolumn{2}{c}{\textbf{\tdata{p\delta_i} Token Access}}\\
\textbf{Client Proof}& \textbf{Global} & \textbf{Private to $p$}\\
\hline
    $\emptyset$ & plaintext & \\
    \privk{p} & plaintext & \\
    \dcapa{p\delta_i} & plaintext & ciphertext \\
    \privk{p}, \dcapa{p\delta_i} & plaintext & plaintext \\
\end{tabular}
\vspace{6pt}
\caption{Client access to disguise $d$'s tokens, depending on what proof the client can provide and the state of the tokens.}
\label{tab:access}
\end{table}

Table~\ref{tab:access} illustrates which clients can access a disguise $d$'s tokens, depending on
what the client presents as proof, and the state of the tokens.

\sys ensures that private tokens are properly secured such that only a client with private key
\privk{p} and capability \dcapa{p\delta_i} can access tokens produced by disguise $d$ associated with $p$.
%
Furthermore, \sys ensures that only a client with capability \dcapa{p\delta_i} can learn if a disguise $d$
applies to principal $p$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storing \tpriv{p}{q} Tokens.}
\tpriv{p}{q} tokens are encrypted with \pubk{p} and the resulting ciphertexts stored in one array
corresponding to the original principal $p$. These token ciphertexts are not separated by disguise
as \tdata{p\delta_i} ciphertexts are, since \tpriv{p}{q} tokens grant the holder authorization to access
tokens from any disguise for pseudoprincipal $q$.

\sys (and equivalently an attacker) cannot learn which disguises applied to principal $p$ from
observing the array of \tpriv{p}{q} ciphertexts. However, \sys can learn how many disguises were
applied to---and in particular, decorrelated---$p$'s data, as well as the number of pseudoprincipals
in the system linked to $p$. This metadata is out of scope of our threat model.
\fi
