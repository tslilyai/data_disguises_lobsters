%-------------------------------------------------------------------------------
\section{Design} 
%-------------------------------------------------------------------------------

\sys adds extra functionality to the application to support disguising (and \sys and the application lie the same security domain).
%
Because disguises are inherently application-specific, the application developer provides the following:
\begin{itemize}
    \item Disguise specifications that consist of a set of predicated disguise operations to
        perform during the disguise.
    \item Application-aware pseudoprincipal generation (how to generate new user accounts in a
        manner that the application can handle, e.g., they may not have email addresses)
\end{itemize}

\vspace{-6pt}
\head{Disguise Specification Operations.} 
Operations \op{d} of disguise $d$ take data objects as input, execute updates to application data,
and produce (\texttt{token, principal}) pairs as output. \sys automatically generates data tokens
(described below) based on the type of \op{d}; however, developers describe in the specification
which principals an operation's token corresponds to. For example, a comment may correspond to the
principal whose ID is referenced by the author column.  

\vspace{6pt}\noindent
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.

        To support private tokens associated with $q$, decorrelation generates a
        public-private key pair \pubk{q} and \privk{q}.
\end{enumerate}

For each \op{d}, the application developer specifies:
\begin{itemize}
    \item An associated predicate over the application database that selects \op{d}'s input
        objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The corresponding principal(s) with capabilities to access the produced token.
\end{itemize}

\noindent
The generated tokens come in two forms: data tokens and privkey tokens.

\vspace{6pt}
\noindent\textbf{\emph{Data Tokens.}}
Every \op{d} produces data tokens associated with the disguise $d$ and a
principal $p$, notated as \tdata{pd}. \tdata{pd} tokens are either private or global depending on
whether the disguise $d$ is global or private. 
\lyt{global/private is a per-disguise setting.}

A \tdata{pd} contains the following fields, which record changes performed by \op{d}:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{objID}: unique ID for the data object modified by \op{d}
\item \fn{updateType}: decorrelate, modify, or remove
\item \fn{oldValue}: original value of object \fn{objID}
\item \fn{newValue}: updated value of object \fn{objID}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent\textbf{\emph{PrivKey Tokens.}}
Decorrelation operations generate a second form of token, namely a privkey token associated with the disguise $d$, principal $p$, and the pseudoprincipal $q$ created
during decorrelation (notated as \tpriv{pdq}).
\tpriv{pdq} contains the following fields:
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: producing disguise $d$ 
\item \fn{principalID}: associated principal $p$
\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}
\sys always stores \tpriv{pdq} privately associated with $p$. 
%This ensures that only a client
%with access to \privk{p} can access \privk{q} (and therefore access $q$'s private tokens).

%-------------------------------------------------------------------------------
\subsection{Security}
%-------------------------------------------------------------------------------
\begin{table}[t!]
\centering
\begin{tabular}{ c | c c }
    & \multicolumn{2}{c}{\textbf{\tdata{pd} Token Access}}\\
\textbf{Client Proof}& \textbf{Global} & \textbf{Private to $p$}\\
\hline
    $\emptyset$ & plaintext & \\
    \privk{p} & plaintext & \\
    \capa{pd} & plaintext & ciphertext \\
    \privk{p}, \capa{pd} & plaintext & plaintext \\
\end{tabular}
\vspace{6pt}
\caption{Client access to disguise $d$'s tokens, depending on what proof the client can provide and the state of the tokens.}
\label{tab:access}
\end{table}

Table~\ref{tab:access} illustrates which clients can access a disguise $d$'s tokens, depending on
what the client presents as proof, and the state of the tokens.

\sys ensures that private tokens are properly secured such that only a client with private key
\privk{p} and capability \capa{pd} can access tokens produced by disguise $d$ associated with $p$.
%
Furthermore, \sys ensures that only a client with capability \capa{pd} can learn if a disguise $d$
applies to principal $p$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Plaintext Token Access.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sys protects private disguise data tokens by encrypting the private \tdata{pd} with a symmetric key
\symk{pd} specific to the disguise and principal. The token's nonce ensures safety against
known-plaintext attacks. \sys then encrypts \symk{pd} with public key \pubk{p}.  
%
A client needs to prove it has \privk{p} by decrypting \symk{pd}, which then allows \sys
to decrypt $p$'s data tokens produced from applying $d$.

\sys protects \tpriv{pdq} tokens by encrypting them with \pubk{p}. Only a client who has
\privk{p} can decrypt \tpriv{pdq} and gain access to pseudoprincipal $q$'s private key \privk{q}
(and thus access to $q$'s private tokens).

\sys stores all global \tdata{pd} tokens in plaintext, where any party can access it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Hiding the Set of Disguises Applied to a Principal.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sys's design may leak information that principal $p$ has been disguised by disguise
$d$ because an adversary may learn that ciphertexts for \symk{pd} and \tdata{pd} tokens exists for a particular $p$ and $d$.
This is a problem: for example, \sys should not store information that a principal $p$ has
invoked GDPR deletion.

To avoid this problem, \sys generates a capability \capa{pd} (e.g., a random number or string)
and saves a map from \capa{pd} to (1) the \symk{pd} ciphertext and (2) an array of \tdata{pd}
ciphertexts.
%\capa{pd} acts as the capability to locate (and thus access) the \symk{pd} and \tdata{pd}
%ciphertexts.

In order to reveal tokens for $p$ from disguise $d$, the client must prove it has the capability
\capa{pd}, which allows \sys to find the encrypted \symk{pd}. The client then has to prove it can
access $p$'s tokens for $d$ by decrypting \symk{pd} with \privk{p}.  Only with the
plaintext \symk{pd} can the array of \tdata{pd} ciphertexts be decrypted by \sys.

Thus, an attacker who can spoof \capa{pd} will not be able to access the plaintext of $p$'s tokens for $d$ without
\privk{p}, although they can learn if $d$ disguised some of $p$'s data.

Note that an adversary can learn the number of \tdata{pd} tokens for each $p$ and $d$; this
metadata is out of scope of our threat model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{External Storage of \capa{pd}.} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sys should not store \capa{pd} such that \sys can learn the
set of capabilities associated with one principal $p$: existence of \capa{pd} allows an adversary to
learn that disguise $d$ has applied to principal $p$. Thus, \capa{pd} must be stored externally,
even when no client speaking for $p$ is currently online.

If $p$ is a pseudoprincipal, \sys saves a (globally accessible) mapping from $p$ to \capa{pd}; this leaks disguise-principal associations, but only for pseudoprincipals whose data is already decorrelated from their original principal owner.

If $p$ is an actual principal, we consider two options: 

(1) \sys can email (or otherwise communicate)
\capa{pd} to a party that can authenticate as $p$. If no email is present (\eg $p$ is a pseudoprincipal),
\sys can save a (globally accessible) mapping from $p$ to \capa{pd}; this leaks disguise-principal associations, but
only for pseudoprincipals whose data is already decorrelated from their original principal owner.
\lyt{This assumes that every real user must have an email.}

(2) Alternatively, \sys can simply return the capabilities back to the application; the application
then must handle the logic of contacting the respective parties and saving capabilities externally.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storing \tpriv{pdq} Tokens.}
\tpriv{pdq} tokens are encrypted with \pubk{p} and the resulting ciphertexts stored in one array
corresponding to the original principal $p$. These token ciphertexts are not separated by disguise
$d$ as \tdata{pd} ciphertexts are, since \tpriv{pdq} tokens grant the holder authorization to access
tokens from any disguise for pseudoprincipal $q$.

\sys (and equivalently an attacker) cannot learn which disguises applied to principal $p$ from
observing the array of \tpriv{pdq} ciphertexts. However, \sys can learn how many disguises were
applied to---and in particular, decorrelated---$p$'s data, as well as the number of pseudoprincipals
in the system linked to $p$. This metadata is out of scope of our threat model.

%-------------------------------------------------------------------------------
\subsection{\sys API.}
%-------------------------------------------------------------------------------
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \vspace{6pt}
    \fn{RegisterPrincipal($p$, email, $\pubk{p}$) $\rightarrow ()$} & Registers $p$ as a principal whose data can be privately disguised.\\
    \vspace{6pt}
    \fn{GetGlobalCapabilities($p$)} $\rightarrow$ \{\capa{pd}\} & Retrieves the (globally 
    available) capabilities associated with principal $p$; nonempty only if $p$ is a pseudoprincipal.\\
    \vspace{6pt}
    \fn{CapabilitiesToEncTokenKeys(\{\capa{}\}) $\rightarrow$ \{Enc(\symk{})\}} & Uses the provided
    capabilities to retrieve the corresponding encrypted symmetric keys that were used to encrypt tokens.\\
    \vspace{6pt}
    \fn{GetPseudoPrincipalEncPrivKeys($p$)} $\rightarrow$ \{Enc(\tpriv{pdq})\} & Retrieves the
    encrypted private key tokens of pseudoprincipal created by decorrelating data from $p$.\\
    \vspace{6pt}
    \fn{Disguise($d$, \{\symk{pd'}\}) $\rightarrow$ \{\capa{}\}} & Applies disguise $d$.  The
    provided set of symmetric keys (potentially corresponding to several disguises and several
    principals) grant \sys access to tokens tokens from these disguises for these principals, which
    allow \sys to compose disguise $d$ on top of these previous disguises.  This function returns a
    set of capabilities enabling access to tokens produced by this disguise.\\
    \vspace{6pt}
    \fn{Reveal($d$, \{\symk{pd}\}) $\rightarrow ()$} & 
    Reveals disguise $d$.  The provided set of symmetric keys corresponding to disguise $d$ and
    potentially several principals grant \sys access to tokens from disguise $d$ for these
    principals. \sys reveals the data stored in the tokens if possible.
\end{tabular}
\vspace{6px}

\caption{\sys API}
\label{tab:api}
\end{table*}

\sys takes these developer-provided specifications and exposes the API in Table~\ref{tab:api} to the
application. 

\head{Principal Public Key Registration.}
Figure~\ref{fig:acctreg} illustrates the principal registration protocol: every principal in the
system must register a public key with \sys in order to later reveal (for disguise reversal or
composition) any of privately disguised data. \sys remembers each public key \pubk{p} along with
$p$'s ID.

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\fn{RegisterPrincipal(p,$\pubk{p}$)}} \< \\
\<\< \fn{StorePubKey($\pubk{p}$)}
}
\caption{\textbf{Principal public key registration.}}
\label{fig:acctreg}
\end{figure*} 

\begin{figure*}[t!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \fn{caps} \gets \fn{LoadClientCapabilities($p$)}\\
\fn{privKs} \gets \{p \mapsto \privk{p}\}\pclb
\pcintertext[dotted]{Recursively get capabilities of all linked pseudoprincipals}
\fn{idsToProcess} \gets \{p\}\\
\pcwhile \fn{idsToProcess} \neq \{\}:\\
\quad q \gets \fn{idsToProcess.pop()}\\
\< \sendmessageright*{\fn{GetPseudoPrincipalEncPrivKeys($q$)}} \< \\
\<\< \fn{encPrivKs} \gets \fn{\sys.Principals[q].EncPKTokens}\\
\< \sendmessageleft*{\fn{encPrivKs}} \< \\
\quad \pcforeach \fn{encPrivK} \in \fn{encPrivKs}:\\
\quad \quad \privk{q} \gets \fn{privKeys}[q]\\
\quad \quad \tpriv{qd'r} \gets \dec(\privk{q}, \fn{encPrivK})\\
\quad\quad\fn{privKs.insert}(r\mapsto \tpriv{qd'r}.\fn{privKey}) \<\< \\
\quad\quad\fn{idsToProcess.insert($r$)} \<\< \\
\< \sendmessageright*{\fn{GetGlobalCapabilities($q$)}} \< \\
\<\< \fn{globalCaps} \gets \fn{\sys.Principals[q].GlobalCaps}\\
\< \sendmessageleft*{\fn{globalCaps}} \< \\
\quad\quad\fn{caps.append(globalCaps)}\\
\quad \pcendforeach\\
\pcendwhile\pclb
    \pcintertext[dotted]{Use capabilities to get corresponding encrypted token keys}
\< \sendmessageright*{\fn{CapabilitiesToEncTokenKeys(caps)}} \< \\
    \<\< \fn{encTokKeys} \gets \fn{LoadEncTokenKeys(caps)}\\
\< \sendmessageleft*{\fn{encTokKeys}}\\
\fn{symKeys} \gets \{\}\\
\pcforeach \fn{Enc(\symk{qd'})} \in \fn{encTokKeys}\\
\quad \pcif \text{authorizes access to $q$'s private tokens for $d'$}: \\
\quad\quad \privk{q} \gets \fn{privKs[q]}\\
\quad\quad \fn{symKeys.insert(\dec(\privk{q}, \symk{qd'}))}\\
\pcendforeach\pclb
\pcintertext[dotted]{Apply disguise with token keys}
\< \sendmessageright*{\fn{Disguise($d$,symKeys)}} \< \\
\<\< \{\capa{}\}\gets\fn{ApplyDisguise($d$,symKeys)} \pclb
\pcintertext[dotted]{Capabilities can be emailed by \sys or returned to application}
}
\caption{\textbf{Disguise Application.}}
\label{fig:disgapp}
\end{figure*} 

\head{Disguise Application and Reversal with Capabilities.}
As shown in Figure~\ref{fig:disgapp}, an \sys client can retrieve capabilities both provided for an
original principal $p$ (for which the client is authenticated and has \privk{p}). 

The client can also retrieve capabilities and private keys for all pseudoprincipals associated with $p$.

Using these capabilities, the client can query for encrypted symmetric \symk{} keys corresponding to
the set of provided capabilities; and decrypt and provide these \symk{}s to \sys to disguise (or reveal) using token data that can be decrypted using the provided \symk{}.

%-------------------------------------------------------------------------------
\subsection{Does this design achieve our security goals?}
\label{sec:achievegoals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Security of Restricted Disguise Application.}}
\sys ensures that only properly authenticated clients can apply or
reveal a disguise, achieving security goal (1).

\vspace{6pt}\noindent\textbf{\emph{(2) Security of Private Disguise Token Plaintext.}}
Our design requires \sys to encrypt private \tdata{} tokens associated with $p$ with a symmetric key
\symk{pd} for each disguise $d$. \sys then encrypts \symk{pd} with public key \pubk{p}.  
A client needs to prove it has \privk{p} by decrypting \symk{pd}, which only then allows decryption
of $p$'s private tokens of disguise $d$, achieving our goal to restrict access to $p$'s private
tokens.

Each private \privk{pdq} is encrypted with \pubk{p}, and thus also requires a client to prove it has
\privk{p} before the client can gain access to $q$'s private tokens.

\vspace{6pt}\noindent\textbf{\emph{(3) Security of Disguises Applied to Principal.}}
We describe how \sys hides which disguises affect each principals' data by requiring a client to
provide a capability \capa{pd} in order to locate the encrypted token data from disguise $d$ applied
to $p$. Because \sys does not store these capabilities, and the capabilities are per-disguise, \sys
cannot link different disguises' encrypted token data to the same principal.

\iffalse
\vspace{6pt}\noindent\textbf{(2) \tdata{} Token Ciphertext Storage.}
\sys must hide which token ciphertexts correspond to which principals.  Naively, \sys can store
all ciphertexts in one bag; in order to determine which ciphertexts a client may access, the client
provides the decrypted \symk{pd} and \sys tries to decrypt every ciphertext in the bag. This clearly
has poor performance and is unscalable.
However, \sys cannot group the ciphertexts into bags indexed by principal ID: this leaks information
about the number of private tokens associated with a principal.

To provide metadata privacy while achieving better performance, \sys stores encrypted \tdata{pd} and
\tpriv{pdq} tokens in a linked list of encrypted tokens produced by $d$ associated with $p$, notated
as \tokls{pd}. 
Tokens store links to the next token in the list with in an additional \fn{nextEncToken} field: this
field stores a pointer to the location of current tail of \tokls{pd} for $p$ and $d$.
Thus, only by decrypting tokens in the list one by one can the entire \tokls{pd} be discovered and
the ciphertexts in the list decrypted.

\sys stores current pointers to the tails of \tokls{pd} indexed by $p$ and $d$. This allows \sys to
know where to start decrypting the list of tokens given $p$ and $d$, and how to set
\fn{nextEncToken} for a new token in \tokls{pd} produced when applying $d$. \sys generates dummy
tail pointers for all principals not associated with disguise $d$ to hide metadata about which lists
exist.
Because \tokls{pd} tails point to (real or dummy) token ciphertexts, an adversary learns nothing
about the token contents or how many tokens are associated with a principal.

\vspace{6pt}\noindent\textbf{(3) \tpriv{} Token Ciphertext Storage.}
\lyt{For this, we would need to store in a linked list, each node would have to be sent one at a
time to the client because each token is encrypted with \pubk{p}}.
\fi
