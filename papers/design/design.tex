%-------------------------------------------------------------------------------
\section{Design} 
%-------------------------------------------------------------------------------

\subsection{Disguise Specifications.} 
Because disguises are inherently application-specific, the application developer provides disguise
specifications that consist of a set of predicated disguise operations \op{d} to perform during the
disguise.

Operations \op{d} of disguise $d$ take data objects as input and execute updates to application
data.  \sys automatically generates database change records when applying \op{d}. 

Developers describe in the specification which principals an operation's generated database change
record corresponds to.  For example, a database change record generated by removing comment may
correspond to the principal whose ID is referenced by the author column.  

Developers also specify an application-aware pseudoprincipal generation policy, namely how to
generate new user accounts in a manner that the application can handle (e.g., pseudoprincipals may
not have email addresses).

Finally, developers specify which principals are authorized to apply each disguise: enforcing
access control for disguising is left to the application.
\lyt{It seems most reasonable for the application to enforce AC for the disguising API the
application exposes to the client?}

\vspace{6pt}\noindent
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.
\end{enumerate}

\noindent For each \op{d}, the application developer specifies:
\begin{itemize}
    \item An associated predicate over the application database that selects \op{d}'s input
        objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The corresponding principal(s) that should have the capability to access \op{d}'s
        generated disguise change or correlation record.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Database Diffs.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Every \op{d} produces a \emph{database diff} \tdata{p\delta_i} associated with the disguise instance $\delta$ and a principal $p$. 

Each \tdata{p\delta_i} contains the ID of the disguise instance, the associated principal $p$'s ID,
and a random nonce.
%
In addition to this data, a decorrelation \tdata{p\delta_i} contains the created pseudoprincipal's
ID; a removal \tdata{p\delta_i} contains the removed object's value; and a modification
\tdata{p\delta_i} contains the old and new value of the modified object.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Diff Access Control.} 

\head{Securing Access to Database Diffs.} 
\sys secures database diffs with data capabilities \dcapa{p\delta_i}.
\sys represents a data capability \dcapa{p\delta_i} as a symmetric key specific to
the disguise instance and principal.
%
\sys encrypts \tdata{p\delta_i} with the \dcapa{p\delta_i}. The diff's nonce ensures safety against
known-plaintext attacks. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Disguise History.}
\sys's design may leak information that $\delta_i$ disguised principal $p$ 
because an adversary may learn that ciphertexts for %\dcapa{p\delta_i} and
\tdata{p\delta_i} exist for a particular $p$ and $\delta_i$.
This is a problem: for example, \sys should not store information that a principal $p$ has
invoked GDPR deletion.

To avoid this problem, \sys stores 
%(1) the \dcapa{p\delta_i} ciphertext and (2) 
an array of \tdata{p\delta_i} ciphertexts at random location pointed to by locating capability
\lcapa{p\delta_i}.  This dissociates one disguise applied to a principal $p$ from all other
disguises, so an adversary only ever learns about a single disguise instance if \sys gains
permission to reveal or compose upon that disguise instance.

Note that an adversary without access to any \lcapa{p\delta_i} can learn that $n$ diffs exist for
\emph{some} $p$ and $\delta_i$, but cannot directly identify which $p$ or $\delta_i$.
If an adversary has access to \lcapa{p\delta_i}, the adversary can learn that $\delta_i$
applied to $p$, and the number of \tdata{p\delta_i} diffs for that $p$ and $d$. This metadata is out of scope of our threat model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storage of \dcapa{p\delta_i} and \lcapa{p\delta_i}.} 
\sys should not store \dcapa{p\delta_i} or \lcapa{p\delta_i}: an adversary could then
learn that $\delta_i$ has applied to principal $p$. Thus, these capabilities must be stored externally,
even when no client speaking for $p$ is currently online.
%
%The only exception to this occurs when $p$ is a pseudoprincipal: in this case, \sys saves a
%(globally accessible) mapping from $p$ to \lcapa{p\delta_i}. This leaks the disguise history of
%pseudoprincipals, but is allowable because pseudoprincipals' data has already been decorrelated from their
%original principal owner.
%
To communicate these capabilities to a client,
\sys can email (or otherwise communicate) \lcapa{p\delta_i} to a party that can authenticate as $p$. 
\lyt{This assumes that every real user must have an email; alternatively, this could be offloaded to
the application.}
%If no email is present (\eg $p$ is a pseudoprincipal), \sys can save a (globally accessible) mapping from $p$ to \lcapa{p\delta_i}; this leaks disguise-principal associations, but
%only for pseudoprincipals whose data is already decorrelated from their original principal owner.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Which Use Cases and Security Properties Have We Achieved?}
As the current design stands, \sys supports ``Per-User, GDPR-Compliant Disguising and
Revealing,'' ``Universal Disguising and Revealing,'' ``Per-User Revealed Views and
Permissions,'' and ``Disguising of Decorrelated Data.''

Application developers can write GDPR-compliant and/or universal disguises with the primitives
exposed by \sys to write disguise specifications.
%
\sys can then use the produced disguise diffs to reveal data when authorized to do so, and when
revealing does not revert updates made to the data since the time of disguise application.

Finally, we see that \sys can now also support the API discussed in \S\ref{s:api}, where
applications can also query \sys to check accessible diffs for ownership properties.  This also
allows \sys to disguise decorrelated data: the same server-side API call used by the application to
check ownership requires \sys to be able to parse ownership information from decorrelation diffs.
Thus, \sys can determine temporary ownership in order to disguise decorrelated data, as long as \sys
has access to decorrelation diffs (by the client providing the appropriate capability pairs).

Furthermore, \sys does this while meeting all security goals: \sys supports authorized disguises and
ensures the security of ownership claims, disguise diffs, and disguise history.

Our current design falls short, however, by failing to support ``Sequences of Disguises,'' which we
explain next.

%\begin{itemize}
%\item \fn{diffID}: unique ID for this diff
%\item \fn{disguiseID}: ID of disguise $d$ being applied
%\item \fn{principalID}: associated principal $p$
%\item \fn{objID}: unique ID for the data object modified by \op{d}
%\item \fn{updateType}: decorrelate, modify, or remove
%\item \fn{oldValue}: original value of object \fn{objID}
%\item \fn{newValue}: updated value of object \fn{objID}
%\item \fn{nonce}: random value generated to prevent known-plaintext attacks
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Supporting Sequences of Disguises}

To apply one disguise on top of another in a way that supports, \eg universal decorrelation after
account pseudonymization, \sys must support \emph{pseudoprincipal diffs}, namely diffs 
associated with pseudoprincipals. 

These diffs can occur after at least one disguise has been applied: subsequent disguises may
associate diffs with pseudoprincipals. For example, after account pseudonymization, every user account
 with a paper or review is a pseudoprincipal user. When \sys applies universal decorrelation,
 decorrelation of all papers and reviews generates correlation diffs for these pseudoprincipals.

This causes a problem: because diffs are encrypted with \dcapa{p\delta_i} and stored at
\lcapa{p\delta_i}, capabilities are emailed or otherwise sent to (potentially offline) clients
so \sys never holds onto capabilities. However, pseudoprincipals have no corresponding real user
(and \sys cannot store which real user each pseudoprincipal corresponds with to provide
unlinkability), so \sys has no way to communicate capabilities to a real user!
%, so pseudoprincipals' capabilities can either be insecurely stored by \sys, or lost forever!

To solve this issue, \sys has a couple options:
\begin{itemize}
    \item \sys can store \pcapa{p\delta_i} for pseudoprincipal $p$. This means
        an adversary will be able to learn $p$'s undisguised data, even if it had been disguised by
        $\delta_i$.

    \item \sys can throw away \pcapa{p\delta_i} for pseudoprincipal $p$. This means that the
        disguise modifications are permanent, and no links (to determine ownership) between
        $p$ and other pseudoprincipals can be made.

    \item \sys can use asymmetric encryption to grant a client access to encrypted pseudoprincipal
        $p$'s \pcapa{p\delta_i}. In this scheme, each principal (real or pseudo) has an associated private-public
        key pair, of which \sys knows only the public key. 

        When a pseudoprincipal $p$ is generated to decorrelate data from $q$, \sys also generates a
        keypair (\pubk{p}, \privk{p}) for $p$, and encrypts \privk{p} with the original principal
        $q$'s public key \pubk{q}. \sys stores the
        resulting ciphertext as part in $q$'s metadata storage (\eg associated with $q$' account).
        Thus, only a user with access to $q$'s account can decrypt and access private key \privk{p}.

        \sys then encrypts \pcapa{p\delta_i} with \pubk{p} and stores the ciphertext, allowing \sys
        to avoid the need to send capabilities to some email address, while retaining strong
        security of $p$'s database diffs.

        A client speaking for $q$ first needs to prove it can access \privk{p} by decrypting the
        \privk{p} ciphertext with \privk{q}.  Only then can the client decrypt the encrypted
        \pcapa{p\delta_i} associated with pseudoprincipal $p$ with the decrypted \privk{p}.
        \pcapa{p\delta_i} then gives the client the ability to reveal, disguise, or perform
        application actions with access to diffs from $\delta_i$ applying to $p$.

        This introduces another round-trip for any client using the API: a client speaking
        for $q$ that wants to reveal or compose on top of pseudoprincipal diffs must (1) query for
        all pseudoprincipal \privk{p} ciphertexts associated with $q$, (2) retrieve the capabilities
        corresponding to all pseudoprincipals $p$, and (3) actually invoke the action with the
        decrypted capability pairs.
\end{itemize}

\iffalse
\head{Decorrelation and Locked Private Keys.}
Decorrelation generates a public-private key pair \pubk{q} and \privk{q} for pseudoprincipal $q$
created during decorrelation.
\sys stores \pubk{q} associated with $q$'s user ID, and puts \privk{q} in a \emph{locked private key}
associated with the original principal $p$ and $q$, notated as \tpriv{p}{q}. \tpriv{p}{q} contains the
pseudoprincipal's ID and private key, along with a random nonce, which are all encrypted with \pubk{p}:
%\begin{itemize}
%\item \fn{principalID}: original principal $p$
%\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
%\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
%\item \fn{nonce}: random value generated to prevent known-plaintext attacks
%\end{itemize}
Because \tpriv{p}{q} is encrypted with \pubk{p}, only a client who has
\privk{p} can access pseudoprincipal $q$'s private key \privk{q}.


\head{Protecting \dcapa{p\delta_i} when stored by \sys.}
\lyt{We need public keys here so that \sys does not hold onto keys that can decrypt for pseudoprincipals!!}
\sys then encrypts \dcapa{p\delta_i} with public key \pubk{p}.  
%
Thus, only a client who has \privk{p} can decrypt the data capability, and return in the capability pair the plaintext symmetric key that enables \sys to decrypt $p$'s database diffs produced from applying $d$.

%\sys stores all global \tdata{p\delta_i} tokens in plaintext, where any party can access it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Acquiring Pseudoprincipal Capabilities}
As discussed above, \sys can access locating capabilities \lcapa{q\delta_i}s for pseudoprincipal $q$ without a
client providing it. 
%
However, a client still needs to acquire \dcapa{q\delta_i} for \sys to have full capability pairs
to disguise, reveal, or otherwise act on behalf of pseudoprincipal $q$.

\sys adds a \fn{GetPrincipalLockedPrivateKeys} Client API call, which returns all locked private
keys \tpriv{p}{q} generated when decorrelating data from $p$.
A client then must prove it has \privk{p} to decrypt \tpriv{p}{q} and extract pseudoprincipal ID $q$ and \privk{q}.

With $q$ and \privk{q}, the client can get all encrypted \dcapa{q\delta_i} for all $\delta_i$, and
provide these to \sys so \sys has the full capability pair \pcapa{q\delta_i}. With
this pair, \sys can retrieve diffs or establish ownership for $q$'s data.

\lyt{TODO: Add an internal server-side API call that retrieves globally accessible location capabilities?}

%-------------------------------------------------------------------------------
\subsection{Does this design achieve our security goals?}
\label{sec:achievegoals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Authorized Disguises.}}
\sys ensures that only properly authenticated clients speaking for authorized principals can apply or
reveal a disguise, achieving security goal (1).

\vspace{6pt}\noindent\textbf{\emph{(2/3) Secure Ownership and Secure Disguise Diffs.}}
\lcapa{p\delta_i} is required to find the encrypted \dcapa{p\delta_i}---a symmetric key
specific to each disguise instance $\delta$ and principal $p$ encrypted with \pubk{p}.
Because \sys encrypts \tdata{p\delta_i} diffs associated with $p$ with \dcapa{p\delta_i}, a client
needs to first decrypt $\dcapa{p\delta_i}$ with \privk{p}, and then hand the pair \pcapa{p\delta_i}
to \sys for \sys to decrypt of $p$'s diffs from $\delta_i$.

Thus, \sys ensures that only clients who can provide \lcapa{p\delta_i} and \dcapa{p\delta_i} (and,
by consequence, have \privk{p}) can access $p$'s disguise diffs, or learn what data objects $p$ and
own. 

\vspace{6pt}\noindent\textbf{\emph{(4) Privacy of Disguise History.}}
We describe how \sys hides which disguises affect each principals' data by requiring a client to
provide a locating capability \lcapa{p\delta_i} in order to find encrypted data from disguise $d$ applied
to (non-pseudoprincipal) $p$. Because \sys does not store these locations, and the locationsare per-disguise, \sys
cannot link different disguises' encrypted data to the same principal.

\begin{table}[t!]
\centering
\begin{tabular}{ c | c c }
    & \multicolumn{2}{c}{\textbf{\tdata{p\delta_i} Token Access}}\\
\textbf{Client Proof}& \textbf{Global} & \textbf{Private to $p$}\\
\hline
    $\emptyset$ & plaintext & \\
    \privk{p} & plaintext & \\
    \dcapa{p\delta_i} & plaintext & ciphertext \\
    \privk{p}, \dcapa{p\delta_i} & plaintext & plaintext \\
\end{tabular}
\vspace{6pt}
\caption{Client access to disguise $d$'s tokens, depending on what proof the client can provide and the state of the tokens.}
\label{tab:access}
\end{table}

Table~\ref{tab:access} illustrates which clients can access a disguise $d$'s tokens, depending on
what the client presents as proof, and the state of the tokens.

\sys ensures that private tokens are properly secured such that only a client with private key
\privk{p} and capability \dcapa{p\delta_i} can access tokens produced by disguise $d$ associated with $p$.
%
Furthermore, \sys ensures that only a client with capability \dcapa{p\delta_i} can learn if a disguise $d$
applies to principal $p$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storing \tpriv{p}{q} Tokens.}
\tpriv{p}{q} tokens are encrypted with \pubk{p} and the resulting ciphertexts stored in one array
corresponding to the original principal $p$. These token ciphertexts are not separated by disguise
as \tdata{p\delta_i} ciphertexts are, since \tpriv{p}{q} tokens grant the holder authorization to access
tokens from any disguise for pseudoprincipal $q$.

\sys (and equivalently an attacker) cannot learn which disguises applied to principal $p$ from
observing the array of \tpriv{p}{q} ciphertexts. However, \sys can learn how many disguises were
applied to---and in particular, decorrelated---$p$'s data, as well as the number of pseudoprincipals
in the system linked to $p$. This metadata is out of scope of our threat model.
\fi
