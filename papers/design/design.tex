
%-------------------------------------------------------------------------------
\section{Threat Model}
%-------------------------------------------------------------------------------
An adversary can access any data stored as plaintext by the application or Edna, including data not
exposed via its client-facing API. We assume that an adversary cannot access prior snapshots of the
application database, or observe modifications or memory accesses performed during disguise
application. Furthermore, undisguised content and implicit correlations based on this content (e.g.,
a comment that mentions the authorâ€™s name) are out of scope.

We assume Edna is honest but curious: when applying or reversing a disguise, Edna may temporarily
hold (in memory) plaintext token data, as well as private or symmetric keys, but is trusted to
forget them once the disguise action is complete.  

Finally, we assume standard security of public key and symmetric key primitives~\note{under a random
oracle model?}.

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.75\linewidth} }
\textbf{Symbol} & \textbf{Description} \\
\hline
$p$ & a principal, namely an application user who owns DB objects of the application \\
$\pubk_p$ & public key of $p$ \\
$\privk_p$ & private key of $p$ \\
$d$ & a disguise \\
\globalop{d} & an operation of disguise $d$ (either a removal, modification, or decorrelation
    operation) that is globally-revealable: all parties can learn what data updates \globalop{d}
    performed.\\
\privop{d} & an operation of disguise $d$ (either a removal, modification, or decorrelation
    operation) that is private: only principals whose data \privop{d} updates can learn
    what updates \privop{d} performed.\\
\tdata{pd} & token storing undisguised data belonging to $p$.
    Every disguise operation generates a \tdata{pd} for every principal $p$ whose data the operation
    updates.\\
    & If a \globalop{d} produces \tdata{pd}, Edna stores \tdata{pd} in plaintext\\
    & If a \privop{d}
    produces \tdata{pd}, Edna stores \tdata{pd} such that only $p$ can access \tdata{pd}.\\
    \tpriv{pdp'} & token storing private key $\pubk_{p'}$. Produced when a \globalop{d} or \privop{d} 
    decorrelates data from $p$ and creates a new anonymous principal $p'$ with corresponding private key $\pubk_{p'}$.
Enda always stores \tpriv{pdp'} such that only $p$ can access \tpriv{pdp'}.\\
$\key_{pd}$ & symmetric key used to encrypt private \tdata{pd} and \tpriv{pdp'} tokens \\
$\ek_{pd}$ & $\key_{pd}$ encrypted with $\pubk_p$\\
\end{tabular}
    \vspace{12px}
\caption{Notation used in disguise protocols}
\label{tab:notation}
\end{table*}

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.7\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($\pubk_p$)} & Registers $p$ as a principal whose data can be privately disguised. \\
    \fn{StartDisguise($d$, Option<$p$>)} & Begins the process of applying disguise $d$, optionally 
    on behalf of principal $p$.\\
    \fn{StartDisguiseReversal(\{$d$, Option<$p$>\})} & Begins the process of reversing disguise $d$,
    optionally on behalf of principal $p$.\\
    \fn{RequestTokenAccess(\{$\ek_{pd}$\})} & Sent from Edna to a client authenticated as
    $p$, requesting the client decrypt the $\ek_{pd}$ with $\privk_p$ and uncover the
    corresponding $\key_{pd}$s. \\
    \fn{GrantTokenAccess(\{$\key_{pd}$\})} & Grants Edna permission, for all $\key_{pd}$, to decrypt any
    privately-stored \tdata{pd} and \tpriv{pdp'} with $\key_{pd}$.\\
\end{tabular}
    \vspace{12px}
\caption{API Calls for Client Authenticated as Principal $p$}
\label{tab:api}
\end{table*}

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.75\linewidth} }
\textbf{Function} & \textbf{Description} \\
\hline
    \fn{StorePubKey($\pubk_p$)} & Persistently saves the public key $\pubk_p$ along with the principal
    ID $p$.\\
    \fn{LoadEncKeys($p$)} & Retrieves all encrypted keys $\ek_{pd}$ persisted in Edna's storage for
    all disguises $d$ applied to $p$'s data.\\
    \fn{ReadPrivateTokens($\key_{pd}$)} & Decrypts all of $p$'s private tokens produced by disguise
    $d$. \\
    \fn{ReadGlobalTokens($p, d$)} & Retrieves $p$'s global tokens produced by disguise $d$. \\
    \fn{ApplyDisguise($d$, \{\tdata{}\})} & Applies disguise $d$, selectively composing $d$'s
    updates with prior disguises using data recorded in the set of \tdata{} tokens. 
    \\
    \fn{ReverseDisguise($d$, \{\tdata{}\})} & Reverses disguise $d$ using data
    recorded in the set of \tdata{} tokens.
\end{tabular}
    \vspace{12px}
\caption{Internal Edna Functions}
\label{tab:funcs}
\end{table*}

%-------------------------------------------------------------------------------
\section{Disguise Protocols}
%-------------------------------------------------------------------------------
\createpseudocodeblock{pcb}{center,boxed}{}{}{}
\createprocedureblock{procb}{center,boxed}{}{}{}

\begin{figure*}[h!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
(\pubk_p, \privk_p) \sample \kgen() \<\< \\
\< \sendmessageright*{\texttt{RegisterPrincipal(p, $\pubk_p$)}} \< \\
\<\< \texttt{StorePubKey($\pubk_p$)}
}
\caption{
    \textbf{Principal Public Key Registration.}
Every principal in the system must register a public key with Edna in order to later reveal (for
disguise reversal or composition) any of its non-globally disguised data. Edna remembers each public key \texttt{pk}$_p$, indexed by the 
principal ID $p$.
}
\label{fig:acctreg}
\end{figure*}

\paragraph{1p Disguise Application.}
When a 1st party (authenticated as some principal $c$) wishes to apply a disguise $d$, the
client invokes the \texttt{ApplyDisguise} API call. 

Prior to applying the disguise, Edna requests to access tokens owned by the client. It does so by
sending a \texttt{AuthorizeToken}-\texttt{AccessRequest} to the invoking client $c$ with the all ciphertexts of 
encrypted symmetric keys \texttt{enck}$_{cd'}$ from all prior disguises $d'$. If the client
authorizes Edna to access its tokens from disguise $d'$, the client decrypts \texttt{enck}$_{cd'}$
to get \texttt{k}$_{cd'}$. All plaintext symmetric keys are sent back to Edna via an
\texttt{AuthorizeTokenAccessReply}. 
Using each \texttt{k}$_{cd'}$, Edna can decrypt the tokens produced by disguise $d'$ and use them
in disguise composition when applying disguise $d$ (See Fig~\ref{fig:algos} for a description of Edna's
token retrieval and disguise application algorithms).

Fig~\ref{fig:disgapp1p} illustrates this protocol.

\paragraph{3p Disguise Application.}
When a 3rd party wishes to apply a disguise $d$, a 3rd party cannot authorize access to any encrypted user data tokens, so Edna does not
send a \texttt{AuthorizeToken}\texttt{AccessRequest}. Instead, Edna simply applies the disguise  
without any keys to decrypt tokens (See Fig~\ref{fig:algos} for a description of Edna's
token retrieval and disguise application algorithms).

Fig~\ref{fig:disgapp3p} illustrates this protocol.

\paragraph{1p Disguise Reversal.}
When a 1st party (authenticated as some principal $c$) wishes to reverse a disguise $d$, the client
invokes the \texttt{ReverseDisguise} API call. Edna then retrieves all tokens of the client's that
it can access for all disguises up to and including $d$. It does so by sending a
\texttt{AuthorizeToken}\texttt{AccessRequest} to the invoking client $c$ with the all ciphertexts of
encrypted symmetric keys \texttt{enck}$_{cd'}$ from all disguises $d'$ before and including $d$. If
the client authorizes Edna to access its tokens from disguise $d'$, the client decrypts
\texttt{enck}$_{cd'}$ to get \texttt{k}$_{cd'}$. All plaintext symmetric keys are sent back to Edna
via an \texttt{AuthorizeToken}-\texttt{AccessReply}. 

Using each \texttt{k}$_{cd'}$, Edna can decrypt the tokens produced by disguise $d'$ and use them to
reverse the disguise $d$ (See Fig~\ref{fig:algos} for a description of Edna's token retrieval and
disguise reversal algorithms).

Fig~\ref{fig:revdisg1p} illustrates this protocol.

\paragraph{3p Disguise Reversal.}
When a 3rd party wishes to reverse a disguise $d$, Edna can only access those tokens stored as
plaintext. 
Fig~\ref{fig:revdisg3p} shows the protocol to reverse a disguise when a disguise is 1p-revealable.


\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{1stParty c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ApplyDisguise(c,d)}} \< \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\privk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{composition\_tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ApplyDisguise($d$,composition\_tokens)}
}
\caption{1p protocol for disguise application}
\label{fig:disgapp1p}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{3rdParty} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ApplyDisguise(*,d)}} \< \\
\<\< \texttt{composition\_tokens} \gets \texttt{ReadTokens([]))} \\
\<\< \texttt{ApplyDisguise($d,$composition\_tokens)}
}
\caption{3p protocol for disguise application}
\label{fig:disgapp3p}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{1stParty c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ReverseDisguise(c,d)}} \< \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\privk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ReverseDisguise($d$,tokens)}
}
\caption{1p protocol for disguise reversal}
\label{fig:revdisg1p}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{3rdParty} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ReverseDisguise(*,d)}} \< \\
\<\< \texttt{tokens} \gets \texttt{ReadTokens([]))} \\
\<\< \texttt{ReverseDisguise($d$,tokens)}
}
\caption{3p protocol for disguise reversal}
\label{fig:revdisg3p}
\end{figure*}

%-------------------------------------------------------------------------------
\subsection{Algorithms}
%-------------------------------------------------------------------------------
\paragraph{ReadTokens.} Edna is given a set of plaintext symmetric keys, indexed by principal and disguise
ID. For each key \texttt{key}$_{cd}$, Edna decrypts all tokens produced by the application of disguise
$d$ to principal $c$'s data with \texttt{key}$_{cd}$. 

If the token stores \texttt{sk}$_{c'}$, the private key of a
anonymous principal $c'$ generated during $d$'s application, Edna decrypts with \texttt{sk}$_{c'}$
all the symmetric keys produced when disguising $c'$'s data. Edna then recursively uses these
symmetric keys to read all of $c'$'s tokens, appending the result to the set of tokesn to
return.

Otherwise, Edna simply adds the token to the set of tokens to return. 

This is shown in Fig~\ref{fig:algos}.

\lyt{I should maybe add another subfunction of ApplyDisguise that shows how exactly
disguise operations produce various types of tokens, such as these private key tokens.}

\paragraph{ApplyDisguise.} Edna applies a disguise given the disguise specification and available tokens
for composition by interating through all disguise operations in the specification.

For each principal $c$ whose data is touched by the disguise, Edna generates a principal- and disguise-specific symmetric key \texttt{k}$_{cd}$, encrypts it with \texttt{pk}$_c$, and stores the ciphertext. This ensures that only a client with the correct private key can decrypt and access
\texttt{k}$_{cd}$. 

Edna then applies each disguise operation, producing tokens for each operation. If the disguise is
1p-revealable, Edna encrypts tokens with the corresponding principals' \texttt{k}$_{cd}$s and stores
these tokens as the tails of the principals' linked list of
encrypted tokens. This is shown in Fig~\ref{fig:algos}.

If the disguise is 3p-revealable, Edna simply stores the token plaintexts.


\begin{figure*}
\procb{\texttt{ReadTokens(keys)}}{
    \< \\
\texttt{tokens} \gets []\\
\pcfor \texttt{$\key_{cd}$ in keys:} \\
\t[1]\texttt{encToken} \gets \texttt{LoadEncTokenListTail}(c,d)\\
\t[1]\pcwhile \texttt{encToken != NULL:}\\
\t[2]\texttt{token} \gets \dec(\key_{cd}, \texttt{encToken})\\
\t[2]\texttt{encToken} \gets \texttt{token.nextEncToken}\\
\t[2]\pcif \texttt{token.type = AnonPrivateKey:}\\
\t[3]c' \gets \texttt{token.anon\_uid}\\
\t[3]\privk_{c'} \gets \texttt{token.priv\_key}\\
\t[3]\texttt{keys}' \gets []\\
\t[3]\pcforeach d':\\
\t[4]\texttt{enck} \gets \texttt{LoadEncKey}(c',d')\\
\t[4]\texttt{keys}'\texttt{.append}(\dec(\privk_{c'}, \texttt{enck}))\\
\t[4]\texttt{tokens.extend(ReadTokens(keys}'))\\
\t[3]\pcendforeach\\
\t[2]\pcelse:\\
\t[3]\texttt{tokens.append(token)}\\
\t[2]\pcfi\\
\t[1]\pcendwhile\\
\pcendfor\\
\texttt{tokens.append(GetGlobalTokens())}\\
\pcreturn \texttt{tokens}\\
}{}

\procb{\texttt{ApplyDisguise}$(d$,\texttt{composition\_tokens})}{
    \< \\
\t[0]\pcfor \texttt{op}_{c} \in \texttt{GetDisguise($d$)}:\\
\t[1]\pcif \texttt{LoadEncKey($c,d$) = NULL}:\\
\t[2] \key_{cd} \sample \kgen() \\
\t[2] \pubk_{c} \gets \texttt{LoadPubKey}(c) \\
\t[2] \texttt{enck$_{cd}$} \gets \enc(\pubk_c, \key_{cd}) \\
\t[2] \texttt{StoreEncKey(enck$_{cd}$)} \\
\t[1]\pcfi\\
\t[1]\key_{ck} \gets \texttt{LoadEncKey($c,d$)}\\
\t[1]\texttt{token} \gets \texttt{op$_{c}$.execute(composition\_tokens)}\\
\t[1]\texttt{token.nextEncToken} \gets \texttt{LoadEncTokenlistTail}(c,d)\\
\t[1]\texttt{token.nonce} \gets \texttt{RandomU64}()\\
\t[1]\texttt{encToken} \gets \enc(\key_{cd}, \texttt{token})\\
\t[1]\texttt{StoreEncTokenListTail}(c,d,\texttt{encToken})\\
\pcendfor
}{}

\procb{\texttt{ReverseDisguise}$(d$,\texttt{tokens})}{
    \< \\
    \texttt{Apply missed updates from disguise log to tokens of disguise $d$}\\
    \texttt{Reveal data in tokens of disguise $d$}\\
    \texttt{Undo modifications to any prior disguise's tokens by disguise $d$}
}{}

\caption{Edna Algorithms (assuming all tokens are user-vault encrypted tokens, and ignoring global vault tokens for now)}
\label{fig:algos}
\end{figure*}
