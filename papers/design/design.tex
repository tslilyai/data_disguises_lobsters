%-------------------------------------------------------------------------------
\section{System Components}
%-------------------------------------------------------------------------------
\begin{itemize}
\item Disguising Tool (``Edna''): adds support for disguise API calls to applications.
\item Principal: an application user account that owns DB objects that are correlated via e.g., foreign key relationships to the account.
\item Client: external devices that contact the application via the application API, and can be authenticated to speak for one or more principals via the application authentication protocol (e.g., logging in with a password, or using access tokens to establish a session).
\item Tokens: 
\begin{itemize}
    \item Correlation tokens (linking an old principal to a created principal from disguise decorrelation operations). These tokens give Edna the ability to disguise the data of these principals when disguising the data of P, or to permanently recorrelate data back with P.
    \item Data tokens save the pre-modified or removed data. These tokens give Edna the ability to compose a future disguise on top of the original data, or permanently restore the original data.
    \item Private key tokens save the private key of a created anonymous principal
\end{itemize}
\item Disguise Capabilities have two forms, and can be held by a 1st-party (a client acting on
behalf of a principal) or 3rd-party (e.g., the application).
\begin{itemize}
\item Application Capability: authorizes the holder to apply a disguise.
\item Revealing Capability: authorizes the holder to reveal disguised data.
\end{itemize}
If a disguise is 1st-party-revealable, no 3rd-party actor can reveal data disguised when applying the
disguise.
If a disguise is 3rd-party-revealable, both 1st- and 3rd-party actors can reveal data disguised when applying the
disguise.
\end{itemize}

%-------------------------------------------------------------------------------
\section{Threat Model}
%-------------------------------------------------------------------------------
An adversary can access any data stored as plaintext by the application or Edna, including data not exposed via its
client-facing API. We assume that an adversary cannot access prior snapshots of the application database, or observe modifications or memory accesses performed during disguise application. Furthermore, undisguised content and implicit correlations based on this content (e.g., a comment that mentions the authorâ€™s name) are out of scope.

We assume Edna is honest but curious: when applying or reversing a disguise, Edna may temporarily
hold (in memory) plaintext token data, as well as private or symmetric keys, but is trusted to
forget them once the disguise action is complete.  

Finally, we assume standard security of public key and
symmetric key primitives~\note{under a random oracle model?}.

%-------------------------------------------------------------------------------
\section{Edna-Client Protocols}
%-------------------------------------------------------------------------------
\createpseudocodeblock{pcb}{center,boxed}{}{}{}
\createprocedureblock{procb}{center,boxed}{}{}{}

\begin{figure}[h!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
(\pk_c, \sk_c) \sample \kgen() \<\< \\
\< \sendmessageright*{\texttt{RegisterClient(c, $\pk_c$)}} \< \\
\<\< \texttt{StorePubKey($\pk_c$)}
}
\caption{Client protocol for public key registration}
\label{fig:acctreg}
\end{figure}

\paragraph{Client Public Key Registration.}
Every principal in the system must register a public key with Edna in order to later reveal (for disguise reversal or
composition) any of its data disguised by 1p-revealable disguises (Fig~\ref{fig:acctreg}).

\paragraph{Client Disguise Application.}
(Fig~\ref{fig:disgapp} shows the protocol when a disguise is 1p-revealable).

\paragraph{Client Disguise Reversal.}
(Fig~\ref{fig:revdisg} shows the protocol to reverse a disguise when a disguise is 1p-revealable).

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ApplyDisguise(c,d)}} \< \\
\<\< \key_{cd} \sample \kgen() \\
\<\< \pk_{c} \gets \texttt{LoadPubKey}(c) \\
\<\< \texttt{enck$_{cd}$} \gets \enc(\pk_c, \key_{cd}) \\
\<\< \texttt{StoreEncKey(enck$_{cd}$)} \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\sk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{composition\_tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ApplyDisguise($c,d,\key_{cd}$,composition\_tokens)}
}
\caption{Client protocol for disguise application}
\label{fig:disgapp}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client c} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\texttt{ReverseDisguise(c,d)}} \< \\
\<\< \forall d', \texttt{encks}[d']\gets \texttt{LoadEncKey}(c,d')\\
\< \sendmessageleft*{\texttt{AuthorizeTokenAccessRequest(encks)}} \< \\
\forall d'~\text{that the client authorizes token access}: \\
\texttt{keys}[d'] \gets \dec(\sk_c, \texttt{encks}[d']) \<\< \\
\< \sendmessageright*{\texttt{AuthorizeTokenAccessReply(keys)}} \< \\
\<\< \texttt{tokens} \gets \texttt{ReadTokens(keys))} \\
\<\< \texttt{ReverseDisguise($c,d$,tokens)}
}
\caption{Client protocol for disguise reversal}
\label{fig:revdisg}
\end{figure*}


%-------------------------------------------------------------------------------
\subsection{Algorithms}
%-------------------------------------------------------------------------------
Fig~\ref{fig:algos} shows pseudocode for Edna's algorithms to retrieve and store tokens during
disguise application and reversal.

\begin{figure*}
\procb{\texttt{ReadTokens(keys)}}{
    \< \\
\texttt{tokens} \gets []\\
\pcfor \texttt{$\key_{cd}$ in keys:} \\
\t[1]\texttt{encToken} \gets \texttt{LoadEncTokenListTail}(c,d)\\
\t[1]\pcwhile \texttt{encToken != NULL:}\\
\t[2]\texttt{token} \gets \dec(\key_{cd}, \texttt{encToken})\\
\t[2]\texttt{encToken} \gets \texttt{token.nextEncToken}\\
\t[2]\pcif \texttt{token.type = AnonPrivateKey:}\\
\t[3]c' \gets \texttt{token.anon\_uid}\\
\t[3]\sk_{c'} \gets \texttt{token.priv\_key}\\
\t[3]\texttt{keys}' \gets []\\
\t[3]\pcforeach d':\\
\t[4]\texttt{enck} \gets \texttt{LoadEncKey}(c',d')\\
\t[4]\texttt{keys}'\texttt{.append}(\dec(\sk_{c'}, \texttt{enck}))\\
\t[4]\texttt{tokens.extend(ReadTokens(keys}'))\\
\t[3]\pcendforeach\\
\t[2]\pcelse:\\
\t[3]\texttt{tokens.append(token)}\\
\t[2]\pcfi\\
\t[1]\pcendwhile\\
\pcendfor\\
\pcreturn \texttt{tokens}\\
}{}

\procb{\texttt{ApplyDisguise}$(c,d,\key_{cd}$,\texttt{composition\_tokens})}{
    \< \\
\pcfor \texttt{op} \in \texttt{GetDisguise($d$)}\\
\t[1]\texttt{token} \gets \texttt{op.execute($c$,composition\_tokens)}\\
\t[1]\texttt{token.nextEncToken} \gets \texttt{LoadEncTokenlistTail}(c,d)\\
\t[1]\texttt{token.nonce} \gets \texttt{RandomU64}()\\
\t[1]\texttt{encToken} \gets \enc(\key_{cd}, \texttt{token})\\
\t[1]\texttt{StoreEncTokenListTail}(c,d,\texttt{encToken})\\
\pcendfor
}{}

\procb{\texttt{ReverseDisguise}$(c,d$,\texttt{tokens})}{
    \< \\
    \texttt{Apply missed updates from disguise log to tokens of disguise $d$}\\
    \texttt{Reveal data in tokens of disguise $d$}\\
    \texttt{Undo modifications to any prior disguise's tokens by disguise $d$}
}{}

\caption{Edna Algorithms (assuming all tokens are user-vault encrypted tokens, and ignoring global vault tokens for now)}
\label{fig:algos}
\end{figure*}
