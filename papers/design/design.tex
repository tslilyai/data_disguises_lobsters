% TODO add description of what token contents contain

%-------------------------------------------------------------------------------
\section{Threat Model}
%-------------------------------------------------------------------------------
An adversary can access any data stored as plaintext by the application or Edna, including data not
exposed via its client-facing API. We assume that an adversary cannot access prior snapshots of the
application database, or observe modifications or memory accesses performed during disguise
application. Furthermore, undisguised content and implicit correlations based on this content (e.g.,
a comment that mentions the authorâ€™s name) are out of scope.

We assume Edna is honest but curious: when applying or reversing a disguise, Edna may temporarily
hold (in memory) plaintext token data, as well as private or symmetric keys, but is trusted to
forget them once the disguise action is complete.  

Finally, we assume standard security of public key and symmetric key primitives~\note{under a random
oracle model?}.

%----------------------------------------------------------%

\createpseudocodeblock{pcb}{center,boxed}{}{}{}
\createprocedureblock{procb}{center,boxed}{}{}{}

\begin{figure*}[h!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\texttt{RegisterPrincipal(p, $\pubk{p}$)}} \< \\
\<\< \texttt{StorePubKey($\pubk{p}$)}
}
\caption{
\textbf{Principal public key registration.}
Every principal in the system must register a public key with Edna in order to later reveal (for
disguise reversal or composition) any of privately disguised data. Edna remembers each public
    key \privk{p} along with $p$'s ID.}
\label{fig:acctreg}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client Authenticated as $p$} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\fn{StartDisguise($d$, Some($p$))}} \< \\
\<\< \eks_{p} \gets \fn{LoadEncKeys}(p)\\
    \< \sendmessageleft*{\fn{RequestTokenAccess($\eks_{p}$)}} \< \\
\texttt{k\_set} \gets \{\}\\
\forall d'~\text{that the client authorizes token access}: \\
    \quad\texttt{k\_set.insert}(\dec(\privk{p}, \texttt{encks}[d'])) \<\< \\
    \< \sendmessageright*{\texttt{GrantTokenAccess(\texttt{k\_set})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \texttt{tokens} \gets \{\}\\
\<\< \forall d'~\text{previously applied}: \\
    \<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
    \<\< \forall \key_{pd'} \in \texttt{k\_set}: \\
    \<\< \quad\texttt{tokens.insert(\fn{ReadPrivateTokens($\key_{pd'}$)})}\\ 
\<\< \texttt{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Authenticated disguise application.} 
    The client first invokes the \fn{StartDisguise} API call. 
    Prior to applying the disguise, Edna requests to access tokens owned by the client by
    sending a \fn{RequestTokenAccess} to the client with the set of $\eks_{p}$.
If the client authorizes Edna to access $p$'s private tokens from a prior disguise $d'$, the client decrypts
    $\ek_{pd'} \in \eks_{p}$ with \privk{p} to get $\key_{pd'}$. 
The client sends all decrypted $\key_{pd'}$s back to Edna via a \fn{GrantTokenAccess} API call. 
Edna uses each $\key_{pd'}$ to decrypt $p$'s private tokens produced by disguise $d'$,
    and compose operations of $d$ on $p$'s data on top of $d'$s.}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Unauthenticated Client} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\fn{StartDisguise($d$, None)}} \< \\
\<\< \texttt{tokens} \gets \{\}\\
\<\< \forall d'~\text{previously applied}: \\
    \<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \texttt{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Unauthenticated disguise application}. In contrast to authenticated disguise
    application, Edna does not request access to any private tokens, and instead simply applies the disguise  
    with only globally-accessible tokens.}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client Authenticated as $p$} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\fn{StartDisguiseReversal($d$, Some($p$))}} \< \\
\<\< \eks_{p} \gets \fn{LoadEncKeys}(p)\\
    \< \sendmessageleft*{\fn{RequestTokenAccess($\eks_{p}$)}} \< \\
\texttt{k\_set} \gets \{\}\\
\forall d'~\text{that the client authorizes token access}: \\
    \quad\texttt{k\_set.insert}(\dec(\privk{p}, \texttt{encks}[d'])) \<\< \\
    \< \sendmessageright*{\texttt{GrantTokenAccess(\texttt{k\_set})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \texttt{tokens} \gets \{\}\\
\<\< \forall d'~\text{previously applied}: \\
    \<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
    \<\< \forall \key_{pd'} \in \texttt{k\_set}: \\
    \<\< \quad\texttt{tokens.insert(\fn{ReadPrivateTokens($\key_{pd'}$)})}\\ 
\<\< \texttt{ReverseDisguise($d$,tokens)}
}
    \caption{\textbf{Authenticated disguise reversal.}
The client invokes the \texttt{StartDisguiseReversal} API call. 
Prior to reversing the disguise, Edna requests to access tokens owned by the client by
    sending a \fn{RequestTokenAccess} to the client with the set of $\eks_{p}$.
If the client authorizes Edna to access $p$'s private tokens from disguises $d'$ up to and including
    $d$, the client decrypts
    $\ek_{pd'} \in \eks_{p}$ with \privk{p} to get $\key_{pd'}$. 
The client sends all decrypted $\key_{pd'}$s back to Edna via a \fn{GrantTokenAccess} API call. 
Edna uses each $\key_{pd'}$ to decrypt $p$'s private tokens produced by disguise $d'$,
    and reverse the changes made by disguise $d$.}
\label{fig:revdisg1p}
\end{figure*}

\begin{figure*}
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Unauthenticated Client} \< \< \textbf{Edna} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\fn{StartDisguiseReversal($d$, None)}} \< \\
\<\< \texttt{tokens} \gets \{\}\\
\<\< \forall d'~\text{previously applied}: \\
    \<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \texttt{ReverseDisguise($d$,tokens)}
}
    \caption{\textbf{Unauthenticated disguise application}. In contrast to authenticated disguise
    reversal, Edna does not request access to any private tokens, and instead simply reverses the disguise  
    with only globally-accessible tokens.}
\end{figure*}

%-------------------------------------------------------------------------------
\section{Notes about Disguise Protocols}
%-------------------------------------------------------------------------------
\textbf{\emph{Why would disguise reversal require tokens from prior disguises?}} 
Note that the application of a disguise $d$ may modify the contents of prior disguise $d'$ tokens!
This can occur because some token \tdata{} may store removed data that, if in the database, would be
affected by the application of $d$. When $d$ is applied, \tdata{}'s data is updated to reflect the
modification by $d$; similarly, when $d$ is reversed, \tdata{}'s original contents are restored.

\begin{figure*}
\procb{\texttt{ReadPrivateTokens($\key_{pd}$)}}{
    \< \\
\texttt{tokens} \gets []\\
\t[0]\texttt{encToken} \gets \texttt{LoadEncTokenListTail}(p,d)\\
\t[0]\pcwhile \texttt{encToken != NULL:}\\
\t[1]\texttt{token} \gets \dec(\key_{pd}, \texttt{encToken})\\
\t[1]\texttt{encToken} \gets \texttt{token.nextEncToken}\\
\t[1]\pcif \texttt{token.type = AnonPrivateKey:}\\
\t[2]p' \gets \texttt{token.anon\_uid}\\
\t[2]\privk{p'} \gets \texttt{token.priv\_key}\\
\t[2]\eks_{p'} \gets \texttt{LoadEncKeys}(p')\\
\t[2]\pcforeach \ek_{p'd'} \in \eks_{p'}:\\
\t[3]\key_{p'd'} \gets \dec(\privk{p'}, \texttt{enck})\\
\t[3]\texttt{tokens.extend(ReadPrivateTokens($\key_{p'd'}$}))\\
\t[2]\pcendforeach\\
\t[1]\pcelse:\\
\t[2]\texttt{tokens.append(token)}\\
\t[1]\pcfi\\
\t[0]\pcendwhile\\
\texttt{tokens.append(GetGlobalTokens())}\\
\pcreturn \texttt{tokens}\\
}{}
\caption{\textbf{ReadPrivateTokens Pseudocode.} Using $\key_{pd}$, Edna decrypts all tokens produced by the application of $d$ to $p$'s data by iterating through a linked list encoded in the token contents.\\
If the decrypted token is a \tdata{pd}, Edna simply adds the token to the set of tokens to return. 
Otherwise, if the token is a \tpriv{pdp'}, then Edna learns the
private key \privk{p'} of anonymous principal $p'$ generated during $d$'s application. Edna uses
\privk{p'} to decrypt all $\key_{p'd'}$,  namely any symmetric keys used to encrypt
$p'$'s private tokens during application of any prior disguise $d'$.\\
    Edna then recursively reads all of $p'$'s private tokens by invoking \fn{ReadPrivateTokens}
    with $\key_{p'd'}$, and appends the result to the set of data tokens to return.\\
}
\end{figure*}

\begin{figure*}
\procb{\texttt{ApplyDisguise}($d$,\texttt{tokens})}{
\< \\
\t[0]\pcfor \texttt{op}_{p} \in \texttt{GetDisguise($d$)}:\\
\t[1]\pcif \texttt{LoadEncKey($p,d$) = NULL}:\\
\t[2] \key_{pd} \sample \kgen() \\
\t[2] \pubk{p} \gets \texttt{LoadPubKey}(c) \\
    \t[2] \texttt{enck$_{pd}$} \gets \enc(\pubk{p}, \key_{pd}) \\
\t[2] \texttt{StoreEncKey(enck$_{pd}$)} \\
\t[1]\pcfi\\
\t[1]\key_{pk} \gets \texttt{LoadEncKey($c,d$)}\\
\t[1]\texttt{token} \gets \texttt{op$_{p}$.execute(composition\_tokens)}\\
\t[1]\texttt{token.nextEncToken} \gets \texttt{LoadEncTokenlistTail}(c,d)\\
\t[1]\texttt{token.nonce} \gets \texttt{RandomU64}()\\
\t[1]\texttt{encToken} \gets \enc(\key_{pd}, \texttt{token})\\
\t[1]\texttt{StoreEncTokenListTail}(p,d,\texttt{encToken})\\
\pcendfor
}{}
\caption{\textbf{ApplyDisguise Pseudocode.} Edna applies a disguise given the disguise
specification and available \tdata{} tokens for composition.
For each principal $p$ whose data is touched by the disguise, Edna generates symmetric key
 $\key_{pd}$, encrypts it with \pubk{p}, and stores the resulting $\ek_{pd}$ ciphertext. This ensures that only a client with the correct private key can decrypt and access $\key_{cd}$. 
Edna then applies each disguise operation, producing tokens for each operation. If the disguise is
1p-revealable, Edna encrypts tokens with the corresponding principals' $\key_{pd}$s and stores
these tokens as the tails of the principals' linked list of
encrypted tokens. This is shown in Fig~\ref{fig:algos}.
If the disguise operation, Edna simply stores the token plaintexts.
}
\end{figure*}

\begin{figure*}
\procb{\texttt{ReverseDisguise}$(d$,\texttt{tokens})}{
    \< \\
    \texttt{Apply missed updates from disguise log to tokens of disguise $d$}\\
    \texttt{Reveal data in tokens of disguise $d$}\\
    \texttt{Undo modifications to any prior disguise's tokens by disguise $d$}
}{}

\caption{Edna Algorithms (assuming all tokens are user-vault encrypted tokens, and ignoring global vault tokens for now)}
\label{fig:algos}
\end{figure*}
