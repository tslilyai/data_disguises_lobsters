%-------------------------------------------------------------------------------
\section{Overview}
%-------------------------------------------------------------------------------

Our design considers \emph{disguisable application systems}, which consist of a typical database-backed
application with an integrated disguising tool (\sys).
We assume the following elements:
\begin{itemize}
    \item $d$: a disguise that can be applied or reversed via \sys's API. Disguises modify and remove
    application data to hide revealing information. 
    \item $p$: an application principal, corresponding to a user ID in the application. 
\end{itemize}

\noindent
%In normal database-backed applications, the application database contents completely capture data
%held by the system: the application acts as the sole creator and updater of database contents. 
A disguisable application system operates on three different categories of data:
\begin{enumerate}
    \item \emph{\textbf{Database Contents}}: The application reads and modifies database
        contents, which include visible, undisguised and currently-disguised daa.
        \sys modifies the data database contents when it applies and reveals disguises.
    \item \emph{\textbf{Disguise History}}: Data about which disguises \sys has applied or
        reversed, used for revealing and to compose disguises on top of one another. 
        %\sys stores the history in plaintext in the application database.
    \item \emph{\textbf{Disguise Tokens}}: Data generated by \sys's
        disguise application. Tokens encode information about disguise modifications to database
        contents, and \sys uses them to compose disguises on top of one another or to reveal a
        disguise. 
\end{enumerate}

%-------------------------------------------------------------------------------
\subsection{Security Goals}
%-------------------------------------------------------------------------------
We assume an attacker who, after compromising the system, can perform any actions the
application can perform, and access any data the application can access. This includes any data that
\sys enables the application to modify or access: the application and \sys have equivalent security
properties.

\sys is honest but curious: when applying or reversing a disguise, it may temporarily
hold (in memory) plaintext token data, but is trusted to forget it once the disguise is complete.
Finally, we assume standard security of public key and symmetric key primitives.

With this threat model, our goals are three-fold: 

\vspace{6pt}\noindent\textbf{\emph{(1) Security of Restricted Disguise Application.}}
We support disguises that require authentication as a principal $p$ prior to being applied (or
reversed). If so, only a client authenticated for principal $p$ can apply (and reverse) this
disguise (and an attacker unauthenticated as $p$ cannot).

\vspace{6pt}\noindent\textbf{\emph{(2) Security of Private Disguise Tokens.}}
Tokens are optionally private to a single principal $p$. 
\sys stores a public key \pubk{p} for every principal, and ensures that 
only a client who knows the corresponding private key \privk{p} access $p$'s
tokens generated by disguise $d$; an
attacker without \privk{p} cannot authorize access to private disguise tokens created prior to time
of compromise, even if authenticated as $p$.

\vspace{6pt}\noindent\textbf{\emph{(3) Security of Private Disguise Token Metadata.}}
Only a client with private key \privk{p} knows how many private disguise tokens correspond to
principal $p$. An attacker cannot learn how many tokens are associated with any principal prior to
time of compromise.

\vspace{6pt}\noindent\textbf{\emph{Non-Goals.}}
\begin{itemize}
    \item Security of private tokens or restricted disguises when an attacker has prior snapshots of system data.
    \item Security of disguise application restricted to $p$ if an attacker authenticates as $p$.
    \item Security of $p$'s private tokens and token metadata if \privk{p} is compromised.  
    \item Any privacy guarantees about information left after disguise application: \sys 
        simply applies a disguise according to the developer-provided specification.
        For example, a disguise may not modify data that leaks the writer's name (e.g., by leaving post content unmodified)
    \item Hiding which application data objects have been disguised. For example, the author of a
        paper may be replaced with ``anonymousFox'', leaking information that the paper has been
        disguised.
\end{itemize}

%-------------------------------------------------------------------------------
\subsection{Achieving Our Security Goals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Security of Restricted Disguise Application.}}
\sys ensures that only properly authenticated clients can apply or
reverse a disguise.  Achieving security goals (2) and (3) requires support for both global and
private disguise token storage, as shown in Table~\ref{tab:accpriv}.

\vspace{6pt}\noindent\textbf{\emph{(2) Security of Private Disguise Tokens.}}
For each disguise $d$, \sys encrypts private tokens associated with $p$ with a symmetric key
\symk{pd}. \sys then encrypts \symk{pd} with public key \pubk{p}.  A client needs to prove it has
\privk{p} by decrypting \symk{pd}, which only then allows decryption of $p$'s private tokens of
disguise $d$.
\lyt{Not mentioning the strawman solution that encrypts each token with \pubk{p} for now.}

\vspace{6pt}\noindent\textbf{\emph{(3) Security of Private Disguise Token Metadata.}}
\sys ensures it does not know how many private tokens belong to $p$ by storing
all private token ciphertexts in one large array, where nothing distinguishes $p_1$'s encrypted token
from $p_2$'s encrypted token.
%

The storage of \symk{pd} ciphertexts exposes another potential vector for metadata leakage: \sys stores \symk{pd} ciphertexts indexed by principal and disguise IDs.
To ensure that the presence of a \symk{pd} does not leak information about which principals' data has
been disguised, \sys stores a dummy ciphertext for every $q$ that $d$ does not disguise in the
array, such that every principal appears to have disguised data for every disguise.
\lyt{TODO implement dummy symks}.

\begin{table}[h]
\centering
    \begin{tabular}{ c c c }
        \textbf{Data} & \textbf{\sys?} & \textbf{p?}\\
\hline
        Database Contents & \checkmark & \checkmark \\
        Disguise History & \checkmark & \checkmark \\
        Global Disguise Tokens & \checkmark & \checkmark \\
        Global Disguise Token Metadata & \checkmark & \checkmark \\
        Private Disguise Tokens & & \checkmark \\
        Private Disguise Token Metadata & & \checkmark \\
\end{tabular}
    \caption{Desired data access policies.}
\label{tab:accpriv}
\end{table}

\iffalse
%Table~\ref{tab:dispriv} summarizes these changes.
\begin{table}[h]
\centering
    \begin{tabular}{ p{0.18\linewidth} p{.8\linewidth}}
        \textbf{Data} & \textbf{Disguise Effects}\\
\hline
        Database Contents & \sys modifies database contents, converting database rows to disguised
        versions according to the disguise specification.        
        \\ Disguise History & \sys appends a record of the disguise action to the history.\\
        Disguise Tokens & Each disguise database modification generates a token recording the
        modification. \sys saves global tokens in plaintext. For private tokens storing
        updates to $p$'s data, \sysencrypts them such with \pubk{p} and stores it in a bag with other private token ciphertexts.\\
\end{tabular}
\caption{Private setting effects of a disguise.}
\label{tab:dispriv}
\end{table}

%-------------------------------------------------------------------------------
\subsection{Strawman: Security in an Open Setting}
%-------------------------------------------------------------------------------
In the \emph{open setting}, no type of data is kept hidden from \sys: \sys reads and writes
application data, disguise history, and token data plaintext. Table~\ref{tab:accopen} shows the
different data types access policies, and Table~\ref{tab:disopen} describes the effects of a
disguise on each type of data.

\begin{table}[h]
\centering
    \begin{tabular}{ c c c }
        \textbf{Data} & \textbf{\sys?} & \textbf{p?}\\
\hline
        Database Contents & \checkmark & \checkmark \\
        Disguise History & \checkmark & \checkmark \\
        Disguise Tokens & \checkmark & \checkmark \\
        Disguise Token Metadata & & \checkmark & \checkmark \\
\end{tabular}
\caption{Open setting data access policies.}
\label{tab:accopen}
\end{table}

\begin{table}[h]
\centering
    \begin{tabular}{ p{0.18\linewidth} p{.8\linewidth}}
        \textbf{Data} & \textbf{Disguise Effect}\\
\hline
        Database Contents & \sys modifies database contents, converting database rows to disguised
        versions according to the disguise specification.        
        \\
        Disguise History & \sys appends a record of the disguise action to the history.\\
        Disguise Tokens & Each disguise database modification generates a token recording the
        modification, which \sys saves in plaintext.\\
\end{tabular}
\caption{Open setting effects of a disguise.}
\label{tab:disopen}
\end{table}

An open setting can achieve only security goal (1) via application
authentication a principal prior to applying a disguise.
However, clearly an open setting fails to support private disguise tokens or hide token metadata: an
attacker who compromises \sys can read all generated tokens.
To meet all security goals, we move to a private setting, in which \sys uses cryptographic
primitives to render tokens inaccessible to \sys without 
\fi
