%-------------------------------------------------------------------------------
\section{Design} 
%-------------------------------------------------------------------------------

\subsection{Disguise Specifications.} 
Because disguises are inherently application-specific, the application developer provides disguise
specifications that consist of a set of predicated disguise operations \op{d} to perform during the
disguise.

Operations \op{d} of disguise $d$ take data objects as input and execute updates to application
data.
\sys automatically generates database change records when applying \op{d}. 

Developers describe in the specification which principals an operation's generated database change record corresponds to. 
For example, a database change record generated by removing comment may correspond to the principal whose ID is referenced by the author column.  
A disguise specification also includes whether tokens produced by disguise application are private
to a principal, or global.

Developers also specify an application-aware pseudoprincipal generation policy, namely how to generate new
user accounts in a manner that the application can handle (e.g., pseudoprincipals may not have email
addresses).

\vspace{6pt}\noindent
Operations come in three forms:
\begin{enumerate}
    \item Modify: change an attribute of the data object.
    \item Remove: delete the data object.
    \item Decorrelate: generate a \emph{pseudoprincipal} $q$, and rewrite the foreign key to original
        principal $p$ from the data object to instead point to $q$.
        A pseudoprincipal may or may not be indistinguishable from a real principal: for example,
        $q$ may not have an associated password.
\end{enumerate}

\noindent For each \op{d}, the application developer specifies:
\begin{itemize}
    \item An associated predicate over the application database that selects \op{d}'s input
        objects in a SQL-like fashion.
    \item The type of operation and its arguments (e.g., which attributes of the data object to
        modify).
    \item The corresponding principal(s) that should be able to grant the produced permission (if
        private).
\end{itemize}

\noindent\textbf{\emph{Decorrelation and Private Key Tokens.}}
\lyt{TODO}
Decorrelation generates a public-private key pair \pubk{q} and \privk{q} for pseudoprincipal $q$
created during decorrelation.
\sys stores \pubk{q} associated with $q$'s user ID, and puts \privk{q} in a \emph{private key token}
associated with the original principal $p$ and $q$  (notated as \tpriv{pq}). \tpriv{pq} contains the following fields:
\begin{itemize}
\item \fn{principalID}: associated principal $p$
\item \fn{pseudoprincipalID}: generated pseudoprincipal $q$
\item \fn{pseudoPrincipalPrivateKey}: \privk{q}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent \sys protects \tpriv{pq} tokens by encrypting them with \pubk{p}. Only a client who has
\privk{p} can decrypt \tpriv{pq} and gain access to pseudoprincipal $q$'s private key \privk{q}.

\head{Database Change Records.}
Every \op{d} produces a \emph{database change record} \tdata{p\delta} associated with the disguise instance $\delta$ and a
principal $p$. 

\tdata{p\delta} contains the following fields, which record any changes made when applying \op{d}:
%
\begin{itemize}
\item \fn{tokenID}: unique ID for this token
\item \fn{disguiseID}: ID of disguise $d$ being applied
\item \fn{principalID}: associated principal $p$
\item \fn{objID}: unique ID for the data object modified by \op{d}
\item \fn{updateType}: decorrelate, modify, or remove
\item \fn{oldValue}: original value of object \fn{objID}
\item \fn{newValue}: updated value of object \fn{objID}
\item \fn{nonce}: random value generated to prevent known-plaintext attacks
\end{itemize}

\noindent\textbf{\emph{Database Change Records as Permissions.}}
database change records act as permissions in \sys; database change records are equivalent to permissions.
%
Possession of \tdata{p\delta} grants the following permissions:
\begin{itemize}
    \item Compose updates of $d'$ on top of updates of disguise $d$ to $p$
    \item Reveal updates performed by disguise $d$ to $p$ if no conflicting updates have been
        performed since
\lyt{This is slightly vague and may not handle all situations? \eg if the application made updates
        that don't conflict, but may be dependent on the status of the disguised object}.
\end{itemize}

\subsection{Security and Capabilities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Securing Permissions.}
\sys protects database change records \tdata{p\delta} by encrypting \tdata{p\delta} with a symmetric key \symk{p\delta}
specific to the disguise and principal. The token's nonce ensures safety against known-plaintext
attacks. \sys then encrypts \symk{p\delta} with public key \pubk{p}.  
%
Thus, only a client who has \privk{p} can decrypts \symk{p\delta} and thus enable \sys
to decrypt $p$'s database change records produced from applying $d$.

\sys stores all global \tdata{p\delta} tokens in plaintext, where any party can access it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Hiding Invoked Disguises Metadata.}
\sys's design may leak information that principal $p$ has been disguised by disguise
$d$ because an adversary may learn that ciphertexts for \symk{p\delta} and \tdata{p\delta} tokens exists for a particular $p$ and $d$.
This is a problem: for example, \sys should not store information that a principal $p$ has
invoked GDPR deletion.

To avoid this problem, \sys stores (1) the \symk{p\delta} ciphertext and (2) an array of \tdata{p\delta}
ciphertexts at random address \addr{p\delta} (e.g., a random number or string).
This dissociates one disguise applied to a principal $p$ from all other disguises, so an adversary only ever
learns about a single disguise if \sys gains permission to reveal or compose upon that disguise.

Note that an adversary can learn the number of \tdata{p\delta} tokens for each $p$ and $d$; this
metadata is out of scope of our threat model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{External Storage of \addr{p\delta}.} 
\sys should not store \addr{p\delta}: existence of \addr{p\delta} allows an adversary to
learn that disguise $d$ has applied to principal $p$. Thus, \addr{p\delta} must be stored externally,
even when no client speaking for $p$ is currently online.

The only exception to this is when $p$ is a pseudoprincipal: in this case, \sys saves a (globally
accessible) mapping from $p$ to \addr{p\delta}; this leaks disguise-principal associations, but only for pseudoprincipals whose data is already decorrelated from their original principal owner.

If $p$ is an actual principal, we consider two options: 

(1) \sys can email (or otherwise communicate)
\addr{p\delta} to a party that can authenticate as $p$. If no email is present (\eg $p$ is a pseudoprincipal),
\sys can save a (globally accessible) mapping from $p$ to \addr{p\delta}; this leaks disguise-principal associations, but
only for pseudoprincipals whose data is already decorrelated from their original principal owner.
\lyt{This assumes that every real user must have an email.}

(2) Alternatively, \sys can simply return the addresses back to the application; the application
then must handle the logic of contacting the respective parties and saving addresses externally.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Capabilities}
A capability \capa{p\delta} grants permissions to compose upon and reveal data from disguise $d$ and
principal $p$ (\ie access to database change records), and has components:
\begin{enumerate}
\item Address \addr{p\delta} at which encrypted \symk{p\delta} and \tdata{p\delta} ciphertexts are located
\item \privk{p}, the private key of $p$ that encrypts \symk{p\delta} (where \symk{p\delta} is required to
    decrypt the \tdata{p\delta} tokens and access permissions)
\end{enumerate}

In order for \sys to find \symk{p\delta} and \tdata{p\delta} ciphertexts, the client must provide \addr{p\delta}. 
The client must also then prove it has \privk{p} to decrypt \symk{p\delta}. Only with the
plaintext \symk{p\delta} can the array of \tdata{p\delta} ciphertexts be decrypted by \sys, and thus permit
\sys to reveal or compose upon disguise $d$'s updates for $p$.

Because \sys can access \addr{qd}s for pseudoprincipal $q$ without a client providing it, a client
only needs to prove it has \privk{q} to gain \capa{qd} for all $d$.  A client that can acquire
private key token \tpriv{pq} and decrypt it with \privk{p} can access \privk{q}, and gain the
capability to reveal or compose upon disguises' updates for pseudoprincipals $q$ of $p$. 

Note that each part of the capability in isolation is insufficient: an attacker who can spoof
\capa{p\delta} will not be able to access the plaintext of $p$'s records from $d$ without \privk{p}, although they can learn if $d$ disguised some of $p$'s data.

%-------------------------------------------------------------------------------
\subsection{Does this design achieve our security goals?}
\label{sec:achievegoals}
%-------------------------------------------------------------------------------
\vspace{6pt}\noindent\textbf{\emph{(1) Security of Restricted Disguise Application.}}
\sys ensures that only properly authenticated clients can apply or
reveal a disguise, achieving security goal (1).

\vspace{6pt}\noindent\textbf{\emph{(2) Security of Correlations.}}
\lyt{TODO}

\vspace{6pt}\noindent\textbf{\emph{(2) Security of Disguise Database Changes.}}
\sys encrypts \tdata{p\delta} tokens associated with $p$ with a symmetric key
\symk{p\delta} for each disguise $d$. \sys then encrypts \symk{p\delta} with public key \pubk{p}.  
A client needs to prove it has \privk{p} by decrypting \symk{p\delta}, which only then allows decryption
of $p$'s records from disguise $d$, achieving our goal to restrict access to $p$'s private
database change records (and thus secure permissions to compose upon or reveal data).
%Each private key token \tpriv{pq} is encrypted with \pubk{p}, and thus also requires a client to prove it has
%\privk{p} before the client can gain access to $q$'s private tokens.

\vspace{6pt}\noindent\textbf{\emph{(3) Security of Invoked Disguises Metadata.}}
We describe how \sys hides which disguises affect each principals' data by requiring a client to
provide a capability \addr{p\delta} in order to locate the encrypted token data from disguise $d$ applied
to (non-pseudoprincipal) $p$. Because \sys does not store these addresses, and the addresses are per-disguise, \sys
cannot link different disguises' encrypted token data to the same principal.


\iffalse
\begin{table}[t!]
\centering
\begin{tabular}{ c | c c }
    & \multicolumn{2}{c}{\textbf{\tdata{p\delta} Token Access}}\\
\textbf{Client Proof}& \textbf{Global} & \textbf{Private to $p$}\\
\hline
    $\emptyset$ & plaintext & \\
    \privk{p} & plaintext & \\
    \capa{p\delta} & plaintext & ciphertext \\
    \privk{p}, \capa{p\delta} & plaintext & plaintext \\
\end{tabular}
\vspace{6pt}
\caption{Client access to disguise $d$'s tokens, depending on what proof the client can provide and the state of the tokens.}
\label{tab:access}
\end{table}

Table~\ref{tab:access} illustrates which clients can access a disguise $d$'s tokens, depending on
what the client presents as proof, and the state of the tokens.

\sys ensures that private tokens are properly secured such that only a client with private key
\privk{p} and capability \capa{p\delta} can access tokens produced by disguise $d$ associated with $p$.
%
Furthermore, \sys ensures that only a client with capability \capa{p\delta} can learn if a disguise $d$
applies to principal $p$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{Storing \tpriv{pq} Tokens.}
\tpriv{pq} tokens are encrypted with \pubk{p} and the resulting ciphertexts stored in one array
corresponding to the original principal $p$. These token ciphertexts are not separated by disguise
as \tdata{p\delta} ciphertexts are, since \tpriv{pq} tokens grant the holder authorization to access
tokens from any disguise for pseudoprincipal $q$.

\sys (and equivalently an attacker) cannot learn which disguises applied to principal $p$ from
observing the array of \tpriv{pq} ciphertexts. However, \sys can learn how many disguises were
applied to---and in particular, decorrelated---$p$'s data, as well as the number of pseudoprincipals
in the system linked to $p$. This metadata is out of scope of our threat model.
\fi
