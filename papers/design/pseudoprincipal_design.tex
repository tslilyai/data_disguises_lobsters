%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Disguising Anonymized Users}

\begin{table*}[t!]
\centering
    \begin{tabular}{ p{.5\linewidth} p{.5\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{GetEncryptedPseudoPrincipalPrivateKeys($p$, \lcapa{pd}) $\rightarrow$
        \fn{Vec<Enc($q$,\privk{q})>}} & Returns the set of encrypted pseudoprincipals and their
        private keys created when decorrelating $p$'s data for disguise $d$.
    \vspace{6pt}\\
    \fn{GetEncryptedLocatingCaps($p$) $\rightarrow$ \fn{Vec<Enc\pcapa{pd}>}} & 
        Returns the set of corresponding \lcapa{pd} encrypted with
        \pubk{p}, for all $d$ that applied to $p$. Nonempty only if $p$ is a pseudoprincipal.\\
    \end{tabular}
\caption{Additional Client-\sys API Calls for Asymmetric Encryption}
\label{tab:client_api_ext}
\end{table*}

To apply one disguise on top of another in a way that supports, \eg comment removal after universal
decorrelation, \sys must support \emph{pseudoprincipal diffs}, namely diffs associated with
pseudoprincipals. 

These diffs can occur after at least one disguise has been applied: subsequent disguises may
associate diffs with pseudoprincipals. For example, after universal decorrelation, every paper or
review correlates with a pseudoprincipal user. When \sys applies universal decorrelation,
decorrelation of all papers and reviews generates correlation diffs for these pseudoprincipals.

However, we now have a problem. Diffs are encrypted with \privk{p} and stored at \lcapa{pd}, and
\sys emails \lcapa{pd} to (potentially offline) clients so that \sys never holds onto \lcapa{pd}.
However, pseudoprincipals have no corresponding real user (and, for unlinkability, \sys cannot store
which real user each pseudoprincipal corresponds with). Thus, \sys has no way to communicate
\lcapa{pd} to a real user!
%, so pseudoprincipals' capabilities can either be insecurely stored by \sys, or lost forever!

We have three potential approaches to solve this problem. Two we see as strawmen because they fail
to meet our secury and use case goals respectively:
\begin{enumerate}
    \item \emph{Weak Security:} \sys can store \lcapa{pd} for pseudoprincipal $p$. This means
        an adversary will be able to learn $p$'s undisguised data, even if it had been disguised by
        $d$.

    \item \emph{Permanent Disguises:} \sys throws away \lcapa{pd} for pseudoprincipal $p$. This means that the
        disguise modifications are permanent, and no links (to determine ownership) between
        $p$ and other pseudoprincipals can be made. This affects temporary recorrelation, because
        decorrelation links between principals cannot be derived from discarded diffs.
\end{enumerate}

We next describe a third option, which meets our security and use
case goals at the cost of usability.

\head{Pseudoprincipal Private Keys.}
When a pseudoprincipal $p$ is generated to decorrelate data from $p_0$, \sys also generates a
keypair (\pubk{p}, \privk{p}) for $p$, and encrypts the private key of $p$ with \pubk{p_0},
producing $\enc(\pubk{p_0}, \privk{p})$.

\sys then encrypts \lcapa{pd} with \pubk{p} and stores only the ciphertext, allowing \sys to avoid
the need to send capabilities to some email address, while retaining strong security of $p$'s
database diffs. 

To achieve security (so no adversary can learn how many pieces of decorrelated data a principal
has), \sys stores both $\enc(\pubk{p_0}, \privk{p})$ and \lcapa{pd} at location \lcapa{p_0d}
along with $p_0$'s encrypted diffs from disguise $d$. \lcapa{p_0d}, held by the client, grants
access to all encrypted private keys associated with pseudoprincipals generated by $d$.

If $p_0$ itself is a pseudoprincipal, then \sys simply stores these ciphertexts associated with
$p_0$'s ID.  This implies that an adversary can learn that \emph{some} disguise has applied to and
decorrelated data from $p_0$, but \emph{only if} $p_0$ is a pseudoprincipal and therefore already
dissociated from the original principal's identity.  \lyt{How to integrate this into our threat
model???}

\head{Usability Analysis.}
A client speaking for $p_0$ first needs to prove it can access \privk{p} by decrypting the \privk{p}
ciphertext with \privk{p_0}. Only then can the client decrypt the encrypted \lcapa{pd} associated
with pseudoprincipal $p$ with \privk{p}. The pair of \privk{p} (the data capability) and \lcapa{pd}
then gives the client the ability to reveal, disguise, or perform application actions with access to
diffs from $d$ applying to $p$.

This introduces another round-trip for any client using the API: a client speaking for $p_0$ that
wants to reveal or compose on top of pseudoprincipal diffs must (1) query for all pseudoprincipal
\privk{p} ciphertexts associated with $p_0$ for all \lcapa{p_0d} (for all $d$); (2) recursively
query for all nested pseudoprincipal \privk{q} ciphertexts associated with $p$ for all \lcapa{pd};
and (3) actually invoke the action with the decrypted capability pairs.

This makes it difficult to implement a userflow where the user can click on a single URL to grant
\sys diff access: in this design, the user has to first retrieve all possible URLs, and make several
more round-trips to the application/\sys.

Table~\ref{tab:client_api_ext} shows the additional API calls added by \sys to support
pseudoprincipal diffs and anonymous user disguising. 
%\lyt{TODO protocol diagrams for this vs. the simple design without asymmetric encryption}

