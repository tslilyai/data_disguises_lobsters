\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.6\linewidth} }
\textbf{API Call} & \textbf{Description} \\
\hline
    \fn{RegisterPrincipal($\pubk{p}$)} & Registers $p$ as a principal whose data can be privately disguised. \\
    \fn{StartDisguise($d$, Option<$p$>)} & Begins the process of applying disguise $d$, optionally 
    on behalf of $p$.\\
    \fn{StartDisguiseReversal($d$, Option<$p$>)} & Begins the process of reversing disguise $d$,
    optionally on behalf of $p$.\\
    \fn{RequestTokenAccess(encSymKeys)} & Sent from \sys to a client authenticated as
    $p$, requesting the client decrypt all the encrypted symmetric keys in \fn{encSymKeys} with
    \privk{p} and uncover the corresponding \symk{pd}s. \\
    \fn{GrantTokenAccess(\{\symk{pd}\})} & Grants \sys permission, for all \symk{pd} in the
    argument, to decrypt any privately-stored \tdata{pd} and \tpriv{pdq} with \symk{pd}.
\end{tabular}
    \vspace{12px}
\caption{API Calls for Client Authenticated as Principal $p$}
\label{tab:api}
\end{table*}

\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.7\linewidth} }
\textbf{Function} & \textbf{Description} \\
\hline
    \fn{ReadPrivateTokens(\symk{pd})} & Decrypts all of $p$'s private tokens produced by disguise
    $d$ using \symk{pd}. \\
    \fn{ReadGlobalTokens($d$)} & Retrieves all global tokens produced by disguise $d$. \\
    \fn{ApplyDisguise($d$,tokens)} & Applies disguise $d$, selectively composing $d$'s
    updates with prior disguises using the tokens's data. \\
    \fn{\op{d}.execute(tokens)} & Executes the disguise operation \op{d}, composing the operation
    with prior disguises using the tokens' data.\\
    \fn{ReverseDisguise($d$,tokens)} & Reverses disguise $d$ using the tokens' data.\\
    \fn{ReverseTokenOp(token)} & Reverses the data modification performed by the disguise operation
    that produced the token.\\
    \fn{StorePubKey($\pubk{p}$)} & Persistently saves the public key \pubk{p} indexed by $p$.\\
    \fn{LoadPubKey($p$)} & Retrieves public key \pubk{p} for $p$.\\
    \fn{LoadEncSymKey($p,d$)} & Retrieves \symk{pd} ciphertext.\\
    \fn{LoadEncSymKeys($p$)} & Retrieves \symk{pd} ciphertexts for all previously applied disguises $d$.\\
    \fn{StoreEncSymKey($p,d$)} & Persistently saves the \symk{pd} ciphertext indexed by $p$ and $d$.\\
    %\fn{VerifySymKey($p,d$,symKey)} & Verifies that the symmetric key plaintext has not been falsified by the client\\
    \fn{LoadListTail}$(p,d)$ & Gets the first encrypted private token in \tokls{pd}, the list of
    tokens associated with $p$ produced by $d$.\\
    \fn{StoreListTail}$(p,d)$ & Persistently saves the first encrypted private token in \tokls{pd}
    indexed by $p$ and $d$.
\end{tabular}
    \vspace{12px}
\caption{Internal \sys functions}
\label{tab:funcs}
\end{table*}

\begin{figure*}[h!]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Principal p} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    (\pubk{p}, \privk{p}) \sample \kgen() \<\< \\
\< \sendmessageright*{\texttt{RegisterPrincipal(p,$\pubk{p}$)}} \< \\
\<\< \texttt{StorePubKey($\pubk{p}$)}
}
\caption{\textbf{Principal public key registration.}}
\label{fig:acctreg}
\end{figure*} 

\begin{figure*}[h]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Client Authenticated as $p$} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
    \< \sendmessageright*{\fn{StartDisguise($d$)}} \< \\
\<\< \fn{symKeyCiphertxts} \gets \fn{LoadEncKeys}(p)\\
\< \sendmessageleft*{\fn{RequestTokenAccess(symKeyCiphertxts)}} \< \\
\texttt{symKeys} \gets \{\}\\
\pcforeach \fn{encSymKey} \in \fn{symKeyCiphertxts}:\\
\quad \symk{pd'} \gets \dec(\privk{p}, \fn{encSymKey})\\
\quad \pcif \text{authorizes access to $d'$-produced tokens}: \\
    \quad\quad\texttt{symKeys.insert(\symk{pd'})} \<\< \\
\quad\pcfi\\
\pcendforeach\\
\< \sendmessageright*{\texttt{GrantTokenAccess(\texttt{symKeys})}} \< \\
% TODO we need to not retrieve all global tokens??? only for disguises that might conflict
\<\< \texttt{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \pcforeach \symk{pd'} \in \texttt{symKeys}: \\
\<\< \quad\texttt{tokens.insert(\fn{ReadPrivateTokens(\symk{pd'})})}\\ 
\<\< \pcendforeach\\
\<\< \texttt{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Authenticated disguise application.} 
The client first invokes the \fn{StartDisguise} API call, authenticated as principal $p$.  
    Prior to applying the disguise, \sys requests to access $p$'s private tokens by sending a
    \fn{RequestTokenAccess} to the client with all \symk{pd} ciphertexts for all $d$ in the disguise
    history.  \\
    The client decrypts the ciphertexts if it has $p$'s private key \privk{p} (proving
    that the client has access to $p$'s private tokens).  \\
    The client only includes the decrypted \symk{pd'} in the set of keys sent back to \sys via a
    \fn{GrantTokenAccess} API call if the client wants to authorizes access to $p$'s private tokens
    from disguise $d'$. \\
    \sys uses each \symk{pd'} to decrypt $p$'s private tokens produced by disguise $d'$. 
    \sys combines all decrypted private tokens with the set of globally accessible tokens to produce
    all tokens available for disguise composition of $d$ on top of $d'$. 
    \lyt{Note: this requires that a client be authenticated as $p$ to access $p$'s tokens, which
    isn't necessarily fundamental.}}
    \label{fig:authdisapp}
\end{figure*}

\begin{figure*}[h]
\pcb{
\<\< \\[-0.9\baselineskip]\\
\textbf{Unauthenticated Client} \< \< \textbf{\sys} \\
[0.1\baselineskip][\hline]
\<\< \\[-0.9\baselineskip]\\
\< \sendmessageright*{\fn{StartDisguise($d$)}} \< \\
\<\< \texttt{tokens} \gets \{\}\\
\<\< \pcforeach d'~\text{in the disguise history}: \\
\<\< \quad\texttt{tokens.insert(\fn{ReadGlobalTokens}($d'$))}\\ 
\<\< \pcendforeach\\
\<\< \texttt{ApplyDisguise($d$,tokens)}
}
    \caption{\textbf{Unauthenticated disguise application}. In contrast to authenticated disguise
    application, \sys does not request access to any private tokens, and instead simply applies the disguise  
    with only globally-accessible tokens.}
    \label{fig:unauthdisapp}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure*}
\procb{\texttt{ApplyDisguise}($d$,\texttt{tokens})}{
\< \\
\t[0]\pcforeach \op{d}:\\
\t[1]\fn{opTokenPrincipalPairs} \gets \texttt{\op{d}.execute(tokens)}\\
\t[1]\pcforeach (\fn{token}, p) \in \fn{opTokenPrincipalPairs}:\\
\t[2]\pcif \texttt{token.isPrivate()}:\\
\t[3]\pcif \texttt{LoadEncSymKey($p,d$) = NULL}:\\
\t[4] \symk{pd} \sample \kgen() \\
\t[4] \pubk{p} \gets \texttt{LoadPubKey}(c) \\
\t[4] \texttt{encSymKey} \gets \enc(\pubk{p}, \symk{pd}) \\
\t[4] \texttt{StoreEncSymKey($p$,$d$,encSymKey)} \\
\t[3]\pcfi\\
\t[3]\symk{pk} \gets \texttt{LoadEncSymKey($p,d$)}\\
\t[3]\texttt{token.nextEncToken} \gets \texttt{LoadListTail}(p,d)\\
\t[3]\texttt{token.nonce} \gets \texttt{RandomU64}()\\
\t[3]\texttt{encToken} \gets \enc(\symk{pd}, \texttt{token})\\
\t[3]\texttt{StoreListTail}(p,d,\texttt{encToken})\\
\t[2]\pcelse\\
\t[3]\fn{StoreGlobalToken}(p,d,\texttt{token})\\
\t[2]\pcfi\\
\t[1]\pcendforeach\\
\pcendforeach\\
\t[0]\pcforeach p \in \fn{application principals}:\\
\t[1]\pcif \texttt{LoadEncSymKey($p,d$) = NULL}:\\
\t[2] \texttt{($p$,$d$,dummyEncSymKey)} \\
\t[2] \texttt{StoreListTail}(p,d,\texttt{dummyToken})\\
\t[1]\pcfi\\
\t[0]\pcendforeach\\
\t[0]\fn{\sys.DisguiseHistory.append(Apply($d$))}
}{}
\caption{\textbf{ApplyDisguise Pseudocode.} \sys applies a disguise given the disguise
specification and available tokens for composition.\\
    Every operation produces a set of (token, principal) pairs.
For each such pair of token and principal $p$, if the token should be private, then \sys generates symmetric key
 \symk{pd} if it does not yet exist, encrypts it with \pubk{p}, and stores the resulting ciphertext. 
    This ensures that only a client with \privk{p} can decrypt and access \symk{pd}. \\
\sys then encrypts the private token with \symk{pd} and stores the ciphertext as the tail of
    \tokls{pd}s.\\
    If the disguise operation is global, \sys simply stores the token plaintext indexed by principal and
    disguise.\\
    After performing all operations, \sys stores a dummy encrypted symmetric key and token list tail pointer for all
    principals whose data was not disguised by $d$.\\
    Finally, \sys logs the completed disguise application in the disguise history.
\label{fig:appdisg}
}
\end{figure*}

\begin{figure*}
\procb{\texttt{\op{d}.execute(tokens)}}{
    \< \\
    %Apply updates to tokens of disguise $d$\\
    %Migrate tokens
    %Generate the appropriate tokens for decor/remove/modify\\
}{}
\caption{\textbf{Operation Execution Pseudocode.}}
    \label{fig:opexec}
\end{figure*}

\begin{figure*}
\procb{\texttt{ReverseDisguise}($d$,\texttt{tokens})}{
\< \\
\t[0]\pcforeach \tdata{pd'} \in \fn{tokens}:\\
\t[1]\pcif d' == d:\\
\t[2] \fn{ReverseTokenOp(\tdata{pd'})}\\
\t[1]\pcfi\\
\t[0]\pcendforeach\\
\t[0]\fn{\sys.DisguiseHistory.append(Reverse($d$))}
}{}
\caption{\textbf{ReverseDisguise Pseudocode.}}
\label{fig:revdisg}
\end{figure*}

\begin{figure*}
\procb{\texttt{ReverseTokenOp(token)}}{
    \< \\
    %\texttt{Apply missed updates from disguise log to tokens of disguise $d$}\\
}{}
\caption{\textbf{ReverseTokenOp Pseudocode.}}
    \label{fig:revtoken}
\end{figure*}

\begin{figure*}
\procb{\texttt{ReadPrivateTokens(\symk{pd})}}{
    \< \\
\texttt{tokens} \gets []\\
\t[0]\texttt{encToken} \gets \texttt{LoadListTail}(p,d)\\
\t[0]\pcwhile \texttt{encToken != NULL:}\\
\t[1]\texttt{token} \gets \dec(\symk{pd}, \texttt{encToken})\\
\t[1]\pcif \texttt{token.isPrivateKeyToken():}\\
\t[2]p' \gets \texttt{token.anon\_uid}\\
\t[2]\privk{p'} \gets \texttt{token.priv\_key}\\
\t[2]\fn{encSymKeys} \gets \texttt{LoadEncSymKeys}(p')\\
\t[2]\pcforeach \fn{encSymKey} \in \fn{encSymKeys}:\\
\t[3]\symk{p'd'} \gets \dec(\privk{p'}, \fn{encSymKey})\\
\t[3]\texttt{tokens.extend(ReadPrivateTokens(\symk{p'd'}}))\\
\t[2]\pcendforeach\\
\t[1]\pcelse:\\
\t[2]\texttt{tokens.append(token)}\\
\t[1]\pcfi\\
\t[1]\texttt{encToken} \gets \texttt{token.nextEncToken}\\
\t[0]\pcendwhile\\
\pcreturn \texttt{tokens}\\
}{}
\caption{\textbf{ReadPrivateTokens Pseudocode.} Using \symk{pd}, \sys decrypts all tokens produced by the application of $d$ to $p$'s data by iterating through a linked list encoded in the token contents.\\
If the decrypted token is a \tdata{pd}, \sys simply adds the token to the set of tokens to return. 
Otherwise, if the token is a \tpriv{pdp'}, then \sys learns the
private key \privk{p'} of pseudoprincipal $p'$ generated during $d$'s application. \sys uses
\privk{p'} to decrypt all \symk{p'd'},  namely any symmetric keys used to encrypt
$p'$'s private tokens during application of any prior disguise $d'$.\\
    \sys then recursively reads all of $p'$'s private tokens by invoking \fn{ReadPrivateTokens}
    with \symk{p'd'}, and appends the result to the set of data tokens to return.\\
}
    \label{fig:rpt}
\end{figure*}

