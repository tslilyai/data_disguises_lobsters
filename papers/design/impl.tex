%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing Disguising}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.7\linewidth} }
\textbf{Function} & \textbf{Description} \\
\hline
    \fn{ReadPrivateTokens(\symk{pd})} & Decrypts all of $p$'s private tokens produced by disguise
    $d$ using \symk{pd}. \\
    \fn{ReadGlobalTokens($d$)} & Retrieves all global tokens produced by disguise $d$. \\
    \fn{ApplyDisguise($d$,tokens)} & Applies disguise $d$, selectively composing $d$'s
    updates with prior disguises using the tokens's data. \\
    \fn{\op{d}.execute(tokens)} & Executes the disguise operation \op{d}, composing the operation
    with prior disguises using the tokens' data.\\
    \fn{ReverseDisguise($d$,tokens)} & Reverses disguise $d$ using the tokens' data.\\
    \fn{ReverseTokenOp(token)} & Reverses the data modification performed by the disguise operation
    that produced the token.\\
    \fn{StorePubKey($\pubk{p}$)} & Persistently saves the public key \pubk{p} indexed by $p$.\\
    \fn{LoadPubKey($p$)} & Retrieves public key \pubk{p} for $p$.\\
    \fn{LoadEncPrivKeyTokens($p$)} & Retrieves \tpriv{pdq'} ciphertexts for $p$.\\
    \fn{LoadEncSymKeys(caps)} & Retrieves \symk{pd} ciphertexts corresponding to the specified
    capabilities.\\
    \fn{StoreEncSymKey(\rptr{pd})} & Persistently saves the \symk{pd} ciphertext indexed by
    capability \rptr{pd}.\\
    \fn{LoadListTail}$(p,d)$ & Gets the first encrypted private token in \tokls{pd}, the list of
    tokens associated with $p$ produced by $d$.\\
    \fn{StoreListTail}$(p,d)$ & Persistently saves the first encrypted private token in \tokls{pd}
    indexed by $p$ and $d$.
\end{tabular}
    \vspace{12px}
\caption{Internal \sys functions}
\label{tab:funcs}
\end{table*}

Table~\ref{tab:funcs} describe \sys's internal functions run server-side to implement its API 
and apply or reverse disguises. 

Figures~\ref{fig:appdisg} and \ref{fig:revdisg} describe how \sys implements disguise application and
reversal respectively. Figure~\ref{fig:opexec} describes how disguise operations update application
state and produce and modify tokens, and 
Figure~\ref{fig:revtoken} describes how \sys uses a token's recorded
modification to reverse an applied disguise operation. 
Figure~\ref{fig:rpt} describes how \sys accesses the private tokens
corresponding to disguise $d$ and principal $p$ by recursively decrypting tokens and traversing
\tokls{pd}.

\sys's implementations of the remaining functions in Table~\ref{tab:funcs} simply read or write into
persistent maps indexed by principal and/or disguise.

\subsection{Composition Techniques}
\sys's algorithm for disguising and disguise reversal in most scenarios is straightforward. 

To apply disguise $d$, \sys applies each \op{d} to all
data objects satisfying \op{d}'s predicate, while also taking into account the information in
accessible tokens (to \eg predicate against undisguised versions of objects). Each \op{d} produces
one or more tokens, which \sys stores appropriately (globally, or encrypted in a \tokls{pd}).

For reversal of disguise $d$, \sys reveals the undisguised version of data stored in accessible tokens
corresponding to $d$ by updating the relevant objects $O$ in the database.

However, \sys must be careful of two potential problems:
(1) \sys cannot accidentally reveal data that must be disguised; and (2) \sys cannot let global
tokens recording updates to data $x$ leak information if $x$ is subsequently (privately) disguised.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Preventing Accidental Data Revealing.}}
\sys records the disguised state of data $x$ in each \tdata{pd} recording a update performed by $d$
to $x$. If the state of $x$ does not match the disguised state in $d$'s token for $x$, then \sys
knows the token records an overwritten update to $x$, and refuses to reveal the undisguised state of $x$
stored in the token.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Preventing Global Token Information Leakage.}}
%The ONLY REASON we need to update tokens is if they're global!!! If they're private, we can use the
%retroactive application method... (optimization to update our "own" tokens though)
%
Let $d_1$ be a global disguise and $d_2$ be a private disguise applied in sequence.  Consider the
scenario in which \op{d_1} updates a data object $O$, producing a global token \tdata{pd_1}. Later,
\sys determines that \op{d_2} also should update $O$.
%by checking if the corresponding \op{d_2}
%predicate matches recorded object data stored in \tdata{pd_1}.

If \sys simply performs \op{d_2}'s update to $O$ in the application database, an adversary can still
read undisguised data from \tdata{pd_1} since is it global and records a now-stale state of $O$!
%
%Furthermore, this means that \sys cannot restore the state of $O$ in the database to
%\xhist{[\app{d_2}]} when reversing $d_1$, because the revealing the data in \tdata{pd_1} would
%reveal data that $d_2$ should have disguised.
%
To prevent global tokens like \tdata{pd_1} from leaking information that should be disguised, \sys
updates the data in \tdata{pd_1} with \op{d_2}'s update. An update to a token such as \tdata{pd_1}
itself generates a (private) token \tdata{pd_2}, just as updating a data object generates a token.

Reversing $d_2$ uses this \tdata{pd_2} to reverse the modification to \tdata{pd_1}. 
If $d_1$ has already been reversed, and the database state of $O$ updated to reflect the contents
of \tdata{pd_1} (which were updated by the application of $d_2$), 
then \sys simply uses \tdata{pd_2} to reverse the current state of $O$ in the database. 

If a future $d_3$ has further updated \tdata{pd_1} in a way that conflicts with $d_2$'s update, then
upon reversal of $d_2$, \sys will notice that \tdata{pd_2} records an overwritten update to
\tdata{pd_1}, and will not revert the state of \tdata{pd_1} until the future disguise $d_3$ has been
reversed.

\lyt{Note that removal is just an interesting case of this, in which \tdata{pd_1} is removed, by a
token \tdata{pd_2} is stored in \tokls{pd_2} that saves the removal of \tdata{pd_1} for reversal.}

%\vspace{6pt}\noindent\textbf{\emph{Token Modification for Object Identification.}}
%Tokens need to refer to the correct objects even if objects have been modified by future disguises.
%Prior tokens should be revised by future disguises so that they apply correctly to the disguised
%data.
%This allows an earlier disguise to be reversed correctly.
%An easy way to avoid needing to do this is to have all objects in the DB have unique, permanent
%identifiers.


