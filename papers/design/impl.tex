%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing Disguising}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Table~\ref{tab:funcs} describe \sys's internal functions run server-side to implement its API 
and apply or reverse disguises. 

Figures~\ref{fig:appdisg} and \ref{fig:revdisg} describe how \sys implements disguise application and
reversal respectively. Figure~\ref{fig:opexec} describes how disguise operations update application
state and produce and modify tokens, and 
Figure~\ref{fig:revtoken} describes how \sys uses a token's recorded
modification to reverse an applied disguise operation. 
Figure~\ref{fig:rpt} describes how \sys accesses the private tokens
corresponding to disguise $d$ and principal $p$ by recursively decrypting tokens and traversing
\tokls{pd}.

\sys's implementations of the remaining functions in Table~\ref{tab:funcs} simply read or write into
persistent maps indexed by principal and/or disguise.

\subsection{Composition Techniques}
\sys's algorithm for disguising and disguise reversal in most scenarios is straightforward. 

For application, \sys applies an \op{d} to all
data objects satisfying \op{d}'s predicate, while also taking into account the information in
accessible tokens (to \eg predicate against undisguised versions of objects). Each \op{d} produces
one or more tokens, which \sys stores appropriately (globally, or encrypted in a \tokls{pd}).

For reversal of disguise $d$, \sys reveals the undisguised version of data stored in accessible tokens
corresponding to $d$ by updating the relevant objects $O$ in the database.

However, in certain scenarios, \sys must apply additional techniques to achieve the semantics
described in \S\ref{sec:comp} while retaining security guarantees. We next describe the techniques
of \emph{retroactive disguise application}, \emph{retroactive disguise reversal}, and \emph{global
token modification}.

\vspace{6pt}\noindent\textbf{\emph{Retroactive Disguise Application.}}
In certain scenarios, \sys must retroactively apply a disguise in order to achieve the end states
described in Table~\ref{tab:composeapprev1}. 

Concretely, consider the history [\app{d_1},\app{d_2}].  As we described in composing disguise
applications, \appcomptwo may be the only possible outcome for \ohist{[\app{d_1},\app{d_2}]}: if $d_1$'s tokens
about $O$ tokens are private to principal $p$, and $d_2$ is invoked by an unauthenticated client or
a client authenticated as a different principal $q$, then some \op{d_2} may not update $O$ because
its predicate only matches again \ohist{[\app{d_1}]}.

However, even in this case, \sys needs to ensure that \ohist{[\app{d_1},\app{d_2},\rev{d_1}]}
achieves the semantics described in Table~\ref{tab:composeapprev1}. In particular, even when $d_1$'s
tokens are private to $p$, a client authorized as $p$ should be able to reverse $d_1$ such that the
state of $O$ is \ohist{[\app{d_2}]}, namely $d_2$ applied to \ostart. 

This requires \sys to retroactively apply $d_2$ during reversal of disguise $d_1$, when \sys has
access to $d_1$'s private tokens for $p$. \sys can use these private tokens to reveal \ostart, and
then match each \op{d_2}'s predicate with \ostart to see if \op{d_2} should update $O$.

\sys uses the disguise history to know what disguises to retroactively apply when a prior disguise
reveals token data.
\lyt{Disguising should based on only contents of data in application database, and
not predicated \eg on the current time.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Retroactive Disguise Reversal.}}
% NOTE TODO this is an issue in a history that does rev d2 after rev d1, not the ones shown above..
In certain scenarios, \sys must retroactively reverse a disguise. 

Concretely, consider the history $H = [\app{d_1},\app{d_2},\rev{d_1},\rev{d_2}]$.
We expect that \ohist{H} is equivalent in \ostart.

When $d_1$'s tokens for $O$ are accessible by the client reversing $d_1$, achieving this requires
only having access to $d_2$'s tokens (as shown in Table~\ref{tab:composeapprev1}).

However, if the client reversing $d_2$ does not have access to $d_1$'s tokens, then'
then \sys cannot restore the state to \ostart unless . 

TODO 

\sys logs the reversal of $d_1$ in the disguise history, and uses this history to detect if it
should reverse any conflicting updates performed by $d_1$ when $d_2$ is reversed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Global Token Modification to Prevent Information Leakage.}}
%The ONLY REASON we need to update tokens is if they're global!!! If they're private, we can use the
%retroactive application method... (optimization to update our "own" tokens though)
%
Let $d_1$ be a global disguise and $d_2$ be a private disguise applied in sequence.  Consider the
scenario in which \op{d_1} updates a data object $O$, producing a global token \tdata{pd_1}. Later,
\sys determines that \op{d_2} also should update $O$ 
%by checking if the corresponding \op{d_2}
%predicate matches recorded object data stored in \tdata{pd_1}.

If \sys simply performs \op{d_2}'s update to $O$ in the application database, an adversary can still
read undisguised data from \tdata{pd_1} since is it global and records a now-stale state of $O$!
%
%Furthermore, this means that \sys cannot restore the state of $O$ in the database to
%\ohist{[\app{d_2}]} when reversing $d_1$, because the revealing the data in \tdata{pd_1} would
%reveal data that $d_2$ should have disguised.
%
To prevent global tokens like \tdata{pd_1} from leaking information that should be disguised, \sys
updates the data in \tdata{pd_1} with \op{d_2}'s update. An update to a token such as \tdata{pd_1}
itself generates a (private) token \tdata{pd_2}, just as updating a data object generates a token.

Reversing $d_2$ uses this \tdata{pd_2} to reverse the modification to \tdata{pd_1}. 
If $d_1$ has already been reversed, and the database state of $O$ updated to reflect the contents
of \tdata{pd_1} (which were updated by the application of $d_2$), 
then \sys simply uses \tdata{pd_2} to reverse the current state of $O$ in the database. 

If a future $d_3$ has further updated \tdata{pd_1} in a way that conflicts with $d_2$'s update,
then upon reversal of $d_2$, \sys will notice that \tdata{pd_2} records a stale update to \tdata{pd_1}, 
and will not revert
the state of \tdata{pd_1} until the future disguise $d_3$ has been reversed.

\lyt{Note that removal is just an interesting case of this, in which \tdata{pd_1} is removed, by a
token \tdata{pd_2} is stored in \tokls{pd_2} that saves the removal of \tdata{pd_1} for reversal.}

%\vspace{6pt}\noindent\textbf{\emph{Token Modification for Object Identification.}}
%Tokens need to refer to the correct objects even if objects have been modified by future disguises.
%Prior tokens should be revised by future disguises so that they apply correctly to the disguised
%data.
%This allows an earlier disguise to be reversed correctly.
%An easy way to avoid needing to do this is to have all objects in the DB have unique, permanent
%identifiers.


