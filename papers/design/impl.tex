%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing Disguising}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table*}[t!]
\centering
\begin{tabular}{ c p{.7\linewidth} }
\textbf{Function} & \textbf{Description} \\
\hline
    \fn{ReadPrivateTokens(\symk{pd})} & Decrypts all of $p$'s private tokens produced by disguise
    $d$ using \symk{pd}. \\
    \fn{ReadGlobalTokens($d$)} & Retrieves all global tokens produced by disguise $d$. \\
    \fn{ApplyDisguise($d$,tokens)} & Applies disguise $d$, selectively composing $d$'s
    updates with prior disguises using the tokens's data. \\
    \fn{\op{d}.execute(tokens)} & Executes the disguise operation \op{d}, composing the operation
    with prior disguises using the tokens' data.\\
    \fn{ReverseDisguise($d$,tokens)} & Reverses disguise $d$ using the tokens' data.\\
    \fn{ReverseTokenOp(token)} & Reverses the data modification performed by the disguise operation
    that produced the token.\\
    \fn{StorePubKey($\pubk{p}$)} & Persistently saves the public key \pubk{p} indexed by $p$.\\
    \fn{LoadPubKey($p$)} & Retrieves public key \pubk{p} for $p$.\\
    \fn{LoadEncSymKey($p,d$)} & Retrieves \symk{pd} ciphertext.\\
    \fn{LoadEncSymKeys($p$)} & Retrieves \symk{pd} ciphertexts for all previously applied disguises $d$.\\
    \fn{StoreEncSymKey($p,d$)} & Persistently saves the \symk{pd} ciphertext indexed by $p$ and $d$.\\
    %\fn{VerifySymKey($p,d$,symKey)} & Verifies that the symmetric key plaintext has not been falsified by the client\\
    \fn{LoadListTail}$(p,d)$ & Gets the first encrypted private token in \tokls{pd}, the list of
    tokens associated with $p$ produced by $d$.\\
    \fn{StoreListTail}$(p,d)$ & Persistently saves the first encrypted private token in \tokls{pd}
    indexed by $p$ and $d$.
\end{tabular}
    \vspace{12px}
\caption{Internal \sys functions}
\label{tab:funcs}
\end{table*}

Table~\ref{tab:funcs} describe \sys's internal functions run server-side to implement its API 
and apply or reverse disguises. 

Figures~\ref{fig:appdisg} and \ref{fig:revdisg} describe how \sys implements disguise application and
reversal respectively. Figure~\ref{fig:opexec} describes how disguise operations update application
state and produce and modify tokens, and 
Figure~\ref{fig:revtoken} describes how \sys uses a token's recorded
modification to reverse an applied disguise operation. 
Figure~\ref{fig:rpt} describes how \sys accesses the private tokens
corresponding to disguise $d$ and principal $p$ by recursively decrypting tokens and traversing
\tokls{pd}.

\sys's implementations of the remaining functions in Table~\ref{tab:funcs} simply read or write into
persistent maps indexed by principal and/or disguise.

\subsection{Composition Techniques}
\sys's algorithm for disguising and disguise reversal in most scenarios is straightforward. 

For application, \sys applies an \op{d} to all
data objects satisfying \op{d}'s predicate, while also taking into account the information in
accessible tokens (to \eg predicate against undisguised versions of objects). Each \op{d} produces
one or more tokens, which \sys stores appropriately (globally, or encrypted in a \tokls{pd}).

For reversal of disguise $d$, \sys reveals the undisguised version of data stored in accessible tokens
corresponding to $d$ by updating the relevant objects $O$ in the database.

However, in certain scenarios, \sys must apply additional techniques to achieve the semantics
described in \S\ref{sec:comp} while retaining security guarantees. We next describe the techniques
of \emph{retroactive disguise application}, \emph{retroactive disguise reversal}, and \emph{global
token modification}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Retroactive Disguise Application.}}
\sys must sometimes retroactively apply a disguise in order to achieve the end states
described in Table~\ref{tab:composeapprev1}. 

Concretely, consider the history [\app{d_1},\app{d_2}].  As we described in composing disguise
applications, \appcomptwo may be the only possible outcome for \ohist{[\app{d_1},\app{d_2}]}: if $d_1$'s tokens
about $O$ tokens are private to principal $p$, and $d_2$ is invoked by an unauthenticated client or
a client authenticated as a different principal $q$, then some \op{d_2} may not update $O$ because
its predicate only matches again \ohist{[\app{d_1}]}.

However, even in this case, \sys needs to ensure that \ohist{[\app{d_1},\app{d_2},\rev{d_1}]}
achieves the semantics described in Table~\ref{tab:composeapprev1}. In particular, even when $d_1$'s
tokens are private to $p$, a client authorized as $p$ should be able to reverse $d_1$ such that the
state of $O$ is \ohist{[\app{d_2}]}, namely $d_2$ applied to \ostart. 

This requires \sys to retroactively apply $d_2$ during reversal of disguise $d_1$, when \sys has
access to $d_1$'s private tokens for $p$. \sys can use these private tokens to reveal \ostart, and
then match each \op{d_2}'s predicate with \ostart to see if \op{d_2} should update $O$.

\sys uses the disguise history to know what disguises to retroactively apply when a prior disguise
reveals token data.
\lyt{Disguising should based on only contents of data in application database, and
not predicated \eg on the current time.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Retroactive Disguise Reversal.}}
In certain scenarios, \sys must retroactively reverse a disguise. 
Concretely, consider the history $H = [\app{d_1},\app{d_2},\rev{d_1},\rev{d_2}]$.
\sys logs the reversal of $d_1$ in the disguise history. 

As discussed in \S\ref{sec:comp}, executing \rev{d_1} cannot reveal data disguised by $d_2$. To
ensure that \rev{d_1} is properly reflected when $d_2$ is reversed, \sys retroactively executes
\rev{d_1} if \rev{d_2} is invoked, using the disguise history to determine if \rev{d_1} had been invoked before.

However, clearly \sys can only retroactively apply \rev{d_1} if the client invoking \rev{d_2} has
access to the relevant $d_1$ tokens, which results in the outcomes shown in
Table~\ref{tab:composeapprev2}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{6pt}\noindent\textbf{\emph{Global Token Modification to Prevent Information Leakage.}}
%The ONLY REASON we need to update tokens is if they're global!!! If they're private, we can use the
%retroactive application method... (optimization to update our "own" tokens though)
%
Let $d_1$ be a global disguise and $d_2$ be a private disguise applied in sequence.  Consider the
scenario in which \op{d_1} updates a data object $O$, producing a global token \tdata{pd_1}. Later,
\sys determines that \op{d_2} also should update $O$ 
%by checking if the corresponding \op{d_2}
%predicate matches recorded object data stored in \tdata{pd_1}.

If \sys simply performs \op{d_2}'s update to $O$ in the application database, an adversary can still
read undisguised data from \tdata{pd_1} since is it global and records a now-stale state of $O$!
%
%Furthermore, this means that \sys cannot restore the state of $O$ in the database to
%\ohist{[\app{d_2}]} when reversing $d_1$, because the revealing the data in \tdata{pd_1} would
%reveal data that $d_2$ should have disguised.
%
To prevent global tokens like \tdata{pd_1} from leaking information that should be disguised, \sys
updates the data in \tdata{pd_1} with \op{d_2}'s update. An update to a token such as \tdata{pd_1}
itself generates a (private) token \tdata{pd_2}, just as updating a data object generates a token.

Reversing $d_2$ uses this \tdata{pd_2} to reverse the modification to \tdata{pd_1}. 
If $d_1$ has already been reversed, and the database state of $O$ updated to reflect the contents
of \tdata{pd_1} (which were updated by the application of $d_2$), 
then \sys simply uses \tdata{pd_2} to reverse the current state of $O$ in the database. 

If a future $d_3$ has further updated \tdata{pd_1} in a way that conflicts with $d_2$'s update,
then upon reversal of $d_2$, \sys will notice that \tdata{pd_2} records a stale update to \tdata{pd_1}, 
and will not revert
the state of \tdata{pd_1} until the future disguise $d_3$ has been reversed.

\lyt{Note that removal is just an interesting case of this, in which \tdata{pd_1} is removed, by a
token \tdata{pd_2} is stored in \tokls{pd_2} that saves the removal of \tdata{pd_1} for reversal.}

%\vspace{6pt}\noindent\textbf{\emph{Token Modification for Object Identification.}}
%Tokens need to refer to the correct objects even if objects have been modified by future disguises.
%Prior tokens should be revised by future disguises so that they apply correctly to the disguised
%data.
%This allows an earlier disguise to be reversed correctly.
%An easy way to avoid needing to do this is to have all objects in the DB have unique, permanent
%identifiers.


