\begin{figure*}
\procb{\texttt{ReadPrivateTokens(\symk{pd})}}{
    \< \\
\texttt{tokens} \gets []\\
\t[0]\texttt{encToken} \gets \texttt{LoadEncTokenListTail}(p,d)\\
\t[0]\pcwhile \texttt{encToken != NULL:}\\
\t[1]\texttt{token} \gets \dec(\symk{pd}, \texttt{encToken})\\
\t[1]\texttt{encToken} \gets \texttt{token.nextEncToken}\\
\t[1]\pcif \texttt{token.type = AnonPrivateKey:}\\
\t[2]p' \gets \texttt{token.anon\_uid}\\
\t[2]\privk{p'} \gets \texttt{token.priv\_key}\\
\t[2]\eks{p'} \gets \texttt{LoadEncKeys}(p')\\
\t[2]\pcforeach \ek{p'd'} \in \eks{p'}:\\
\t[3]\symk{p'd'} \gets \dec(\privk{p'}, \ek{p'd'})\\
\t[3]\texttt{tokens.extend(ReadPrivateTokens(\symk{p'd'}}))\\
\t[2]\pcendforeach\\
\t[1]\pcelse:\\
\t[2]\texttt{tokens.append(token)}\\
\t[1]\pcfi\\
\t[0]\pcendwhile\\
\pcreturn \texttt{tokens}\\
}{}
\caption{\textbf{ReadPrivateTokens Pseudocode.} Using \symk{pd}, \sys decrypts all tokens produced by the application of $d$ to $p$'s data by iterating through a linked list encoded in the token contents.\\
If the decrypted token is a \tdata{pd}, \sys simply adds the token to the set of tokens to return. 
Otherwise, if the token is a \tpriv{pdp'}, then \sys learns the
private key \privk{p'} of anonymous principal $p'$ generated during $d$'s application. \sys uses
\privk{p'} to decrypt all \symk{p'd'},  namely any symmetric keys used to encrypt
$p'$'s private tokens during application of any prior disguise $d'$.\\
    \sys then recursively reads all of $p'$'s private tokens by invoking \fn{ReadPrivateTokens}
    with \symk{p'd'}, and appends the result to the set of data tokens to return.\\
}
\end{figure*}

\begin{figure*}
\procb{\texttt{ApplyDisguise}($d$,\texttt{tokens})}{
\< \\
\t[0]\pcfor \texttt{op}_{p} \in \texttt{GetDisguise($d$)}:\\
\t[1]\pcif \texttt{LoadEncKey($p,d$) = NULL}:\\
\t[2] \symk{pd} \sample \kgen() \\
\t[2] \pubk{p} \gets \texttt{LoadPubKey}(c) \\
    \t[2] \texttt{\ek{pd}} \gets \enc(\pubk{p}, \symk{pd}) \\
\t[2] \texttt{StoreEncKey(\ek{pd})} \\
\t[1]\pcfi\\
\t[1]\symk{pk} \gets \texttt{LoadEncKey($p,d$)}\\
\t[1]\texttt{token} \gets \texttt{op$_{p}$.execute(composition\_tokens)}\\
\t[1]\texttt{token.nextEncToken} \gets \texttt{LoadEncTokenlistTail}(c,d)\\
\t[1]\texttt{token.nonce} \gets \texttt{RandomU64}()\\
\t[1]\texttt{encToken} \gets \enc(\symk{pd}, \texttt{token})\\
\t[1]\texttt{StoreEncTokenListTail}(p,d,\texttt{encToken})\\
\pcendfor
}{}
\caption{\textbf{ApplyDisguise Pseudocode.} \sys applies a disguise given the disguise
specification and available \tdata{} tokens for composition.
For each principal $p$ whose data is touched by the disguise, \sys generates symmetric key
 \symk{pd}, encrypts it with \pubk{p}, and stores the resulting \ek{pd} ciphertext. This ensures that only a client with the correct private key can decrypt and access \symk{pd}. 
\sys then applies each disguise operation, producing tokens for each operation. If the disguise is
1p-revealable, \sys encrypts tokens with the corresponding principals' \symk{pd}s and stores
these tokens as the tails of the principals' linked list of
encrypted tokens. This is shown in Fig~\ref{fig:algos}.
If the disguise operation, \sys simply stores the token plaintexts.
}
\end{figure*}

\begin{figure*}
\procb{\texttt{ReverseDisguise}$(d$,\texttt{tokens})}{
    \< \\
    \texttt{Apply missed updates from disguise log to tokens of disguise $d$}\\
    \texttt{Reveal data in tokens of disguise $d$}\\
    \texttt{Undo modifications to any prior disguise's tokens by disguise $d$}
}{}

\caption{\sys Algorithms (assuming all tokens are user-vault encrypted tokens, and ignoring global vault tokens for now)}
\label{fig:algos}
\end{figure*}
