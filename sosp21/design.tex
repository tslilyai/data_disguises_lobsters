%-------------------------------------------------------------------------------
\section{Data Disguising}
%-------------------------------------------------------------------------------
\begin{figure}[t!]
    \centering
    \includegraphics[width=0.5\textwidth]{img/disguises}

    \caption{Disguises move the target object (in this example, a user Bob) from an identity-revealing
    guise to privacy-preserving guises.}
    \label{fig:example}
\end{figure}

%\lyt{TODO (Frans): drive w/explicit example of table rows and foreign key relationships, too
%abstract. Start with Figure~\ref{fig:arch}?}

\begin{figure*}[t!]
    \centering
    \footnotesize
\begin{tabular}{@{}c|c|c|c@{}}
\textbf{User Transformation Spec} & \textbf{User Object} & \textbf{Guise 1} &
    \textbf{Guise 2} \\
\begin{lstlisting}[language=Rust]
"id":       IDAttribute,
"name":     Gen(Random),
"active":   Gen(Default(false)),
"darkmode": CopyAll,
"notifs":   CopyOnce+Gen(Default(false)),
"tag_id":   GenForeignKey,
\end{lstlisting}
    &
\begin{lstlisting}[language=Rust]
"id":       19,
"name":     BobParr,
"active":   true,
"darkmode": false,
"notifs":   true,
"tag_id":   11
\end{lstlisting}
&
\begin{lstlisting}[language=Rust]
"id":       295,
"name":     MrIncredible,
"active":   false,
"darkmode": false,
"notifs":   true,
"tag_id":   81483
\end{lstlisting}
&
\begin{lstlisting}[language=Rust]
"id":       918,
"name":     SuperDad,
"active":   false,
"darkmode": false,
"notifs":   false,
"tag_id":   15592
\end{lstlisting}
\end{tabular}
    \caption{Creating two guises of an example user (of a synthetic application schema).}
    \label{fig:guises}
\end{figure*}


%
The key idea behind \emph{data disguising} is to associate multiple \emph{guises} with a target
data object. Guises vary in how they reveal identities or preserve privacy.
%
Objects move between different guises by means of privacy transformations.
%
Figure~\ref{fig:example} illustrates this with the example of user account deletion.
%
When his account is active, user Bob's profile is associated with his true identity and all his
contributions to the site (an identity-revealing guise).
%
When Bob deletes his account, his profile and contributions move to different, privacy-preserving
guises: his name has been anonymized, his email address has been redacted, and his contributions
have been decorrelated and attributed to individual, unidentified user guises.
%

%
Data disguising builds on the existing structure of web applications.
%
Web applications are often structured as object graphs, either explicitly~\cite{tao, delf},
through an object-relational model (ORM)~\cite{orm}, or implicitly via foreign keys (edges)
between tables (vertices) in relational databases.
%
Data disguises transform this object graph.
%

%
The application developer writes a disguise specification for each privacy transformation needed
in the application.
%
This specification is a declarative statement similar to a relational schema, with entries for
graph vertices (objects) and directed edges (relationships between pairs of objects)
to be transformed (see \S\ref{sec:policies}).
%
We assume that:
\begin{enumerate}[nosep]
  \item developers use their domain knowledge to write correct and complete disguises;
    %\lyt{a bit worried about ``complete'' here}
  \item application code handles the different guises appropriately (\eg in
    displaying them); and
  \item different guises of the same object have the same structure (\eg they can be
    rows in the same table).
\end{enumerate}
%
A data disguising tool takes the disguise specification and turns it into storage operations that
apply the transformation (disguise) or its reverse (reveal).
%
% Malte: I don't think the following is fundamental
%The tool proxies application queries to its data storage, and exposes ``DISGUISE'' and
%``REVERSE DISGUISE" operations that invoke the disguise on transformation-triggering events
%(\eg user account deletion, data timeout, etc.).
%\lyt{This repeats the intro currently; perhaps we want to put it only there?}
%

%\begin{enumerate}[nosep]
  %\item application developers use their domain knowledge to write correct and complete
    %disguise specifications;
%\item \lyt{Not sure we need this?} application code invokes disguises via the disguising tool's API on
 %   transformation-triggering events (\eg user account deletion, data timeout, etc.); and
%  \item application code is prepared to handle the different guises appropriately (\eg in displaying
%      them); guises have the same structure as application objects (\eg exist as rows in existing
%        application tables).
%\end{enumerate}
%
At any given moment, an application's data object graph comprises a mix of
identity-revealing guises and privacy-preserving ones. Privacy transformations split
and combine individual guises when triggered.
%
%Using their application expertise, the developer selects from a menu of possible transformations
%(Section~\ref{sec:policies}) that can be performed on objects and object graph edges.
%The data disguise consists of the chosen set of transformations, and determines the
%structure of the object graph after a target (\eg the unsubscribing user) is disguised.
%
%Disguising a target object creates \emph{guises}---transformed versions and/or copies of the target.
%Disguising requires object deletion and anonymization: guises help maintain referential integrity
%when data is deleted, and transform objects into anonymized forms.  Guises additionally decorrelate
%other objects from the target: for example, a new guise for the user can be created in the users
%table, and the foreign key relationship from a row in the posts table rewritten to point this guise,
%to decorrelate the post from the user.

%-------------------------------------------------------------------------------
\section{Specifying Data Disguises}
%-------------------------------------------------------------------------------
\label{sec:policies}

%
Data disguises involve transformations on object types and edge types in the
application object graph.
%
A disguising tool applies these transformations by traversing the graph starting from a
developer-specified target object, such as a deleted user.
%
%The developer chooses one transformation for each object type, and
%one for each edge type.
%Object type transformations specify how to transform a template object of that type into guises; edge type
%transformations specify whether to delete, retain, or decorrelate edges of that type.
%where decorrelation replaces the edge with edges to guises.

%We next describe a menu of object and edge transformations sufficient to write disguises for the
%privacy transformations in Section~\ref{sec:survey}.

\subsection{Creating Guises for Objects}
\label{sec:guises}
%
To create a guise from an object, developers specify how to transform attributes of the
object into guise attributes.
%
Figure~\ref{fig:guises} shows an example, producing guises for user objects.
%
User objects have identifier \texttt{id}; a reference \texttt{tag\_id}
forms an edge in the graph (a foreign key constraint to tag objects).
%

%An object has three kinds of attributes: a unique identifier attribute; value
%(non-referential) attributes such as timestamps or usernames; and edge (\eg foreign key)
%attributes that refer to other objects.
%


%
Guises always have unique, random identifiers.
%
Developers choose how to create other guise attributes, selecting from among the following:
%
\paragraph{(1) Copy object content.}
%
Guises of the same object all share the object's attribute values.
%
If the attribute is an edge attribute (\eg a foreign key column), all guises will have
edges to the same object.
%
%
Copying allows developers to retain the object's content, without worrying about how to
synthesize attribute values for guises.
%
%However, this should only be chosen if guise attribute
%values cannot be generated, or if this attribute says little about the true identity of the
%entity.
For example, in Figure~\ref{fig:guises} the \texttt{darkmode} attribute is copied in
all guises.
%; the \texttt{darkmode} attribute reveals very little about the underlying user's
%identity.

\paragraph{(2) Generate new content.}
%
To create new attributes, developers specify whether the guise's value should be random,
a default value, or generated from the object's attribute value via a custom function (\eg hashing 
the value).
%
Figure~\ref{fig:guises} illustrates an example of random (\texttt{name}) and default
(\texttt{active}) generated value attributes.
%
%
Creating new guise edge attributes (\eg new foreign key relationships) requires
creating a new guise for the referenced object in order to maintain referential
integrity;
the data disguise rewrites the edge to point to the new guise.
%
In Figure~\ref{fig:guises}, creating two user guises requires creating two
tag guises, and the tag guises' identifiers become the user guises' foreign keys.
%

\paragraph{(3) Copy object content, but only once.}
%
One guise copies the attribute value from the object, but all other guises generate new
values (as described above).
%
\texttt{notifs} in Figure~\ref{fig:guises} illustrates how the attribute is copied once.
%
This enables the application to retain the original object semantics (\eg a count of how many
users want notifications) without creating duplicates.
%

\subsection{Transforming Edges Between Objects}
\label{design:edgepol}
%
Edge transformations specify how a disguise restructures the object graph as it
recursively traverses edges from the target.
%
% SOURCE = CHILD
% DEST = PARENT
Edges have a \emph{source} object and a \emph{destination} object, where the source references
the destination (\eg via a foreign key column in a relational database).
%
The developer specifies transformations for each edge type, choosing from the following:
%
\begin{enumerate}[nosep]
    %
    \item \textbf{Retain} edges of this type.
    %
    Transforms both source and destination objects into a single guise each.
    %
    \item \textbf{Decorrelate} edges of this type.
    %
    Creates one guise of the destination object for each of the sources; replaces each source's
    edge to the destination with an edge to that unique guise.
    %
    \item \textbf{Delete} edges of this type.
    %
    Transforms the destination object into a single guise; removes the source and its descendants
    if otherwise unconnected.
    %
\end{enumerate}
%
An optional argument enables conditionally-applied edge transformations, \eg removing only
user-created tags, or removing tags only until the user's papers comprise less than
$10$\% of tagged papers. %; or transforming only in the child-parent direction.
%

\subsection{An Example Disguise}
\label{design:eg}
%
Consider disguising Bob when he deletes his HotCRP account.
%
Bob would prefer his papers and reviews to be unlinked from his identity.
%
HotCRP, on the other hand, would like to retain paper and review information that other users
find useful.
%
A careful selection of edge and object transformations achieves both.
%

%
To decorrelate reviews from Bob, the disguise \texttt{Decorrelate}s user-to-review edges.
%
This requires transforming Bob into one unique user guise per review.
%
The disguise generates guise attribute values using suitable defaults;
%
in particular, HotCRP users' \texttt{disabled} attribute is set for the guises,
ensuring that guises have no permissions and never review papers.
%

%
Bob is further linked to papers through conflicts, which can indicate coauthorship or a
reviewer conflict.
%
These conflicts are not reassigned to the new guises, since preserved
conflicts could reidentify Bob as the likely author of a review. Thus, the
conflict edges that link a disguised user to papers need a \texttt{Delete} annotation.
%
%% Edge directionality matters here: paper-to-conflict edges should not be removed, as doing so
%% could incorrectly allow conflicted users to see the paper!

The disguise \texttt{Retain}s all other edge types, ensuring that review and paper
artifacts remain correctly linked. Active reviewers still see the correct paper for their reviews,
and active authors see the correct reviews for their papers, albeit potentially authored by
anonymous, unlinkable guises of the original reviewer.
%
%Review and paper guises copy the original object, retaining paper and review information.
%
%\ms{Does this mean duplicate papers/reviews can show up?}

%
Unlike the current real-world HotCRP account deletion policy~\cite{hotcrp:privacy}, which
deletes all objects belonging to Bob, this disguise strikes a balance between decorrelating
Bob's identity from his reviews and papers, and maintaining useful information for other
HotCRP users.
%
Furthermore, it is easy to imagine extending this disguise to automatically disguise Bob
after some time (\eg 2 years after the conference), protecting his future research career
by hiding youthful reviewing sins.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
%By default, all \emph{sensitive} entities---entities transitively connected via
%parent-child edges to the mask's target entity---transform into with ghost entities.
%For example, in Figure~\ref{fig:edgepol}a, all reviews and papers of the unsubscribing user are by
%default replaced by ghosts.

%Any parent of a sensitive child is ghosted as well. This is not actually true; we retain the
%original parent entity, but allow it to be decorrelated
%\lyt{Child-to-Parent edges can have different ghost
%generation policies + edge policies than Parent-to-Child edges. I'm not sure if we should mention
%that here (seems too detailed?)}

\paragraph{Child-Parent Edge Transformations.}
Data masks also allow the developer to specify edge transformations in the child-parent direction,
namely from sensitive children to parents that are not descendants of the user.
%
For example, papers have both tags and users as parents. If an unsubscribed user authors all papers
with a particular tag, the developer may realize that the tag can reidentify the user, and want to
decorrelate the paper from the tag.

Because parents of sensitive children may have non-sensitive children (\eg many papers may share
tags with the user's papers), decorrelation and delete transformations in the child-parent direction
take a \textbf{sensitivity threshold} as an argument, which tells the mask how many edges need to be
decorrelated or deleted.

In the paper-tag example, a reasonable sensitivity threshold
might be $0.1$: fewer than 10\% of all papers with a specific tag key should be correlated with an
(unsubscribed) user.  Figure~\ref{fig:sensitivity} shows an example in which paper-tag edges are
decorrelated to meet a threshold of 0.5.

\paragraph{Edge Transformation Filters}
For decorrelation or delete transformations (in either parent-child or child-parent directions), the
developer can additionally specify an \textbf{edge filter}. The filter takes the parent and child
entities of the edge as inputs, and returns whether the entities satisfy the filter. If yes, the
edge is decorrelated or deleted; otherwise, the edge is retained.
%
For example, perhaps we want to remove tags from a user's papers (decorrelate paper-tag edges)
\emph{only if} the tags were created by the unsubscribing user.
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
\sys also handles user data management and storage.
While unsubscribing a user, \sys tracks all deletions and modifications to the database.
\sys encrypts this log with a per-user key, and stores this encrypted
blob in a dedicated application datastore (Figure~\ref{fig:arch}, step 5). The user key is secret-shared using a (2, 3)
threshold scheme~\cite{secretsharing} between the user, \sys, and a trusted third party (\eg
Amazon S3), so that the user can authorize \sys and the third party to restore the key if
the user forgets their share.
%Alternatively, the key can also be password-encrypted, which relies
%on the user not forgetting their password.
The user can optionally choose to store this encrypted data themselves
%(or in a third party cloud provider),
and be in charge of providing their data and key to \sys to decrypt the data upon
resubscription.

To resubscribe, a user authorizes the decryption of their data and associated metadata by
providing their share of the key (or authorizing a trusted third party to reconstruct the secret
with the application). \sys decrypts the data with the key, and systematically reverses
the modifications made during unsubscription, restoring removed entities and correlations between
entities.
\fi
