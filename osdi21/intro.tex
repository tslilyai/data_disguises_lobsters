%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

Web application companies face increasing legal requirements to protect users’ data. These
requirements pressure companies to properly delete and anonymize users' data when a user requests to
\emph{unsubscribe} from the service (i.e.,\ revoke access to their personal data). For example, the
GDPR requires that any data remaining after a user unsubscribes cannot be (directly or
indirectly) used to identify the user~\cite{gdpr}.  

In this paper, we propose \sys{}, which enables applications to meet the de-identification
requirements in the GDPR, and goes beyond: with \sys{}, it is possible for users to switch between a
privacy-preserving unsubscribed mode and an identity-revealing subscribed mode at any time without
permanently losing their data. This facilitates important new web service paradigms,
such as users granting a time-limited ``lease'' of data to a service instead of having a permanent
service account.

\sys{} provides strong de-identification properties by maximally \emph{decorrelating} a user's data
entities (e.g.,\ posts and upvotes) from each other and from the user's identity upon
unsubscription.  \sys{} makes the key observation that data entities can leak identifying
information in two ways: (1) directly via its content, and (2) indirectly via the correlations it has to
other data entities in the system.  
Correlations can range from obviously identifying (e.g.,\ posts correlated
with a user clearly belong to that user), to subtly perilous: posts correlated with a
particular user-generated tag most likely belong to the tag's author, and posts liked by the  
same group of users likely belong to a friend of the group. 

Many web applications have come up with solutions to address (1)
by anonymizing unique identifiers, often leaving arbitrary user-generated content out of scope.
However, this only addresses information leakage from single data entities in isolation.
\sys{}'s decorrelation additionally eliminates identifying information stemming from (2) by removing
correlations between data entities. 

Decorrelation breaks connections between data entities that would otherwise allow an adversary to
determine that two entities belong to the same (unsubscribed) user: post-decorrelation, an adversary
cannot distinguish between a scenario in which two data entities have been generated by two distinct
users, and one in which they were both generated by the same (unsubscribed) user.  If two of a
user's entities cannot be correlated back to the user, then at most one of these entities may leak
identifying information about the user.\footnote{Assume for a contradition that both entities leak
identifying information: then both entities are more likely to have been generated by a particular
identity than any other, contradicting our assumption.}  Thus, if single data entities are
appropriately anonymized (via methods to address leakage from a single entity's content), then
\sys{} prevents identifying information from being leaked via correlations.

Applications using \sys{} can easily and correctly decorrelate users' entities when users
unsubscribe by providing a high-level specification that captures the desired application semantics
for unsubscribed users. Furthermore, \sys{} automatically performs decorrelation in a way that
allows for recorrelation upon resubscription, while still achieving performance comparable to
today’s widely-used databases and requiring no modification of application schemas. 

\subsection{Threat Model} 
An adversary aims to relink decorrelated entities to unsubscribed users after \sys{}
performs decorrelation. We make the following assumptions about such an adversary: 
\begin{itemize}
    \item An adversary can perform only those queries allowed by the application API, 
i.e.,\ can access the application only via its public interface. 
\lyt{Alternatively, an adversary could perform arbitrary queries on some public subset of the
application schema (e.g., all tables other than the mapping table, or all tables marked with some
compliance policy); arbitrary queries over the
entirety of the table are out of scope, unless ``private'' tables are removed and stored by
unsubscribing users.}

    \item An adversary cannot perform application queries to the past or search web archives:
    information from prior application snapshots may reveal 
    exactly how data records were decorrelated from unsubscribed users. 

    \item An adversary cannot gain identifying information from arbitrary user-generated content (for
        example, a reposted screenshot, or text in user stories or comments). Decorrelation seeks to
        remove identifying information from user-generated data that can be enumerated or follows a
        specific pattern (e.g., a birthday or email address), and application metadata (e.g., date
        of postings, database ID columns).
\end{itemize}

\subsection{Decorrelation Design}
Application data is structured as tables, each containing a different \emph{data entity}, e.g.,\ a
story, user, or vote. Queries write, read from, and compute over entities.  All entities (e.g.,\
posts) that share a correlation with the same entity (e.g.,\ a user) form a \emph{cluster}
identified by that entity. In database terms, entities in the same cluster are identified by having
the same foreign key value (e.g.,\ a particular value for column \texttt{user\_id}). 

Decorrelation of a user breaks any clusters around the user into singleton clusters, each identified
by a unique ghost user. In essence, the user is exploded into many ghost user, each correlated with
only one of the user's data entities.

However, breaking up clusters around the user may not sufficiently decorrelate these entities from
the user. For example, stories belonging to the user may also cluster around a particular tag. Or
perhaps one of the user's stories is upvoted only by all of the users' friends (these upvotes
cluster around the story). These pieces of information allow an adversary to correlate a story back
to a single user, even when clusters around the user no longer exist.

The key observation here is that two types of clusters can still leak identifying information about
the user: (1) clusters identified by data entities owned by the users, and (2) clusters consisting
of the user's data entities, identified by other entities.  By breaking any such clusters into
singletons by introducing ghost entities (as was done with introducing ghost users), \sys{} removes
any identifying information leaked from correlations between user's data entities and other entities
in the application.

More generally, decorrelation must recursively break up any clusters that may recorrelate a data
entity back to the identifier of a broken-up cluster. Let $A$ and $B$ be entity types. Let $a \in A$ be the
entity being decorrelated. $a$ identifies at least one cluster $B_a \subseteq B$.
Decorrelation on $a$ does the following: 
\begin{enumerate}
    \item \textbf{Break direct clusters and recurse.} $a$ splits into ghost entities of type $A$, one for each entity
        $b\in B_a$. Decorrelation then runs on each cluster entity $b$.

    \item \textbf{Break clusters around identity substitutes and recurse.} 
        If more than one of the $b \in B_a$ is also in a cluster that is identified by an entity $c
        \in C$, then we decorrelate $c$ from its data. 
        
\end{enumerate}
For example, each story (the $b$) posted by a user $a$ belongs in a cluster $B_a$ identified by $a$.
Decorrelation step (1) reassigns each story to a ghost user. Then each story is itself decorrelated.
Decorrelation step (2) may find that a particular tag $c$ identifies at least two of the users'
stories (these stories belong in a cluster $B_c$ identified by $c$). The tag is then decorrelated to
ensure that nothing related to the tag may reassociate these stories with the same tag.  This
recursive decorrelation prevents any other correlations with the user's stories from leaking
identifying information about the stories' author.

\subsection{The Impact of Decorrelation}
Taken to the extreme, decorrelation strips any links to (real) application data from data entities
recursively related to the user via clusters. While this removes as much correlation-based
identifying information from the application as possible while keeping data entities available to
the application, completely decorrelated data entities may be useless to the application. Worse yet,
the noise and data pollution from ghost entities may instead affect the accuracy and semantics of
the application: users may see meaningless content, comment threads may be disjoint and scattered,
and highly-ranked content may suddenly lose votes.

On the other extreme, however, performing no decorrelation at all fails to adequately de-identify
users. \sys{} balances between the two extremes by decorrelating only to the extent allowed by the
application developer, as specified in by schema annotations on relationships that cannot be broken
(e.g.,\ votes clustered around stories). 

\paragraph{Maintaining aggregate accuracy.}
Queries that specifically perform aggregations and return statistical measures (e.g.,
the count of number of users in the system, or the number of stories per user), can return
significantly different results. This affects the utility of the data for the application: for
example, if the application relies on the number of stories per tag to determine hot topics, these
would be heavily changed if ghost tags were created.  In addition, the adversary may learn which
entities are ghosts: for example, an abnormally low count of stories per tag might indicate to an
adversary that these tags are ghost tags.  \lyt{But perhaps it's ok if an adversary can tell what's
a ghost, as long as it can't tell which user each ghost is correlated with.}

One solution is to analyze the aggregations performed by application queries, and then
introduce ghosts entities that lead to the same (or close-enough) aggregation result. For example,
if a tag is split into ghost tags, one per story associated with the tag, but the application still
would like the count of stories for this tag to be high, one of the ghost tags can be populated with
many ghost stories to retain the count of stories per tag. These ghost stories identifiers would be
uploaded upon recorrelation, allowing \sys{} to remove any ghost stories that were created. In this
situation, this creates a large number of ghost tags with only one story, which would only affect
application semantics if a query calculates the mean of number of stories per tag (which requires a
different way of populating tags with stories). Note that this solution may be impossible for  
certain combinations of aggregations (e.g., queries that return both the average stories per tag and also
the total number of stories).

A second solution would be to store and separately update answers to aggregation queries;
these answers would be updated when queries update the data tables.

\lyt{I don't *think* differential privacy really should be applied here, because we'd also face the
issue of running out of privacy budget. Adding noise might ensure that the impact of any one
(real/ghost) user is very little, but it has its own noise/utility tradeoff. Furthermore, the amount
of noise necessary if many ghost users are created might be too large.}

\paragraph{Maintaining application structure.}
Many applications allow queries to return individual entities (e.g., a particular story) in addition
to statistics and aggregations. Ghost entities muddy individual entities' data, and potentially
alter the application's structure in ways that render it meaningless. For example,
subreddits---similar to tags or categories---on Reddit create communities and social circles 
that are fundamental to how people interact on Reddit.
These subreddits may become nonsensical if many users unsubscribe and stories are
decorrelated from a particular subreddit.

To prevent these potentially disastrous scenarios, application developers can annotate which
entities do not need to be recursively decorrelated during the first step of decorrelation, which
breaks direct clusters. For example, perhaps the cluster of votes grouped by story does not leak any
identifying information, and thus stories do not need to be decorrelated.  The developer may also
indicate if the entity (e.g., the
story) does leak identifying information through its clusters but decorrelating it would destroy
application integrity, which results in the removal of the entity and its dependencies.
However, the entity cannot be restored upon resubscription in this case.

In the second step of decorrelation, we decorrelate identity substitutes only enough to be below a
\emph{correlation threshold} specified by the application developer. Again, if the application
developer annotates a particular entity as essential to the application structure and the
correlation threshold is exceeded, then the entity is entirely removed from the database. 

At a high level, the correlation threshold limits the ability of an adversary to use an identity
substitute as a proxy for a user's identity.  This correlation threshold is defined on a type of
entity $C$ as follows. Let $B_a$ be the set of entities of type $B$ clustered by $a$, the entity
undergoing decorrelation.  Let $c \in C$ be an entity that acts as an identity substitute for $a$, with
$B_c \subseteq B_a$ clustered by $c$. Let $B_{total}$ be the set of entities of type $B$ clustered
by $c$. The correlation threshold for the entity $c$ is the maximum value for the proportion $B_a /
B_{total}$. Thus, lowering the threshold increases the number of entities in $B_{total}$ that belong
to other users, and lowers the ability of the adversary to use $c$ to correlate the $b \in B_{c}$ to
a single identity.

For entities such as tags or categories, a reasonable correlation threshold might be 0.05: less than
5\% of all stories associated with that tag are allowed to cluster by one (unsubscribed) user. Note
that user entity types are always associated with a correlation threshold of 0: after a user
unsubscribes, no entities should be clustered by that user.

Note that meeting the threshold can be done by breaking up the entity $c$ into 
ghosts, each associated with a singleton $b \in B_c$, until the threshold is met. Another strategy
might pollute $B_{total}$ with \emph{new} ghost entities to lower the proportion, rather than
breaking up the cluster. 

\iffalse
\subsection{\sys{}: Instantiating the Decorrelation Model}
\sys{} is one potential architecture for implementing this model. In \sys{}, sensitive columns are
user ID fields (annotated by the application developer).  These user IDs are
numerical user keys \uidkey{} that are each unique to one user, and map entities to a particular
user. Entities containing multiple \uidkey{}s are considered shared among the identified users. 

\sys{} handles flows that contain sensitive entities belonging to unsubscribed users by anonymizing
the \uidkey{} column: the \uidkey{} is replaced by a unique ghost ID
(\gidkey{}) per entity belonging to the unsubscribed user. 
By replacing \uidkey{} values with \gidkey{} values, \sys{} ensures that the
computations on the dataflow decorrelate these entities with the unsubscribed user: an unsubscribed
user's data is split into individual pieces. 

While the model implies that actions are taken at runtime (when entities pass through query
operators), \sys{} implements actions on \uidkey{}s by storing the \gidkey{}s in the underlying
application data tables, saving a mapping of \gidkey{}s to \uidkey{} in the database, and
maintaining materialized views to answer application queries that expose real or ghost identifiers
depending on whether a particular user is subscribed. \sys{} implements a database shim layer that
transparently rewrites application queries to query the materialized view (the ``acted-upon''
result) rather than the data tables, and which propagates updates appropriately to the materialized
view. In essence, the materialized views cache the result of the actions taken after a query
operation such as a JOIN.

An alternative action might replace all unsubscribed users' \uidkey{}s with one \emph{global
placeholder} value, essentially collapsing all unsubscribed users' entities into one pool. However,
this erases all user-specific data, making resubscription and subsequent recorrelation of a user's
entities with the user's identity difficult. \sys{}'s ghost identifiers allows users to reactivate
their account and undo the decorrelation: \uidkey{}s can be linked back to a set of unique
\gidkey{}s.  This gives users the ability to freely unsubscribe to protect their privacy without
worrying about losing their accounts.  \lyt{Ghosts also make schema changes / changing the location
of data records easier to support.}

Furthermore, ghost IDs provide increased decorrelation guarantees: if decorrelation utilizes a
global placeholder and entities with \uidkey{}s are exposed by application queries, an attacker can
determine with 100\% certainty which queried entities are unsubscribed entities, namely any entity
with \uidkey{} equal to the global placeholder. If only one or a few users have unsubscribed,
correlating these unsubscribed entities back to one identity may be trivial.

However, if decorrelation instead relies on ghosts, an attacker cannot guarantee that any revealed
identifier is a ghost instead of a real (subscribed) user. Instead, the attacker must calculate the
probability that an identifier belongs to a ghost using external knowledge about identifiers (e.g.,
GIDs may be randomly generated in a identifiable pattern) or other information exposed by the
entity. This external, non-\uidkey{} information can be either marked sensitive (so \sys{} with
act upon these entity columns as well) or treated as out of scope.
\fi
