%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

Web application companies face increasing legal requirements to protect users’ data. These
requirements pressure companies to properly delete and anonymize users' data when a user requests to
\emph{unsubscribe} from the service (i.e.,\ revoke access to their personal data). For example, the
GDPR requires that any data remaining after a user unsubscribes cannot be (directly or
indirectly) used to identify the user~\cite{gdpr}.  

In this paper, we propose \sys{}, which enables applications to meet the de-identification
requirements in the GDPR, and goes beyond: with \sys{}, it is possible for users to switch between a
privacy-preserving unsubscribed mode and an identity-revealing subscribed mode at any time without
permanently losing their data. This facilitates important new web service paradigms,
such as users granting a time-limited ``lease'' of data to a service instead of having a permanent
service account.

\sys{} provides strong de-identification properties by maximally \emph{decorrelating} a user's data
entities (e.g.,\ posts and upvotes) from each other and from the user's identity upon
unsubscription.  \sys{} makes the key observation that data entities can leak identifying
information in two ways: (1) directly via its content, and (2) indirectly via the correlations it has to
other data entities in the system.  
Correlations can range from obviously identifying (e.g.,\ posts correlated
with a user clearly belong to that user), to subtly perilous: posts correlated with a
particular user-generated tag most likely belong to the tag's author, and posts liked by the  
same group of users likely belong to a friend of the group. 

Many web applications have come up with solutions to address (1)
by anonymizing unique identifiers, often leaving arbitrary user-generated content out of scope.
However, this only addresses information leakage from single data entities in isolation.
\sys{}'s decorrelation additionally eliminates identifying information stemming from (2) by removing
correlations between data entities. 

More precisely, decorrelation breaks connections between data
entities that would otherwise allow observers to determine that two entities belong to the same
(unsubscribed) user: it is equally as likely for the two data entities to have been generated by two
distinct users as it is for them to have been generated by the same user.  If two of a user's
entities cannot be correlated to the user, then at most one of these entities may leak identifying
information about the user.\footnote{Assume for a contradition that both entities leak identifying
information: then both entities are more likely to have been generated by a particular identity than
any other, contradicting our assumption.}  Thus, if single data entities are appropriately
anonymized (addressing (1)), then \sys{} prevents correlations between entities from leaking
identifying information.

enables these unsubscription-resubscription modes with 

Applications using \sys{} can easily and correctly decorrelate users'
entities when users unsubscribe by providing a high-level specification that captures the
desired application semantics for unsubscribed users. Furthermore, \sys{} automatically performs
decorrelation while achieving performance comparable to today’s widely-used databases and requiring
no modification of application schemas. 


\sys{} makes the key observation that data entities leak identifying
information through how they cluster. For example, posts are clustered by user identity: clearly,
posts correlated with the same user all identify the user. 



Clusters leak contextual information about the entity that 

Decorrelation breaks these connections, removing any contextual information about a data entity in
the application. On one extreme, decorrelating a data entity leaves it as a standalone: for example,
a decorrelated post would have no associated owner, story, votes, or parent. 


from every other entity in the
application removes this contextual information leakage completely.

On the other extreme, leaving all correlations in place
An entity's correlations form the context in which the entity
can be understood, and 



\sys{} relies on a developer-provided specification in order to determine 

\subsection{Threat Model} 
An adversary aims to relink decorrelated entities and reveal identifying connections after \sys{}
performs decorrelation. We make the following assumptions about such an adversary: 
\begin{itemize}
    \item An adversary can perform only those queries allowed by the application API, 
i.e.,\ can access the application only via its public interface. 
\lyt{Alternatively, an adversary could perform arbitrary queries on some public subset of the
application schema (e.g., all tables other than the mapping table, or all tables marked with some
compliance policy); arbitrary queries over the
entirety of the table are out of scope, unless ``private'' tables are removed and stored by
unsubscribing users.}

    \item An adversary cannot perform application queries to the past or search web archives:
    information from prior application snapshots may reveal 
    exactly how data records were decorrelated from unsubscribed users. 

    \item An adversary cannot gain identifying information from arbitrary user-generated content (for
        example, a reposted screenshot, or text in user stories or comments). Decorrelation seeks to
        remove identifying information from user-generated data that can be enumerated or follows a
        specific pattern (e.g., a birthday or email address), and application metadata (e.g., date
        of postings, database ID columns).
\end{itemize}

\subsection{Modeling Decorrelation}
Application data is structured as tables, each containing a different \emph{data entity}, e.g.,\ a
story, user, or vote.  
Queries write, read
from, and compute over entities. 

Decorrelation of a user entity splits the user into a set of \emph{ghost user} entities, with one
ghost user for each data entity that is \emph{clustered} by the user.  Clusters are determined by
foreign key attributes in data tables which correspond to user identifiers, or by attributes that
are used to JOIN with the user table.  For example, stories cluster by user because they contain a
foreign key attribute (\texttt{user\_id}) into the user table, specifying which user wrote the
story.

However, breaking up user-associated clusters of entities may not sufficiently decorrelate these
entities from the user. For example, perhaps only stories belonging to the user possess a particular
tag. Or perhaps the user's stories are all upvoted only by all of the users'
friends. These pieces of information allow an adversary to correlate a story back to a user's
identity without using the \texttt{user\_id} value. 

To prevent these information leaks, decorrelation of a user \emph{propagates} recursively through
entities associated with the user. To generalize decorrelation, let $a$ of entity type $A$ be the
entity being decorrelated. Then decorrelation on $a$ performs the following: 
\begin{enumerate}
    \item \textbf{Break Direct Clusters and Recurse.} $a$ splits into ghost entities of type $A$, one for each entity
        $b\in B$ which is clustered by $a$. Each cluster entity $b$ is recursively
        decorrelated from its data.

        For example, each story (the $b$) clustered by a user (the $a$) is reassigned to a ghost
        user. Then each story is itself decorrelated, splitting into one ghost story per vote on the
        story. If votes also have clusters, then the votes would also be decorrelated from these
        entities, and so on. This recursive decorrelation prevents structural information about the
        story (e.g., friends who liked the story) from leaking identifying information about who the
        story may belong to.

    \item \textbf{Decorrelate Identity Substitutes.} If more than one of the $b$ clustered by $a$ also
        clusters by entity $c \in C$, then we decorrelate $c$ from its data. 
        More formally, let $B_a$ be the set of entities of type $B$ clustered by $a$, the entity undergoing
        decorrelation.  Then $c$ is an identity substitute for $a$ if $\exists B_c$ such that
        \begin{itemize}
            \item $B_c \subseteq B_a$
            \item $|B_c| > 1$ 
            \item $B_c$ is a set of entities of type $B$ clustered by $c$
        \end{itemize}

        For example, a tag may act as an identity substitute if many of the stories associated with
        a \texttt{user\_id} are also associated with that tag, and the tag is then decorrelated.
\end{enumerate}

\subsection{Tradeoff: Ghost Entities vs. Utility}
Decorrelation fundamentally decreases the utility of data for the application: introducing
ghost entities and ghost associations decrease the amount of accurate information returned to
application queries. In essence, ghosts act as a mechanism to add noise to obfuscate a user's
presence in a dataset.

\paragraph{Maintaining aggregate accuracy.}
Queries that specifically perform aggregations and return statistical measures (e.g.,
the count of number of users in the system, or the number of stories per user), can return
significantly different results. This affects the utility of the data for the application: for
example, if the application relies on the number of stories per tag to determine hot topics, these
would be heavily changed if ghost tags were created.  In addition, the adversary may learn which
entities are ghosts: for example, an abnormally low count of stories per tag might indicate to an
adversary that these tags are ghost tags.  \lyt{But perhaps it's ok if an adversary can tell what's
a ghost, as long as it can't tell which user each ghost is correlated with.}

One solution is to analyze the aggregations performed by application queries, and then
introduce ghosts entities that lead to the same (or close-enough) aggregation result. For example,
if a tag is split into ghost tags, one per story associated with the tag, but the application still
would like the count of stories for this tag to be high, one of the ghost tags can be populated with
many ghost stories to retain the count of stories per tag. These ghost stories identifiers would be
uploaded upon recorrelation, allowing \sys{} to remove any ghost stories that were created. In this
situation, this creates a large number of ghost tags with only one story, which would only affect
application semantics if a query calculates the mean of number of stories per tag (which requires a
different way of populating tags with stories). Note that this solution may be impossible for  
certain combinations of aggregations (e.g., queries that return both the average stories per tag and also
the total number of stories).

A second solution would be to store and separately update answers to aggregation queries;
these answers would be updated when queries update the data tables.

\lyt{I don't *think* differential privacy really should be applied here, because we'd also face the
issue of running out of privacy budget. Adding noise might ensure that the impact of any one
(real/ghost) user is very little, but it has its own noise/utility tradeoff. Furthermore, the amount
of noise necessary if many ghost users are created might be too large.}

\paragraph{Maintaining application structure.}
Many applications allow queries to return individual entities (e.g., a particular story) in addition
to statistics and aggregations. Ghost entities muddy individual entities' data, and potentially
alter the application's structure in ways that render it meaningless. For example,
subreddits---similar to tags or categories---on Reddit create communities and social circles 
that are fundamental to how people interact on Reddit.
These subreddits may become nonsensical if many users unsubscribe and stories are
decorrelated from a particular subreddit.

To prevent these potentially disastrous scenarios, application developers can annotate which
entities do not need to be recursively decorrelated during the first step of decorrelation, which
breaks direct clusters. For example, perhaps the cluster of votes grouped by story does not leak any
identifying information, and thus stories do not need to be decorrelated.  The developer may also
indicate if the entity (e.g., the
story) does leak identifying information through its clusters but decorrelating it would destroy
application integrity, which results in the removal of the entity and its dependencies.
However, the entity cannot be restored upon resubscription in this case.

In the second step of decorrelation, we decorrelate identity substitutes only enough to be below a
\emph{correlation threshold} specified by the application developer. Again, if the application
developer annotates a particular entity as essential to the application structure and the
correlation threshold is exceeded, then the entity is entirely removed from the database. 

At a high level, the correlation threshold limits the ability of an adversary to use an identity
substitute as a proxy for a user's identity.  This correlation threshold is defined on a type of
entity $C$ as follows. Let $B_a$ be the set of entities of type $B$ clustered by $a$, the entity
undergoing decorrelation.  Let $c \in C$ be an entity that acts as an identity substitute for $a$, with
$B_c \subseteq B_a$ clustered by $c$. Let $B_{total}$ be the set of entities of type $B$ clustered
by $c$. The correlation threshold for the entity $c$ is the maximum value for the proportion $B_a /
B_{total}$. Thus, lowering the threshold increases the number of entities in $B_{total}$ that belong
to other users, and lowers the ability of the adversary to use $c$ to correlate the $b \in B_{c}$ to
a single identity.

For entities such as tags or categories, a reasonable correlation threshold might be 0.05: less than
5\% of all stories associated with that tag are allowed to cluster by one (unsubscribed) user. Note
that user entity types are always associated with a correlation threshold of 0: after a user
unsubscribes, no entities should be clustered by that user.

Note that meeting the threshold can be done by breaking up the entity $c$ into 
ghosts, each associated with a singleton $b \in B_c$, until the threshold is met. Another strategy
might pollute $B_{total}$ with \emph{new} ghost entities to lower the proportion, rather than
breaking up the cluster. 

\iffalse
\subsection{\sys{}: Instantiating the Decorrelation Model}
\sys{} is one potential architecture for implementing this model. In \sys{}, sensitive columns are
user ID fields (annotated by the application developer).  These user IDs are
numerical user keys \uidkey{} that are each unique to one user, and map entities to a particular
user. Entities containing multiple \uidkey{}s are considered shared among the identified users. 

\sys{} handles flows that contain sensitive entities belonging to unsubscribed users by anonymizing
the \uidkey{} column: the \uidkey{} is replaced by a unique ghost ID
(\gidkey{}) per entity belonging to the unsubscribed user. 
By replacing \uidkey{} values with \gidkey{} values, \sys{} ensures that the
computations on the dataflow decorrelate these entities with the unsubscribed user: an unsubscribed
user's data is split into individual pieces. 

While the model implies that actions are taken at runtime (when entities pass through query
operators), \sys{} implements actions on \uidkey{}s by storing the \gidkey{}s in the underlying
application data tables, saving a mapping of \gidkey{}s to \uidkey{} in the database, and
maintaining materialized views to answer application queries that expose real or ghost identifiers
depending on whether a particular user is subscribed. \sys{} implements a database shim layer that
transparently rewrites application queries to query the materialized view (the ``acted-upon''
result) rather than the data tables, and which propagates updates appropriately to the materialized
view. In essence, the materialized views cache the result of the actions taken after a query
operation such as a JOIN.

An alternative action might replace all unsubscribed users' \uidkey{}s with one \emph{global
placeholder} value, essentially collapsing all unsubscribed users' entities into one pool. However,
this erases all user-specific data, making resubscription and subsequent recorrelation of a user's
entities with the user's identity difficult. \sys{}'s ghost identifiers allows users to reactivate
their account and undo the decorrelation: \uidkey{}s can be linked back to a set of unique
\gidkey{}s.  This gives users the ability to freely unsubscribe to protect their privacy without
worrying about losing their accounts.  \lyt{Ghosts also make schema changes / changing the location
of data records easier to support.}

Furthermore, ghost IDs provide increased decorrelation guarantees: if decorrelation utilizes a
global placeholder and entities with \uidkey{}s are exposed by application queries, an attacker can
determine with 100\% certainty which queried entities are unsubscribed entities, namely any entity
with \uidkey{} equal to the global placeholder. If only one or a few users have unsubscribed,
correlating these unsubscribed entities back to one identity may be trivial.

However, if decorrelation instead relies on ghosts, an attacker cannot guarantee that any revealed
identifier is a ghost instead of a real (subscribed) user. Instead, the attacker must calculate the
probability that an identifier belongs to a ghost using external knowledge about identifiers (e.g.,
GIDs may be randomly generated in a identifiable pattern) or other information exposed by the
entity. This external, non-\uidkey{} information can be either marked sensitive (so \sys{} with
act upon these entity columns as well) or treated as out of scope.
\fi
