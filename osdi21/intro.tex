%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

Web application companies face increasing legal requirements to protect users’ data. These
requirements pressure companies to properly delete and anonymize users' data when a user requests to
\emph{unsubscribe} from the service (i.e.,\ revoke access to their personal data). For example, the
GDPR requires that any data remaining after a user unsubscribes cannot be (directly or
indirectly) used to identify the user~\cite{gdpr}.  

In this paper, we propose \sys{}, which enables applications to meet the de-identification
requirements in the GDPR, and goes beyond: with \sys{}, it is possible for users to switch between a
privacy-preserving unsubscribed mode and an identity-revealing subscribed mode at any time without
permanently losing their data. This facilitates important new web service paradigms,
such as users granting a time-limited ``lease'' of data to a service instead of having a permanent
service account.

\sys{} provides strong de-identification properties by maximally \emph{decorrelating} a user's data
entities (e.g.,\ posts and upvotes) from each other and from the user's identity upon
unsubscription.  \sys{} makes the key observation that data entities can leak identifying
information in two ways: (1) directly via its content, and (2) indirectly via the correlations it has to
other data entities in the system.  
Correlations can range from obviously identifying (e.g.,\ posts correlated
with a user clearly belong to that user), to subtly perilous: posts correlated with a
particular user-generated tag most likely belong to the tag's author, and posts liked by the  
same group of users likely belong to a friend of the group. 

Many web applications have come up with solutions to address (1)
by anonymizing unique identifiers, often leaving arbitrary user-generated content out of scope.
However, this only addresses information leakage from single data entities in isolation.
\sys{}'s decorrelation additionally eliminates identifying information stemming from (2) by removing
correlations between data entities. 

Decorrelation breaks connections between data entities that would otherwise allow an adversary to
determine that two entities belong to the same (unsubscribed) user: post-decorrelation, an adversary
cannot distinguish between a scenario in which two data entities have been generated by two distinct
users, and one in which they were both generated by the same (unsubscribed) user.  If two of a
user's entities cannot be correlated back to the user, then at most one of these entities may leak
identifying information about the user.\footnote{Assume for a contradition that both entities leak
identifying information: then both entities are more likely to have been generated by a particular
identity than any other, contradicting our assumption.}  Thus, if single data entities are
appropriately anonymized (via methods to address leakage from a single entity's content), then
\sys{} prevents identifying information from being leaked via correlations.

Applications using \sys{} can easily and correctly decorrelate users' entities when users
unsubscribe by providing a high-level specification that captures the desired application semantics
for unsubscribed users. Furthermore, \sys{} automatically performs decorrelation in a way that
allows for recorrelation upon resubscription, while still achieving performance comparable to
today’s widely-used databases and requiring no modification of application schemas. 

\subsection{Threat Model} 
An adversary aims to relink decorrelated entities to unsubscribed users after \sys{}
performs decorrelation. We make the following assumptions about such an adversary: 
\begin{itemize}
    \item An adversary can perform only those queries allowed by the application API, 
i.e.,\ can access the application only via its public interface. 
\lyt{Alternatively, an adversary could perform arbitrary queries on some public subset of the
application schema (e.g., all tables other than the mapping table, or all tables marked with some
compliance policy); arbitrary queries over the
entirety of the table are out of scope, unless ``private'' tables are removed and stored by
unsubscribing users.}

    \item An adversary cannot perform application queries to the past or search web archives:
    information from prior application snapshots may reveal 
    exactly how data records were decorrelated from unsubscribed users. 

    \item An adversary cannot gain identifying information from arbitrary user-generated content (for
        example, a reposted screenshot, or text in user stories or comments). Decorrelation seeks to
        remove identifying information from user-generated data that can be enumerated or follows a
        specific pattern (e.g., a birthday or email address), and application metadata (e.g., date
        of postings, database ID columns).
\end{itemize}

\subsection{Decorrelation Design}
Application data is structured as tables, each containing a different \emph{data entity}, e.g.,\ a
story, user, or vote. Queries write, read from, and compute over entities.  All entities (e.g.,\
posts) that share a correlation with the same entity (e.g.,\ a user) form a \emph{cluster}
identified by that entity. In database terms, entities in the same cluster are identified by having
the same foreign key value (e.g.,\ a particular value for column \texttt{user\_id}). 

Decorrelation of a user breaks any clusters around the user into singleton clusters, each identified
by a unique ghost user. In essence, the user is exploded into many ghost user, each correlated with
only one of the user's data entities.

However, breaking up clusters around the user may not sufficiently decorrelate these entities from
the user. For example, stories belonging to the user may also cluster around a particular tag. Or
perhaps one of the user's stories is upvoted only by all of the users' friends (these upvotes
cluster around the story). These pieces of information allow an adversary to correlate a story back
to a single user, even when clusters around the user no longer exist.

The key observation here is that two types of clusters can still leak identifying information about
the user: (1) clusters identified by data entities owned by the users, and (2) clusters consisting
of the user's data entities, identified by other entities.  By breaking any such clusters into
singletons by introducing ghost entities (as was done with introducing ghost users), \sys{} removes
any identifying information leaked from correlations between user's data entities and other entities
in the application.

More generally, decorrelation must recursively break up any clusters that may recorrelate a data
entity back to the identifier of a broken-up cluster. Let $A$ and $B$ be entity types. Let $a \in A$
be the entity being decorrelated. $a$ identifies at least one cluster $B_a \subseteq B$.
Decorrelation on $a$ does the following: 
\begin{enumerate} 
    
    \item \textbf{Break direct clusters and
            recurse.} $a$ splits into ghost entities $A_g \subseteq A$, one for each entity $b\in B_a$.
            Decorrelation then runs on each cluster entity $b$.
            
            Furthermore, if the $A_g$ are in a cluster identified by some entity $c$, $c$ is
            decorrelated.

    \item \textbf{Break clusters around identity proxies and recurse.} If more than one of the
        $b \in B_a$ is also in a cluster that is identified by an entity $c \in C$ (an identity
        ``proxy''), then we decorrelate $c$ from its data. 
        
\end{enumerate}
For example, each story (the $b$) posted by a user $a$ belongs in a cluster $B_a$ identified by $a$.
Decorrelation step (1) reassigns each story to a ghost user. Then each story is itself decorrelated.
If stories are decorrelated into a ghost story per vote, for example, then the votes would be
decorrelated. The ghost stories would cluster by the ghost user, so this ghost user would have to
further decorrelate.

Decorrelation step (2) may find that a particular tag $c$ identifies at least two of the users'
stories (these stories belong in a cluster $B_c$ identified by $c$). The tag is then decorrelated to
ensure that nothing related to the tag may reassociate these stories with the same tag.  This
recursive decorrelation prevents any other correlations with the user's stories from leaking
identifying information about the stories' author.

Ghost entities are generated by replacing foreign key attributes with a unique identifier drawn
from a random distribution; all other attributes can be replaced by default values, or
using application-specific generators (for example, a randomly generated username or phone number).
If foreign keys values are kept and consequently cluster the generated ghost entities, then these
foreign entities must be decorrelated to ensure that ghosts cannot be grouped back together.

\lyt{Given this ghost generation scheme, decorrelation of a story would then destroy story content
(essentially deleting the story... the user would not get this content back). A
smarter way to ghost stories may be to split up the content into ``pieces'', one per ghost story,
and encrypt these pieces so that ghost stories cannot be relinked together, but the user could
decrypt the pieces and reform the original story.}

\subsection{The Impact of Decorrelation}
Taken to the extreme, decorrelation strips any links to (real) application data from data entities
recursively related to the user via clusters. While this removes as much correlation-based
identifying information as possible while keeping data entities present, completely decorrelated
data entities may be useless to the application. Worse yet, the noise and data pollution from ghost
entities may instead affect the accuracy and semantics of the application: users may see meaningless
content, comment threads may be disjoint and scattered, and highly-ranked content may suddenly lose
votes. On the other extreme, however, performing no decorrelation at all fails to adequately de-identify
users. 

\sys{} balances between the two extremes by decorrelating only to the extent allowed by the
application developer. The developer provides schema annotations on relationships (foreign keys)
that cannot be broken (e.g.,\ votes related to stories) because they would create meaningless ghost
content or break application semantics. When possible, \sys{} measures the potential amount of identifying
information leaked by the retained correlations, and, depending on what the developer specifies,
either removes the entity entirely if a \emph{cluster threshold} is exceeded, or adds noise
until the amount of leaked information is below the threshold.  Furthermore, \sys{} allows for
entities to be decorrelated without affecting queries which specifically return aggregation results.

\paragraph{Specifying Decorrelation Behavior and Correlation Thresholds.}
Ghost entities muddy individual entities' data, and potentially alter the application's structure in
ways that render it meaningless. 
%For example, subreddits---similar to tags or categories---on Reddit
%create communities and social circles that are fundamental to how people interact on Reddit.  These
%subreddits may become nonsensical if many users unsubscribe and stories are decorrelated from a
%particular subreddit.
For example, perhaps it is meaningless to create ghost stories in order to break up clusters of
votes identified by story; or perhaps it would ruin the applications' recommendation-by-tag
semantics to create ghost tags.   To prevent these potentially disastrous scenarios, application developers
provide annotations on which entity types (database tables) that cannot be exploded into ghost
entities.  The application developer also indicates whether it is acceptable
to \emph{add} ghost entities to clusters if clusters cannot be broken, and if so, the mechanism to
generate these ghosts. 

\sys{} determines whether a still-correlated entity needs to be removed---its correlations expose
too much identifying information---by computing the proportion of entities in a cluster that are
related to the entity being decorrelated. This proportion is compared to a \emph{cluster threshold}
\lyt{(developer specified?  set by user?)}.

If \sys{} cannot decorrelate clusters identified by an entity (step 1), then \sys{} checks whether
it is possible to add ghost entities to the cluster. If yes, then \sys{} generates enough ghosts
such that the original cluster entities make up less than the cluster threshold proportion of
all entities in the cluster.  If this correlation threshold is exceeded, or the developer does not
allow for ghosts to be added to the cluster, \sys{} removes the entity and its dependencies.
However, the entity cannot then be restored upon resubscription.

If \sys{} cannot decorrelate an identity proxy (step 2), then \sys{} calculates what proportion of entities 
in proxy-identified clusters belong to the entity being decorrelated. If the proportion is below the
cluster threshold, no further actions are needed; otherwise, if the developer allows ghosts to be
added to the cluster, then \sys{} generates enough ghosts such that the proportion drops below the
threshold. Again, if the developer does not allow for ghosts to be added to the cluster, \sys{}
removes the proxy entity and its dependencies.

For entities such as tags or categories, a reasonable cluster threshold might be 0.05: less than
5\% of all stories identified by that tag should have been associated with an (unsubscribed) user. Note
that user entity types are always associated with a correlation threshold of 0: after a user
unsubscribes, no entities should be clustered by that user.

Note that even for entities for which decorrelation is acceptable, they may only need to be
decorrelated until their clusters meet the cluster threshold.

%At a high level, the correlation threshold limits the ability of an adversary to use an identity
%substitute as a proxy for a user's identity.  This correlation threshold is defined on a type of
%entity $C$ as follows. Let $B_a$ be the set of entities of type $B$ clustered by $a$, the entity
%undergoing decorrelation.  Let $c \in C$ be an entity that acts as an identity substitute for $a$, with
%$B_c \subseteq B_a$ clustered by $c$. Let $B_{total}$ be the set of entities of type $B$ clustered
%by $c$. The correlation threshold for the entity $c$ is the maximum value for the proportion $B_a /
%B_{total}$. Thus, lowering the threshold increases the number of entities in $B_{total}$ that belong
%to other users, and lowers the ability of the adversary to use $c$ to correlate the $b \in B_{c}$ to
%a single identity.
\paragraph{Maintaining aggregate accuracy.}
Queries that specifically perform aggregations and return statistical measures (e.g.,
the count of number of users in the system, or the number of stories per user), can return
significantly different results. This affects the utility of the data for the application: for
example, if the application relies on the number of stories per tag to determine hot topics, these
would be heavily changed if ghost tags were created.  In addition, the adversary may learn which
entities are ghosts: for example, an abnormally low count of stories per tag might indicate to an
adversary that these tags are ghost tags.  \lyt{But perhaps it's ok if an adversary can tell what's
a ghost, as long as it can't tell which user each ghost is correlated with.}

One solution is to analyze the aggregations performed by application queries, and then
introduce ghosts entities that lead to the same (or close-enough) aggregation result. For example,
if a tag is split into ghost tags, one per story associated with the tag, but the application still
would like the count of stories for this tag to be high, one of the ghost tags can be populated with
many ghost stories to retain the count of stories per tag. These ghost stories identifiers would be
uploaded upon recorrelation, allowing \sys{} to remove any ghost stories that were created. In this
situation, this creates a large number of ghost tags with only one story, which would only affect
application semantics if a query calculates the mean of number of stories per tag (which requires a
different way of populating tags with stories). Note that this solution may be impossible for  
certain combinations of aggregations (e.g., queries that return both the average stories per tag and also
the total number of stories).

A second solution would be to store and separately update answers to aggregation queries;
these answers would be updated when queries update the data tables.

\lyt{I don't *think* differential privacy really should be applied here, because we'd also face the
issue of running out of privacy budget. Adding noise might ensure that the impact of any one
(real/ghost) user is very little, but it has its own noise/utility tradeoff. Furthermore, the amount
of noise necessary if many ghost users are created might be too large.}
